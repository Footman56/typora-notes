# 一、基础运算

```
3 ** 2  == 3 * 3  就是n次方运算
3 % 2 = 1  -》 取余运算
9 // 4 = 2 -》 取模运算 
```

# 二、数据类型

```
list :可以容纳不同类型的数据 有序集合
Dictionary: 键值对，key 可以是数值、字符串、bool。但是不能为List、Dictionary
Tuple:  有序的，不同字段类型的 ，不可变的集合
Set : 无序，不重复的 格式为： {a,True}. 不可遍历的
```

计算平方根的时候可以采用 math.sqrt() 或者 （） ** 0.5  如果是虚数的话 需要使用cmath.sqrt()

通过内置函数 id() 来查询内存地址。整形、浮点型、字符串 只要内容一致的话，内存地址就是一置的

type() 函数可以查询 变量的类型 

# 三、函数

sum 可以接受 list、set、tuple 作为参数

math.pi  代表数学常量 派![image-20251020165127853](https://raw.githubusercontent.com/Footman56/images/master/img202510201651700.png)

math.nan 永远不等于任何数（包括自身） 需要用math.isnan() 来判断



# 四、变量

python 变量采用蛇形结构，多个单词之间通过"_"来分割

```
int(float('9.8')  是对的 ；  int('9.8') 是不对的。 转换的时候只能一层一层的转换
```

```
type(10) == int  => True  属于精确比较，返回的是类型，不考虑子类继承
isinstance(10,(int,float)) =>True  属于判断继承比较，返回的是bool，考虑子类继承
```

```
==  : 判断的是值是否相等
is  : 判断的是内存地址是否相等
```

# 五、运算符

｜ ： 按位或，如果是数值运算的时候先转后成二进制，之后按位进行或计算。如果是bool 运算时等同于 or  但是不会短路

& ：按位与，如果是数值运算的时候先转后成二进制，之后按位进行 与计算。如果是bool 运算时等同于 and 但是不会短路

~ :  按位非，如果是数值运算的时候先转后成二进制，之后按位进行 非计算。如果是bool 运算时等同于 not 但是不会短路

^ :    按位异或，对应的二进制位不同 → 结果为 1；对应的二进制位相同 → 结果为 0  异或运算具有**交换律**和**结合律**

小技巧：

```
<<  左移 ： 每移动一位就*2
>>  右移 ： 每移动一位就 /2 结果为整数
&   按位与 ： 全1为1
｜  按位或  ： 有1就1 
^   按位异或  相同为0，不同为1

# 想要对两个数据进行交互
x =10 , y = 20  => x,y = y,x 
x = x^y
y = x^y
x = x^y
```



``` 
# 只出现一次的数字
nums = [2, 3, 2, 4, 3]
result = 0
for n in nums:
    result ^= n

print(result)  #


成对出现的数会互相抵消 (a ^ a = 0)

/ # 浮点除，会计算出小数
// # 整除， 结果为整数
% # 取商

q,r = divmod(x,y)   # divmod 进行商余操作，返回两个结果，一个是商，一个是余
```



# String

python 不区别 '' 和 “” , 没有char类型

``` 
# 从开头或者结尾进行单词替换，如果符合条件就一直替换，直到出现不符合条件的字符
challenge = 'athirty days of pythoonnny'
print(challenge.strip('ty')) 

find() 和index() 都是能查询子字符串的位置，
区别是index()未找到时报错，find()是提示-1。并且index()可以指定开始和结束字符串位置

print(name.find("or"))
print(name.index("or",3))


优雅打印
a1 = 100 , a2 = 40
print(f'{a1 = }, {a2 = }') # 打印的效果就是  a1= 100,a2 = 40

print('-' * 50 )  # 就是重复打印50个'-' 
```



```
两种特殊的格式
r	'C:/peilizhi/tmp'

前面加上 r就代表原生的字符串，不需要对特殊的字符进行转义


aa= b 'hello world'
aa 对象就是字节类型的， 代表二进制数据


```



## 输入、输出

python 中的输入与输出非常符合自然语言。

```
print() 是输出、input() 是输入。
输入的数据都是当作str 形式的。


a1, a2 = eval(input('请输入两个整型数值'))


eval() 函数的功能是 对满足python 形式的 表达式进行计算
```



# 列表

```
1. 定义,是存取有序
a = [] 
a = list()

2. 添加
a1.append(1) # 添加到末尾
a1.insert(0, 9) # 在指定下标下添加元素

3. 修改
a1[0] = 8

4. 删除
element = a1.pop()   默认是弹出最后一个元素，如果参数有下标的话就是弹出执行下标的元素。这种形式的话是有返回值的
a1.remove(3)  删除对应的元素，不存在的时候会报错，没有返回值

5. 分片获取
a2 = a1[0:1:1]  开始下标-包含: 结束下标-不包含 : 步长

```

# 元组

```
不可变的集合

1.定义
a = (1,2) 
如果元组中只有一个对象的话，需要以,为结尾，否则的话就当作单个对象
a = (1,)
```



#  字典

```
a = dict()

a = {'张三': 80,'李四':90}
```

# 集合

```
1. 确定性 2.无序性 3. 互异性

set() 或者 {1,2,3}

a = {1,2,3}
b = {4,5,6}
交集 ： a &  b 
并集 ： a | b 
差集 ： a - b  或者 b - a
对称差集 a.symmetric_difference(b)  等同于 （a-b）+ (b-a)
```



# 条件分支

```
if xx : 
	xxx
elif  xx:
	xxx
else:
  xxx
  
  
双分支条件的简化版
n1, n2 = eval(input("请输入两个数值进行大小比较:"))
bigger = n1 if n1 > n2 else n2
print("较大的数是：", bigger)


多分支条件
if score >= 90:
    print("优秀")
elif score >= 80:
    print("良好")
elif score >= 70:
    print("及格")
elif score >= 60:
    print("不及格")
else:
    print("差")
    
    
# 匹配语句   
level = score // 10

match level:
    case 10 | 9:
        print("优秀")
    case 8:
        print("中等")
    case 7:
        print("及格")
    case _:
        # 兜底的情况
        print("不及格")
```



# for 循环

```
for 一般适用于知道循环的次数。

# 生成5遍 “我爱python!”  在不需要遍历列表下标时可以使用 _ 来代替
for _ in range(0, 5):
    print("我爱python!")
	
range(start,stop,step)  用于生成从[start,stop) 以一定长度的step 来生成数据 （就用来说明循环的次数）

# 列表生成式  []最前面是结果， 之后就是for循环，通过空格隔开多层循环，在最后通过if来判断是否满足条件
alist = [(a, b, c) for a in range(1, 21) for b in range(a, 21) for c in range(b, 21) if a ** 2 + b ** 2 == c ** 2]
print(alist)

for a in range(1, 21):
    for b in range(a, 21):
        for c in range(b, 21):
            if a ** 2 + b ** 2 == c ** 2:
                print(a, b, c)

```



# while

```
while 循环一般不知道循环的次数，通过内部判断来退出

1. break 形式退出  2. 将 while 对应的值改成false
count = 2
while True:
    if count % 2 == 1 and count % 3 == 1 and count % 4 == 1:
        print(count)
        break
    count += 1
```





# 函数

```python
# def 开头，之后就是函数名称，参数不需要声明类型，结果也是可以不声明类型的 
def name_titles(name: str, age: int) -> tuple:
    """
    This function returns the title of the name
    :return 多个参数的话返回的实际对象是元组
    """
    return name.title(), age + 18

# 每个函数之间需要有两行空格

name, age = name_titles("xiaowang", 20)
print(f'{name = }, {age = }')


## 不定入参
def math_operators(*args) -> int:
    """
    :arg 本质是元组
    """
    print("第一个参数是", f'{ args[0] = }')
    result = 0
    for i in args:
        result += i
    return result


result = math_operators(1, 2, 3, 4, 5)
print(f'{result = }')



# 关键字参数
def math_kw_operators(name: str, **kwargs) -> dict:
    """
    :kwargs 本质是字典，取值逻辑按字典的取值方式
    """
    python = kwargs["python"]
    chinese = kwargs["chinese"]
    english = kwargs["english"]
    sum = python + chinese + english
    name = name.title()
    return {'name': name, 'sum': sum}
  
  
# 两种形式调用
result1 = math_kw_operators("xiaoli", python=100, chinese=100, english=100)
print(f'{result1 =}')

result2 = math_kw_operators("xiaohong", **{"python": 200, "chinese": 200, "english": 200})
print(f'{result2 =}')



# 匿名函数 lambda 入参: 返回结果
# filter 对列表进行过滤，返回的对象是迭代器对象，需要转换成list 才可以使用
func1 = lambda x: 0 == x % 3
l_result = list(filter(func1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
print(f'{l_result =}')
```



# 类

```python
# 面向对象特性 封装、继承、多态、抽象



from abc import ABC, abstractmethod

# 继承自object类
class Food(object):
    def __init__(self, name):
        self.name = name


class Bone(Food):
    def __init__(self):
        super().__init__("骨头")


class CatFood(Food):
    def __init__(self):
        super().__init__("猫粮")


# 想用定义抽象方法，需要继承ABC类(代表抽象类)
class Animal(ABC):
    #  构造方法
    def __init__(self, name):
        self.name = name

    # name 属性的获取 getter方法，如果需要特殊处理的时候需要重写，否则不需要
    @property
    def name(self):
        if self.__name:
            return self.__name
        else:
            return 'No name'

    # name 属性的设置,setter 方法
    @name.setter
    def name(self, name):
        if not isinstance(name, str):
            raise ValueError('name must be a string')
        self.__name = name.title()  # __ 代表私有属性

    # 要有一个抽象方法，表示吃,子类必须重写
    @abstractmethod
    def eat(self, food: Food):
        pass


class Dog(Animal):
    def __init__(self, name):
        # 调用父类构造方法
        super().__init__(name)

    # 子类重写父类方法    
    def eat(self, food: Food):
        # 具体子类实现抽象方法时需要判断参数类型是否为能处理的
        if isinstance(food, Bone):
            print(self.name + '吃' + food.name)
        else:
            print(self.name + '吃不了' + food.name)



class Person(object):
    def __init__(self, name):
        self.name = name

    def feed(self, animal: Animal, food: Food):
        print(self.name + '给' + animal.name + '吃' + food.name)
        animal.eat(food)

        if isinstance(animal, Dog):
            animal.yelling()


p = Person("立志")
dog = Dog("啸天犬")
p.feed(dog, Bone())
```



# 文件读写

```
with open('test.txt', 'wt', encoding='utf-8') as write:
    write.write("今天很高兴！")

with open('test.txt', 'rt', encoding='utf-8') as read:
    print(read.read())
    
    
# 重点是 文件读写模式
'r'       open for reading (default)
    'w'       open for writing, truncating the file first
    'x'       create a new file and open it for writing
    'a'       open for writing, appending to the end of the file if it exists
    'b'       binary mode
    't'       text mode (default)
    '+'       open a disk file for updating (reading and writing)
    
    
# 在文件末尾进行追加
with open('test.txt', 'a+', encoding='utf-8') as write:
    for i in range(0, 5):
        str = f"今天很高兴, {i = }\n"
        write.write(str)
```



# 异常

```python
def division(x, y):
    try:
        v = x / y
        print("执行完try")
    except ZeroDivisionError as e:
        # 如果发生了异常，并且异常是ZeroDivisionError的话就会执行到这里
        print("执行except", e)
        return '除数不能为0'
    except BaseException as e:
        # BaseException 是所有异常的父类
        print("这里发生了异常", e)
        # 此时函数没有return，函数会返回None
    else:
        # 如果没有异常，就会执行到这里
        print("执行else")
        return v
    finally:
        # 无论是否发生异常，都会执行到这里
        # finally 常用于释放资源，在return 语句执行前先执行
        print("执行finally")


print(f'{division(2, '6') = } ')



## 自定义异常： 继承BaseException类，重写构造方法
class MyException(BaseException):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return self.message


def division_except(x, y):
    v = x / y
    print("执行完try")
    raise MyException("就是报错")


try:
    division_except(2, 6)
except MyException as e:
    print('捕获到MyException', e)
```

