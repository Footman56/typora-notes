1、参数流转问题

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410192242865.jpeg" alt="img" style="zoom:50%;" />





# 大数据和高并发

大数据量和高并发是项目发展必然遇到的问题，如果不合理处理的话都会导致极糟糕的客户体验。

大数据主要解决在数据量很大的时候增删改查能够高效的执行

高并发主要解决是有大量的客户请求进来对服务器有巨大的压力

需要综合考虑静态资源和动态请求的不同处理方式

## 解决大数据

### 高效缓存

缓存**一些不经常变化的数据**，在请求的时候可以先查询缓存，查到就立刻返回，就不用再查询数据库。

缓存就需要考虑什么时候创建缓存？什么时候缓存失效？

高效缓存的实现有 本地内存或者缓存架构

本地内存的话就是ConcurrentHashMap，

缓存架构有redis 、Memcache、Ehcahe

#### 创建缓存

可以在项目启动的时候创建缓存；也可以在第一次查询的时候创建缓存；也可以在缓存失效的时候创建缓存；

注：**一些数据是空值的时候需要新建另一种缓存对象来记录，因为查询缓存的时候查询的空值，会认为是没有缓存的，会再次查库。导致缓存没有起作用**

### 失效缓存

可以定时失效缓存；可以在有数据变化的时候失效缓存；

### 优化查询

合理的表结构设计能够支持业务快速迭代，并方便后面拓展。可以通过索引来加快查询，优化SQL来提高执行的效率

### 分区

分区就是将数据按照某种规则来分开存储，这样查询的范围就大大减少，这种改动是对程序透明的，程序不需要改动。

如果数据之间是有规律的并且能够根据这种规律快速区别数据，就可以分区。

### 分表

如果表中数据可以分成几种类型，并且多个类型之间的联合操作计较少的话，就可以将不同的类型放在不同的表中；例如评分等级为优秀、良好可以区分

如果表中的几个字段相交其他字段改动的比较少的话，就可以将这几个字段区别开放在另一张表中。这样更新的时候锁表锁的字段也比较少，主要问题还是表结构设计的要合理

### 分离活跃数据

如果有的数据是比较活跃的，有的数据是很少变化的，就可以将这部分活跃的数据单独存储，查询的时候范围就比较少。常用于登陆的时候区别活跃用户和长期不使用的用户。重点在于区别那些用户是活跃的（要记录活跃标识），根据客户最近的操作来计算活跃度。之后通过**定时任务**将活跃的数据迁移到另一个表中

### 批量读取和延迟写入

批量读取是将多次读取请求合并成一个一次请求，减少对数据库的操作。比如一个请求要查询多个字段并且确定这些字段是否都是合理的，一种是针对每次字段查询一次，要查询多次；另一种是在一次请求中通过in 组合多个条件，如果没有查到的话就是不符合条件

延迟修改适合频繁修改的情景，借助缓存来记录中间变化的过程，有修改先更新缓存，之后再**定时**将缓存中的数据放入数据库。查询的时候就需要从缓存和数据中都获取数据，此时缓存中的数据就与数据库中的数据不一致啦，万一缓存中的数据因故障丢失的话，那么就需要对这种数据进行特殊处理，用于记录这些数据。

### 读写分离

分为 主从服务器，主服务器负责写入操作，从服务器负责读取。当有写操作的时候就将数据写入到主服务器，之后主服务器将变化的数据同步到从服务器，一些查询的操作就走从服务器。在写操作之后，是需要一定的时间来同步到从服务器上。在这个时候如果查询的话就有可能查询从服务器，导致数据不一致的情景。简单的数据同步操作可以通过数据库的热备份功能。***需要重点处理主从延迟问题***

### 存储过程

一些复杂的sql 可以通过编写存储过程来快速执行，因为存储过程只编译一次。

## 解决高并发

**根源思路就是降低一台服务器处理的请求数量，降低cpu处理的压力**

### 动静态资源分离

一些静态资源（html、jsp、css 等）不怎么变化的，可以迁移到另一台服务器上，请求的时候通过网关转发（nginx），这样就将请求分流，不至于都打到一个服务器上，导致服务器压力过大。

### 静态资源缓存

将一些不怎么变化的页面缓存起来，不需要请求的时候都重新创建。但是实际情况中不变化的静态资源很少，很少。可以缓存页面，一些需要变化的字段就可以通过ajax来请求 

### 集群

集群是将一台机器处理变成多台机器处理，每台机器能够处理的功能是一样的。将有大量相同请求的时候，就将这些请求按照一定的规则分配给不同的机器，降低单台机器处理的压力。集群分为静态资源集群、应用程序集群。静态资源集群是每台机器中记录静态资源。**应用程序集群的时候需要注意一个数据的更新变化**，比如同一个Session ，两次请求应该是同一个Session,但是请求如果被不同的服务器处理的话，就可能导致Session。常见的解决方式是当Session 变化的时候立刻同步到其他服务器上，（tomcat）；将Session 放在缓存里面，多个应用程序使用同一个缓存Session。

### 分布式

分布式意味着将业务拆分。不同的业务由不同的机器处理。

### CDN

CDN是将请求交给合适的服务器，如果是北京请求的，就交给北京的服务器

### 反向代理

正向代理：代替客户去请求对应的资源，之后再将资源返回给我们（类似翻墙软件，为我代理）

反向代理：通过代理服务器去请求对应的资源，我们访问代理服务器（为服务器代理），能够便于统计请求信息

### 底层优化

我们现在的web服务都是遵循 TCP/IP 模型 

