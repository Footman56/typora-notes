

elasticsearch-head

elastic search-head 是谷歌插件，可以查看elasticsearch 存储情况

直接在谷歌商店下载即可



##  添加文档

POST http://localhost:9200/索引/__doc  或者  http://localhost:9200/shopping3/_create

_doc 是类型，现在都是 _doc这一种类型 

```
POST http://localhost:9200/shopping3/_doc
body 中添加json格式的内容
{
    "name":"xiaoli",
    "age":12,
    "sex":"girl"
}
```

<img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220719231536540.png" alt="image-20220719231536540" style="zoom:50%;" />

多次发送请求会创建多个文档

POST http://localhost:9200/索引/_doc/指定Id

```
http://localhost:9200/shopping3/_doc/100
```

数据存储：

<img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220719231742574.png" alt="image-20220719231742574" style="zoom:50%;" />

## 查询

### 主键查询

GET http://localhost:9200/索引/_doc/id主键

```
GET http://localhost:9200/shopping3/_doc/100
```

```json
{
    "_index": "shopping3",
    "_type": "_doc",
    "_id": "100",
    "_version": 1,
    "_seq_no": 3,
    "_primary_term": 1,
  // 是否找到
    "found": true,
    "_source": {
        "name": "xiaoli",
        "age": 12,
        "sex": "girl"
    }
}
```

### 全查询

GET http://localhost:9200/索引/_search

```
http://localhost:9200/shopping3/_search
```

```json
{
  // 耗时，毫秒单位
    "took": 2,
  //  是否超时
    "timed_out": false,
    "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
    },
    "hits": {
        "total": {
            "value": 5,
            "relation": "eq"
        },
        "max_score": 1.0,
      // 命中
        "hits": [
            {
                "_index": "shopping3",
                "_type": "_doc",
                "_id": "VwwEF4IB0bzTGXVT6bpN",
                "_score": 1.0,
                "_source": {
                    "name": "xiaoli",
                    "age": 12,
                    "sex": "girl"
                }
            },
            {
                "_index": "shopping3",
                "_type": "_doc",
                "_id": "WAwHF4IB0bzTGXVTvLpf",
                "_score": 1.0,
                "_source": {
                    "name": "xiaoli",
                    "age": 12,
                    "sex": "girl"
                }
            },
            {
                "_index": "shopping3",
                "_type": "_doc",
                "_id": "WQwHF4IB0bzTGXVTwLo2",
                "_score": 1.0,
                "_source": {
                    "name": "xiaoli",
                    "age": 12,
                    "sex": "girl"
                }
            },
            {
                "_index": "shopping3",
                "_type": "_doc",
                "_id": "100",
                "_score": 1.0,
                "_source": {
                    "name": "xiaoli",
                    "age": 12,
                    "sex": "girl"
                }
            },
            {
                "_index": "shopping3",
                "_type": "_doc",
                "_id": "200",
                "_score": 1.0,
                "_source": {
                    "name": "xiaoli",
                    "age": 12,
                    "sex": "girl"
                }
            }
        ]
    }
}
```

### 简单条件查询

GET http://localhost:9200/shopping3/_search?q=name:xiaoli  直接在请求路径中添加查询条件

也可以组装多个条件

http://localhost:9200/megacorp/_search?q=last_name:liu&q=first_name:xiaoli

GET 

Body

```json
{
  // 查询条件
    "query":{
  // 查询全部
        "match_all":{
        }
  //条件查询
        "match":{
          "name":"lizhi"
        }
    },
   // 从哪里开始 
    "from" :0,
   // 每页数据
    "size":3,
   // 返回结果列
    "_source":["name","sex"],
   // 排序
    "sort":{
        "age":{
            "order":"asc"
        }
    }
}
```

[match] query doesn't support multiple fields, found [name] and [sex]： match不支持多个条件

[match_all] unknown field [name] did you mean [_name]? : match_all 不支持条件

### 多条件查询

一些格式是固定的

```json
{
  "query":{
    "bool":{
      "must":{
        "macth":{
          "xxxx":"xxxxx"
        }
      },
      "filter":{
        "range":{
          "xx":{"gt":xxx}
        }
      }
    }
  }
}
```



must = and ,should = or  filter 过滤

```json
{
    "query":{
        "bool":{
            "must":[
                {
                    "match":{
                         "name": "xiaoli"
                    }
                },{
                    "match":{
                        "age":13
                    }
                }
            ]
        }
    }
}
```

```json
{
    "query":{
        "bool":{
            "should":[
                {
                    "match":{
                         "name": "xiaoli"
                    }
                },{
                    "match":{
                        "name":"lizhi"
                    }
                }
            ]
        }
    }
}
```

```json
{
    "query":{
        "bool":{
            "should":[
                {
                    "match":{
                         "name": "xiaoli"
                    }
                },{
                    "match":{
                        "name":"lizhi"
                    }
                }
            ],
            "filter":{
                "range":{
                    "age":{
                        "gt": 12
                    }
                }
            }
        }
    }
}
```

使用match 就是全文检索。elaticsearch 将文档建立倒排索引，match 在查询的时候会分成一个词去查询索引，

使用match_phrase 就是精确查询

## 全量修改

PUT http://localhost:9200/索引/_doc/id

body 里面放修改内容json

```
PUT http://localhost:9200/shopping3/_doc/100
 {
                    "name": "xiaolixxxx",
                    "age": 15,
                    "sex": "boy"
}
```

```json
{
    "_index": "shopping3",
    "_type": "_doc",
    // 影响的主键
    "_id": "100",
  //  每做一次操作 +1
    "_version": 3,
  //  更新类型
    "result": "updated",
    "_shards": {
        "total": 2,
        "successful": 1,
        "failed": 0
    },
    "_seq_no": 6,
    "_primary_term": 1
}
```

多次执行时都会更新

## 部分修改

POST http://localhost:9200/索引/**_update**/id

BODY 

```json
{
    "doc":{
      // 要修改的内容
        "name":"lizhi"
    }
}
```

一定要指定为_update ，否则就是全文替换

```json
{
    "_index": "shopping3",
    "_type": "_doc",
    "_id": "200",
    "_version": 2,
    "result": "updated",
    "_shards": {
        "total": 2,
        "successful": 1,
        "failed": 0
    },
    "_seq_no": 9,
    "_primary_term": 1
}
```



## 删除内容

DELET  http://localhost:9200/索引/_doc/id

## 聚合操作

GET http://localhost:9200/shopping3/_search

Body

```json
{
    // 聚合操作
    "aggs":{
        // 分组名称
        "group_name":{
            // 分组操作
          // avg 求平均值
            "terms":{
                // 分组字段
                "field": "name"

            }
        }
    },
  // 不展示原数据，只展示统计数据
    "size" :0
}
```

如果字段没有进行优化，也类似没有加索引。没有优化的字段es默认是禁止聚合/排序操作的。

加索引操作

PUT http://localhost:9200/索引/_mapping?pretty

body

```json
{
    "properties": {
        // 要优化的字段
    "name": { 
      "type":     "text",
      "fielddata": true
    }
  }
}
```

## 映射

映射：可以理解成定义对象

先建立索引

再创建参数映射

Body：

PUT http://localhost:9200/索引/_mapping

```json
{
    "properties":{
        "name":{
          // 可分词，全文索引
            "type": "text",
            "index": true
        },
        "sex":{
          // 不能分词，完全匹配
            "type":"keyword",
            "index":true
        },
        "tel":{
            "type":"text",
            "index":false
        }
    }
}
```





请求语法：

```
GET /es_db/_doc/_search
{json请求体数据} 

可以简化为下面写法:
GET /es_db/_search
{json请求体数据}
```

# 查询全部

但是默认只会返回10条数据

```
GET /es-db/_search
{
	"query":{
			"match_all":{}
	}
}
```

#  返回指定数量

```
GET /es-db/_search
{
	"query":{
			"match_all":{}
	},
	"size": 10
}
```

但是size 不能指定特别大，不能大于10000，否则会报错，

这个数量是通过了 index.max_result_window 配置设置的

```
# 放开大小后，能查询size=20000的请求
PUT /es-db/_setting
{
	"index.max_result_window":200000
}
```

但是这种治标不治本，可以通过scroll api更高效的请求大量数据集（深度分页）。

# 深度分页

```
#查询命令中新增scroll=1m,说明采用游标查询，保持游标查询窗口一分钟。 
#这里由于测试数据量不够，所以size值设置为2。
#实际使用中为了减少游标查询的次数，可以将值适当增大，比如设置为1000。
GET /es-db/scroll=1m
{
	"query":{
			"match_all":{}
	},
	"size":2
}
```

# 排序

排序之后得分会失效

```
GET /es-db/_search
{
  "query": {
    "match_all": {}
  },
  "size": 200000,
  "sort": [
    {
      "age": {
        "order": "desc"
      }
    }
  ]
}
```

# 只返回特定字段

```
GET /es-db/_search
{
	"query":{
		"match_all" :{}
	},
	"_source":["age","name"]
}
```

# match

match在匹配时会对所查找的关键词进行分词，然后按分词匹配查找（模糊查询）

match支持以下参数:

+ query : 指定匹配的值
+  operator : 匹配条件类型
  + and : 条件分词后都要匹配
  + or : 条件分词后有一个匹配即可(默认)

+ minmum_should_match : 最低匹配度，即条件在倒排索引中最低的匹配度

```
# 默认条件是or 也就是说只有匹配到一个查询条件中的分词就能够查询到
GET /es-db/_search
{
	"query":{
		"match":{
			"address":{
				"query":"xx",
        }
		}
	}
}
```

```
#  默认条件是and  也就是说要匹配到所有查询条件中的分词
GET /es-db/_search
{
	"query":{
		"match":{
			"address":{
				"query":"xx",
				"operator":"and"
        }
		}
	}
}
```

# match_phrase

，他是短语查询，match_phrase 会将检索关键词分词。match_phrase的分词结果必须在被检索字段的分词中**都包含**，而且顺序必 须相同，**而且默认必须都是连续的**。

slop 可以指定间隔多少分词也算连续

```
GET /es-db/_search
{
	"query":{
		"match_phrase":{
			"address":{
				"query": "广州云",
				"slop": 2
			}
		}
	}
}
```

# 分析分词

```
POST _analyze
{
	"analyzer":"standard", 
	"text":"广州白云山"
}
```



# 多字段查询

检查多个字段是否符合条件

**注意:字段类型分词,将查询条件分词之后进行查询，如果该字段不分词就会将查询条件作 为整体进行查询。**

如果address 分词的话，那么查询条件“长沙张龙”也根据规则分词

```
GET/es_db/_search 2{
 "query": {
 "multi_match": {
 "query": "长沙张龙",
 "fields": [
 "address",
 "name"
]  }
 }  }
```

# query_string

允许我们在单个查询字符串中指定AND | OR | NOT条件，同时也和 multi_match query

一样，支持多字段搜索。和match类似，但是match需要指定字段名，query_string是在所 有字段中搜索，范围更广泛。
 **注意: 查询字段分词就将查询条件分词查询，查询字段不分词将查询条件不分词查询**

## 未指定查询条件

筛选出含有张三 或者 橘子洲的，无论在哪个字段

```
GET /es_db/_search {
"query": {
"query_string": {
 "query": "张三 OR 橘子洲"
}
} }
```

## 指定在单个字段查询

```
GET /es_db/_search 
{
	"query": {
	"query_string": {
 	"query": "张三 OR 橘子洲",
 	"default_field": "address"
	}
	} 
}
```

## 多个字段查询

```
GET /es-db/_search {
 "query": {
"query_string": {
 "fields": ["name","address"],
 "query": "张三 OR (广州 AND 王五)"
}
} }
```

# term 关键词

Term用来使用关键词查询(精确匹配),还可以用来查询没有被进行分词的数据类型。

，搜索和利用统计语言模型进行自然语言处理都需要处理Term。

 match在匹配时会对所查找的关键词进行分词，然后按分词匹配查找，而term会直接对关 键词进行查找。一般模糊查找的时候，多用match，而精确查找时可以使用term。

**ES中默认使用分词器为标准分词器(StandardAnalyzer),标准分词器对于英文单 词分词,对于中文单字分词。**

在ES的Mapping Type 中 keyword , date ,integer, long , double , boolean or ip 这些类型不分词，只有text类型分词。

```
GET /es-db/_search
{
  "query": {
    "term": {
      "address": {
        "value": "广州天河公园"
      }
    }
  }
}

# 精确查询 .keyword才查到
GET /es-db/_search
{
  "query": {
    "term": {
      "address.keyword": {
        "value": "广州天河公园"
      }
    }
  }
}
```

# 范围查询

range 

条件有：

+ gte 大于等于
+ lte 小于等于
+ gt 大于
+ lt 小于
+ now 当前时间

**查询使用get、post 都可以**

```
GET /es-db/_search
{
	"query":{
		"range":{
			"age":{
				"lte": 25,
				"gte": 20
			}
		}
	}
}
```

