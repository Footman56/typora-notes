<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411030202178.png" alt="image-20241103020202127" style="zoom:50%;" />

在执行增删改的时候，虽然没有手动 begin 事务和 commit 事务，但是 mysql 会隐式开启事务执行

执行一条语句是否自动提交事务，是由 autocommit 参数决定的，默认是开启。

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411030142528.png" alt="image-20241103014253478" style="zoom:50%;" />



# buffer pool

在内存中

缓存数据页，如果操作的数据页在缓存中就不需要查询磁盘，否则需要查询磁盘，并将对应的数据页放在buffer pool 中

buffer pool 一般设置为机器内存的 60～70%

 

# undo 日志

用于事务失败时进行回滚。**innodb 引擎独有**，保证事务的原子性

InnoDB对undo log文件的管理采用段的方式，也就是回滚段（rollback segment） 。每个回滚段记录了 1024 个 undo log segment ，每个事务只会使用一个undo log segment。

在MySQL5.5的时候，只有一个回滚段，那么最大同时支持的事务数量为1024个。在MySQL 5.6开始，InnoDB支持最大128个回滚段，故其支持同时在线的事务限制提高到了 128*1024 。

```
innodb_undo_directory：设置undo log文件所在的路径。该参数的默认值为"./"，即innodb数据文件存储位置，目录下ibdata1文件就是undo log存储的位置。
innodb_undo_logs: 设置undo log文件内部回滚段的个数，默认值为128。
innodb_undo_tablespaces: 设置undo log文件的数量，这样回滚段可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件。
```

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411022254862.png" alt="image-20241102225427817" style="zoom:50%;" />

undo log 内容

+ 在插入一个记录的时候，记录这个记录的主键，回滚时删除这个记录
+ 在删除一条记录的时候，记录这个记录的内容，回滚时插入这个记录
+ 在更新一条记录的时候，记录这个记录的原始内容，回滚时更新为原始记录

undo log  日志什么时候删除

+ 新增类型的，在事务提交之后就可以清除掉了。
+ 修改类型的，事务提交之后不能立即清除掉，这些日志会用于mvcc。只有当没有事务用到该版本信息时才可以清除。



# redo log

记录操作变更，并且提交更新、删除、插入的效率

是一种保险机制，在事务提交成功的时候，但是IO 没有来得及将buffer pool 中修改的页（脏页） 刷进磁盘中，断电时无法恢复内存中buffer log, 可以通过 redo log 来恢复已经提交成功的事务。

在redo log 中的提交成功的就是需要刷进磁盘中的



redo log 写入磁盘文件时机

+ mysql 正常关闭
+ 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；
+ InnoDB 的后台线程每隔1 秒，将 redo log buffer 持久化到磁盘。
+ 每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由innodb_ flush log_at_trx_commit 参数

## 重要参数

**innodb_log_buffer_size**：设置redo log buffer大小参数，默认16M ，最大值是4096M，最小值为1M。

**innodb_log_group_home_dir**：设置redo log文件存储位置参数，默认值为"./"，即innodb数据文件存储位置 data，其中的 ib_logfile0 和 ib_logfile1 即为redo log文件。

**innodb_log_files_in_group**：设置redo log文件的个数，命名方式如: ib_logfile0, iblogfile1... iblogfileN。默认2个，最大100个。

**innodb_log_file_size**：设置单个redo log文件大小，默认值为48M。最大值为512G，注意最大值指的是整个 redo log系列文件之和，即(innodb_log_files_in_group * innodb_log_file_size)不能大于最大值512G。

```mysql
show variables like '%innodb_log_buffer_size%';
show variables like '%innodb_log_group_home_dir%';
show variables like '%innodb_log_files_in_group%';  
show variables like '%innodb_log_file_size%';  
show variables like 'innodb_flush_log_at_trx_commit';
# 设置innodb_flush_log_at_trx_commit参数值(也可以在my.ini或my.cnf文件里配置)：
set global innodb_flush_log_at_trx_commit=1;  
```

**innodb_flush_log_at_trx_commit**：这个参数控制 redo log 的写入策略，它有三种可能取值：

- 设置为0：表示每次事务提交时都只是把 redo log 留在 **redo log buffer** 中，数据库宕机可能会丢失上一秒的数据。
- 设置为1(默认值)：表示每次事务提交时都将数据写入到 redo log ，数据最安全，不会因为数据库宕机丢失数据，但是效率稍微差一点，线上系统推荐这个设置。
- 设置为2：表示每次事务提交时都只是把 redo log 写到操作系统的缓存page cache里，这种情况如果数据库宕机是不会丢失数据的，但是操作系统如果宕机了，page cache里的数据还没来得及写入磁盘文件的话就会丢失数据。

InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 操作系统函数 write 写到文件系统的 page cache，然后调用操作系统函数 fsync 持久化到磁盘文件。 

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411030002908.png" alt="image-20241103000231857" style="zoom:50%;" />

写入redo log 的效率远高于写入磁盘文件。redo log 写入方式是在文件末尾追加，先写redo log 后刷新数据表文件的机制叫WAL 机制（write -Ahead logging）

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411030000468.png" alt="image-20241103000018410" style="zoom:25%;" />

**write pos** 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。

**checkpoint** 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件里。

如果 write pos 追上 checkpoint 的时候，说明redo log以及写满啦，需要将buffer pool 中的数据刷新到磁盘中，擦除redo log 中的记录，移动check point

如果事务提交成功的话，但是IO 线程没有写入到磁盘中，可以通过redo log 来写入。只会恢复





# bin log

二进制、归档日志，保存修改操作语句，不会保存查询

bin log 是server 层实现的日志，所有存储引擎都可以

用于备份恢复、主从复制

## 重要参数

**log_bin**:  是否开启bin log ，8.0版本默认打开

 在 mysql 中配置        

```mysql
#log-bin设置binlog的存放位置，可以是绝对路径，也可以是相对路径，这里写的相对路径，则binlog文件默认会放在data数据目录下 
log-bin=mysql-binlog 
# Server Id是数据库服务器id，随便写一个数都可以，这个id用来在mysql集群环境中标记唯一mysql服务器，集群环境中每台mysql服务器的id不能一样，不加启动会报错 
server-id=1 
# 日志文件格式
binlog_format = row 
# 执行自动删除距离当前15天以前的binlog日志文件的天数， 默认为0， 表示不自动删除 
expire_logs_days = 15 
# 单个binlog日志文件的大小限制，默认为 1GB
max_binlog_size = 200M     
```

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411030213601.png" alt="image-20241103021357538" style="zoom:50%;" />

bin log 日志格式

- STATEMENT：基于SQL语句的复制，每一条会修改数据的sql都会记录到master机器的bin-log中，这种方式日志量小，节约IO开销，提高性能，但是对于一些执行过程中才能确定结果的函数，比如UUID()、SYSDATE()等函数如果随sql同步到slave机器去执行，则结果跟master机器执行的不一样。
- ROW：基于行的复制，日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改记录下每一行数据修改的细节，可以解决函数、存储过程等在slave机器的复制问题，但这种方式日志量较大，性能不如Statement。举个例子，假设update语句更新10行数据，Statement方式就记录这条update语句，Row方式会记录被修改的10行数据。
- MIXED：混合模式复制，实际就是前两种模式的结合，在Mixed模式下，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种，如果sql里有函数或一些在执行时才知道结果的情况，会选择Row，其它情况选择Statement，推荐使用这一种。

bin log 是追加写，写完一个文件之后再写另一个文件。但是可以定期清理

事务执行过程中，先把日志写到 binlog cache （Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。

MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：

+ sync_binlog=0的时候，表示每次提交事务都只 write，不fsync，后续交由操作系统决定何时将数据持久化到磁盘；
+ sync_binlog=1的时候，表示每次提交事务都会 write，然后马上执行 fsync；
+ sync_binlog =N（N>1） 的时候，表示每次提交事务都 write，但累积N 个事务后才 fsync。

默认是0，主机异常时，写入 bin log 会失败



重新生成bin log 日志:  不在向当前文件书写，新开一个文件书写bin log

+ 服务器重启或则启动
+ 执行 flush logs 
+ 文件大小达到 max_binlog_size 



## 删除 bin log 日志

```mysql
删除当前的binlog文件
reset master;
# 删除指定日志文件之前的所有日志文件，下面这个是删除6之前的所有日志文件，当前这个文件不删除
purge master logs to 'mysql-binlog.000006';
# 删除指定日期前的日志索引中binlog日志文件
purge master logs before '2023-01-21 14:00:00';
```

## 查看bin log 日志

**在执行mysqlbinlog 的时候需要保证 mysql/bin 加入到环境变量中**， vi .bash_profile

```mysql
# 查看bin-log二进制文件（命令行方式，不用登录mysql ,进入 ）
mysqlbinlog --no-defaults -v --base64-output=decode-rows /usr/local/mysql/mysql-8.0/data/binlog.000031 

# 查看bin-log二进制文件（带查询条件）
mysqlbinlog --no-defaults -v --base64-output=decode-rows D:/dev/mysql-5.7.25-winx64/data/mysql-binlog.000007 start-datetime="2023-01-21 00:00:00" stop-datetime="2023-02-01 00:00:00" start-position="5000" stop-position="20000"
```

bin log  日志

```
# at 1304594
#241031 15:40:40 server id 1  end_log_pos 1304693 CRC32 0xbe167550 	Table_map: `rsshub`.`huochai_entry` mapped to number 102
# at 1304693
#241031 15:40:40 server id 1  end_log_pos 1304790 CRC32 0x8225011b 	Table_map: `rsshub`.`huochai_feed` mapped to number 100
# at 1304790
#241031 15:40:40 server id 1  end_log_pos 1305862 CRC32 0xf660ca77 	Update_rows: table id 102
# at 1305862
#241031 15:40:40 server id 1  end_log_pos 1306502 CRC32 0x4f7a8c84 	Update_rows: table id 100 flags: STMT_END_F
### UPDATE `rsshub`.`huochai_entry`
### WHERE
###   @1=1730359838441345
###   @2='https://www.cnblogs.com/GilbertDu/p/18515175'
###   @3='《JVM第4课》程序计数器'
###   @4=';救苦救难韩天尊'
###   @5='b\x01\x00\x00xeÁNÂ@\x10_e /á\x04c<xob\x1c´\t"çR\x10Z©ÂA6E%Ql\x1ai1\x1el>;³ˉWp&{ÙÿÛo*zKÑ\x00øP%3\x1c/O6sÐ0k\rýí\x17gM£Á\x0eZýMáâ$PFù\x01\x0e\x1e1äôºrT¥*Gjæ\x11\x02¯\x13ð¸\fº"³D\x16ËU\x17Ѻ\x13Óû¶lLÛ&/é×uç\x0bC\x17êÇðùN**ý]\x16z°ÈÛHð\x1b*Tú²㈌ә·Ñ}%\rBÁâ^]Ùò©^_¬·p\tS\x1c`nãCHq¼Ëñc,2á\x1bMwWÚh_oÖ[\x06«\x1aÍ\x13óv#\x0fpü?r[¢UücH\x02»fÒͥo\x1bÓ4í\x07%êèø'
###   @6='https://www.cnblogs.com/GilbertDu/p/18515175'
###   @7=1730253420
###   @8=1730358752
###   @9='qî: ÝGY³Êæ4ç\x18 '
###   @10=0
###   @11=0
###   @12=67
###   @13=''
###   @14='{"enclosures":[]}'
### SET
###   @1=1730359838441345
###   @2='https://www.cnblogs.com/GilbertDu/p/18515175'
###   @3='《JVM第4课》程序计数器'
###   @4=';救苦救难韩天尊'
###   @5='b\x01\x00\x00xeÁNÂ@\x10_e /á\x04c<xob\x1c´\t"çR\x10Z©ÂA6E%Ql\x1ai1\x1el>;³ˉWp&{ÙÿÛo*zKÑ\x00øP%3\x1c/O6sÐ0k\rýí\x17gM£Á\x0eZýMáâ$PFù\x01\x0e\x1e1äôºrT¥*Gjæ\x11\x02¯\x13ð¸\fº"³D\x16ËU\x17Ѻ\x13Óû¶lLÛ&/é×uç\x0bC\x17êÇðùN**ý]\x16z°ÈÛHð\x1b*Tú²㈌ә·Ñ}%\rBÁâ^]Ùò©^_¬·p\tS\x1c`nãCHq¼Ëñc,2á\x1bMwWÚh_oÖ[\x06«\x1aÍ\x13óv#\x0fpü?r[¢UücH\x02»fÒͥo\x1bÓ4í\x07%êèø'
###   @6='https://www.cnblogs.com/GilbertDu/p/18515175'
###   @7=1730253420
###   @8=1730358752
###   @9='qî: ÝGY³Êæ4ç\x18 '
###   @10=1
###   @11=0
###   @12=67
###   @13=''
###   @14='{"enclosures":[]}'
### UPDATE `rsshub`.`huochai_feed`
### WHERE
###   @1=67
###   @2='http://123.57.235.173:1200/cnblogs/cate/java'
###   @3=0
###   @4=9
###   @5='Java - 网站分类 - 博客园'
###   @6='https://www.cnblogs.com/cate/java'
###   @7='Java - 网站分类 - 博客园 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)'
###   @8=1730358752
###   @9=10
###   @10=''
###   @11=''
###   @12=0
###   @13=0
###   @14='{"curl_params":null,"ssl_verify":null,"timeout":null}'
###   @15=66
###   @16=54
### SET
###   @1=67
###   @2='http://123.57.235.173:1200/cnblogs/cate/java'
###   @3=0
###   @4=9
###   @5='Java - 网站分类 - 博客园'
###   @6='https://www.cnblogs.com/cate/java'
###   @7='Java - 网站分类 - 博客园 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)'
###   @8=1730358752
###   @9=10
###   @10=''
###   @11=''
###   @12=0
###   @13=0
###   @14='{"curl_params":null,"ssl_verify":null,"timeout":null}'
###   @15=66
###   @16=53
# at 1306502
```



# 两阶段提交

+ 如果在将 redo log 刷入到磁盘之后，MySQL 突然宕机了，而 binlog 还没有来得及写入。 MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id =1这行数据恢复到新值， 但是 binlog里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行字段是旧旧值 ，与主库的值不一致性；
+ 如果在将 binlog 刷入到磁盘之后，MysQL 突然宕机了，而 redo log 还没有来得及写入。由于 redolog 还没写，崩溃恢复以后这个事务无效，所以id=1这行数据的字段还是旧值jay，但是binlog里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行字段是新值，与主库的值不一致性；

避免两日志之间逻辑不一样的问题，使用【两阶段提交】来解决 ，记录repare  和commit

1. 在写入redo log 时将XID(内部事务id)设置 repare
2. 同XID 在binlog 写完之后，将redo log 中的XID 设置为commit



恢复数据：

1. 在MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：
2. 如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务。
3. 如果 binlog 中有当前内部 XA 事务的XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务，恢复这个事务的数据。
4. 如果redo  log 是commit 状态，就直接恢复事务数据

# 删除数据库恢复

删除整个数据库，不能通过redo log 来恢复，redo log 会删除已经写入磁盘的数据，需要使用bin log 来恢复

恢复逻辑就是重演 bin log 里面的操作，此时需要和备份数据进行配置，因为bin log 会定期删除，所以备份的时机的频率要高于 删除日志的频率，比如5天备份一次的话，那么bin log 中就要有当前5天的操作，否则的话就是失去最近5天的修改

备份数据库：

```mysql
mysqldump -u root 数据库名>备份文件名;   #备份整个数据库
mysqldump -u root 数据库名 表名字>备份文件名;  #备份整个表

# 恢复数据
mysql -u root test < 备份文件名   #恢复整个数据库，test为数据库名称，需要自己先建一个数据库test
```

执行bin log 

```mysql
# 219 是bin log 中at 后面的值，恢复逻辑就是从 开始at的位置，执行到结束at位置，闭区间 
mysqlbinlog  --no-defaults --start-position=219 --stop-position=701 --database=test \data\mysql-binlog.000009 | mysql -uroot -p123456 -v test


# 补充一个根据时间来恢复数据的命令，我们找到第一条sql BEGIN前面的时间戳标记 SET TIMESTAMP=1674833544，再找到第二条sql COMMIT后面的时间戳标记 SET TIMESTAMP=1674833663，转成datetime格式
mysqlbinlog  --no-defaults --start-datetime="2023-1-27 23:32:24" --stop-datetime="2023-1-27 23:34:23" --database=test D:/dev/mysql-5.7.25-winx64/data/mysql-binlog.000009 | mysql -uroot -p123456 -v test
```

