1. 联合索引时 尽量全值匹配

    KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE，联合索引是name，age，position 查询的时候尽量都使用到，或者使用左前缀

   ```mysql
   EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22 AND position ='manager';
   优于
   EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22;
   ```

2. 最左前缀法则

   联合索引时：指的是查询从索引的最左前列开始并且不跳过索引中的列：根据索引底层结果，如果跳过中间的列不能保存数据是有序的，导致非唯一索引可能需要全表扫描来确定是否还有相等的值

3. 不在索引列上做任何操作（计算、函数、（自动**or**手动）类型转换），会导致索引失效而转向全表扫描，**计算的结果不是有序的**，

```mysql
EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22 AND position ='manager';
```

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202306271909843.png" alt="iShot_2023-06-27_19.08.19" style="zoom:50%;" />

```mysql
EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age > 22 AND position ='manager';
```

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202306271911985.png" alt="iShot_2023-06-27_19.10.44" style="zoom:50%;" >

因为查询到 age > 22 之后的数据，不能保证position 是有序的，要全部扫描后面的数据

4. 尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 **select \*** 语句

   select *  要回表，IO请求次数多

5. mysql在使用不等于（！=或者<>），not in ，not exists 的时候无法使用索引会导致全表扫描

   < 小于、 > 大于、 <=、>= 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引

6. is null 、 is not null 一般情况下也无法使用索引

7. like以通配符开头（'$abc...'）mysql索引失效会变成全表扫描操作

   如果是 %xxx 这种无法通过索引匹配到

   解决这种问题：

   a. 使用覆盖索引，查询字段必须是建立覆盖索引字段

   ```mysql
   EXPLAIN SELECT name,age,position FROM employees WHERE name like '%Lei%';
   ```

   <img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202306271953059.png" alt="image-20230627195352018" style="zoom:50%;" />

​	b.	如果不能使用覆盖索引则可能需要借助搜索引擎(elasticsearch)

8. 字符串不加单引号索引失效

   ```mysql
   EXPLAIN SELECT * FROM employees WHERE name = '1000';
   EXPLAIN SELECT * FROM employees WHERE name = 1000;
   ```

   数据类型不同做了隐式转换，导致对索引进行函数操作

9. 少用**or**或**in**，用它查询时，**mysql**不一定使用索引，mysql内部优化器会根据**检索比例**、**表大小**等多个因素整体评估是否使用索引，详见范围查询优化

   or 的话会请求多次，有时性能反而不如全部扫描

10. 范围查询优化

    范围查询的时候不要太多，如果查 2000个数据的可能全表扫描更好。

    优化：分多次小查询

    ```mysql
    由
    explain select * from employees where age >=1 and age <=2000;
    转换成
    explain select * from employees where age >=1 and age <=1000;
    explain select * from employees where age >=1001 and age <=2000
    ```


11. 联合索引的第一个字段不建议使用范围，可能会不走索引，进行全表扫描，因为mysql可能认为第一个字段都是范围的话，数据量可能很大，还不如走全表扫描效率高
12. in or 在数据量较大的时候的时候会走索引，但是数据量小的时候会直接全表扫描
13. 使用 like “k k %” 的时候会走索引  因为索引下推
13. 联合索引第一个字段使用范围的话，一般不会使用索引

在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 'LiLei' 开头的索引，然后拿这些索引对应的主键逐个回表，到主键索 引上找出相应的记录，再比对age和position这两个字段的值是否符合。
 MySQL 5.6引入了**索引下推优化**，可以在索引遍历过程中，**对索引中包含的所有字段先做判断**，过滤掉不符合条件的记录之后再回表，可 以有效的减少回表次数。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 'LiLei' 开头的索引之后，同时还会在索引里过 滤age和position这两个字段，***拿着过滤完剩下的索引对应的主键id再回表查整行数据。***并且索引下推只适合二级索引，因为二级索引没有记录全部内容，需要回表，主键索引则不同

![image-20230627200504960](https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202306272005057.png)

15. 在索引中，如果一个字段的内容不多的话，可以在查询中穷举出所有情况，满足所有索引字段，便于走索引
16. order by   在执行的时候有两种情况
    + using index condition :  使用索引进行排序
    + using file sort :  使用文件进行排序，性能较差

在sql执行过程中想要使用 索引排序的时候需要 遵守几个条件

+ order by 子句满足最左前列    idx(name,age )       order by  age, name 是不会走索引的
+ 使用where 子句与order by 子句条件列满足最左前列 。 查询的时候使用索引长度有区别，一般不会使用order by 字段的

一般执行的时候会先执行where ，再执行 order by ，就是检查where 之后的结果是否有序的，如果有序就走索引排序，否则就是文件排序



file sort 有两种方式

+ 单路排序：将结果集全部加载到sort buffer 中，进行排序   在 trace 工具中 sort_mode  : <sort_key,packed_additional_fields>
+ 双路排序：将主键、order 字段加载到 sort buffer中，排序，再回表   在 trace 工具中 sort_mode  : <sort_key,rowid>

mysql 通过比较max_length_for_sort_data（默认1024字节） 与结果集字段大小进行比较；如果max_length_for_sort_data < 结果集字段大小 就采用双路排序，否则就是单路排序



我们先看单路排序的详细过程：

1. 从索引name找到第一个满足name=‘zhuge’条件的主键id
2. 根据主键id取出整行，取出所有字段的值，存入sort_buffer中
3. 从索引name找到下一个满足name=‘zhuge’条件的主键id
4. 重复步骤2、3直到不满足name=‘zhuge’
5. 对sort_buffer中的数据按照字段position进行排序
6. 返回结果给客户端

我们再看下双路排序的详细过程：

1. 从索引name找到第一个满足name=‘zhuge’的主键id
2. 根据主键id取出整行，把排序字段position和主键id这两个字段放到sortbuffer中
3. 从索引name取下一个满足name=‘zhuge’记录的主键id
4. 重复3、4直到不满足name=‘zhuge’
5. 对sort_buffer中的字段position和主键id按照字段position进行排序
6. 遍历排序好的id和字段position，按照id的值回到原表中取出所有字段的值返回给客户端







**没有明显 order by 的话，会默认根据主键排序**

group by  会先执行一下排序，再进行分组。对于groupby的优化，如果不需要排序的可以加上orderbynull禁止排序。where高于having，能写在where中的限定条件就不要去having限定了。



分页查询

```sql
select * from user   limit 1000,5
```

这种sql 查询中1005条数据，最后只返回最后的5条。所以数量比较大的时候查询性能就比较

**如果想要优化性能比较慢的，优化思路就尽量向索引上靠**



```mysql
select * from user order by name limit 1000,5
```

name 字段有索引，但是排序的时候使用的file sort    原因：扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。

```mysql
select * from user as a  inner join (select id from user order by name limit 1000,5) as b on a.id =b.id
```

如果结果集的字段很多，可以考虑**覆盖索引**。 通过 本表 inner join 临时表【结果很简单，只有主键】    之后再进行主键关联 ，就可能导致排序的时候使用索引排序，后续链接的时候因为临时表的数据不会很多可以作为驱动表





inner join  优化

+ 小表驱动大表

+ 关联字段使用索引

  

表关联有两种算法

+ Nested loop join 【循环嵌套链接】

  ```mysql
  select * from a inner join b on a.id = b.id 
  ```

  执行流程

  1. 先确定驱动表a    小表指通过查询条件查询之后数量比较小的表
  2. 获取驱动表a中符合条件的第一行
  3. 用驱动表a的关联条件 去找关联表b 中符合条件的行，并加入结果集 ： 如果是索引的话，只需要一次就可以，否则就有遍历 表b
  4. 循环驱动表a 直到所有匹配的行都找完

  总计 遍历磁盘次数 = 驱动表a数量 + 关联表b的查询次数

  这种时候关联条件是索引的情况.  mysql 会自动优化选择数量小的作为驱动表

  如果再explain 中没有出现  `using buffer join` 就说说明使用的是 Nested loop join 

  

+ Block Nested loop join  【基于块的循环嵌套链接】

  执行流程

  1. 先确定驱动表a 
  2. 将驱动表数据加载到 join buffer中
  3. 获取被驱动表的符合条件的第一行数据
  4. 将这行数据与 join buffer 中数据进行比较，找到符合条件的加入到结果集中
  5. 循环遍历被驱动表，直到所有匹配的行都找完

  总计 遍历磁盘次数 = 驱动表a数量 + 关联表b数量   在join  buffer 中比较的次数 = 驱动表a数量 * 关联表b数量



join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。如果放不下表的所有数据话，策略很简单，就是分段放。

**MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用BNL算法。如果有索引一般选择NLJ算法，**

**有索引的情况下NLJ算法比BNL算法性能更高**

inner join mysql 会自动选择驱动表，left join 、right  join 、straight  join 会明确驱动表， straight  join 不建议使用



in 和exist 进行优化

in 的数据集不能太大，否则容易全表扫描，最多不超过1000条，要去重 

当B表的数据集小于A表的数据集时，in优于exists

```mysql
select * from A where id in (select id from B)

# 等价于
for(select id from B){
	select * from A where A.id = B.id
}
```



当A表的数据集小于B表的数据集时，exists优于in

```mysql
select * from A where exists ( select 1 from B where A.id = B.id)
# 等价于
for (select * from A){
	select * from B where A.id = B.id
}
```

EXISTS(subquery)只返回TRUE或FALSE,因此子查询中的SELECT*也可以用SELECT1替换,官方说法是实际执行时会忽略SELECT清单

EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比

EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析





