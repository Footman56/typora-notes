![](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410242319298.png)

mysql 的连接分成：长链接、短链接

长链接的含义是：一次链接执行多个sql ,并不是一个sql 一个链接

长链接就会导致内存增多。

原因是：MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放

生产环节中通常使用 链接池 来管理长链接，是**复用链接**，并不是频繁创建。频繁创建会消耗性能



mysql 8.0 为什么废弃查询缓存？

因为在更新操作比较频繁的数据库中缓存命中率不高，并且更新会导致缓存维护问题



在分析阶段，通过词法分析就能识别出不存在的字段、表等



在执行器阶段会检查权限，其实在分析器阶段也会简单的检查权限。但是一些复杂的sql 光在分析器检查权限是不够的（一些触发器只有在执行的时候才能确定需要的表）



执行器执行的时候分成三种情况： 主键索引查询、全表扫描、索引下推

主键索引查询（同普通索引）

+ 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为const，这个函数指针被指向为 InnoDB引擎索引查询的接口，把条件 id =1 交给存储引擎，让存储引擎定位符合条件的第一条记录。

+ 存储引擎通过主键索引的 B+ 树结构定位到 id=1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；（如果是索引的话，会通过B+ 树找到索引的记录）

+ 执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符
  合则跳过该记录。

+ 执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回-1的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。

  

全表扫描

+ 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为all，这个函数指针被指向为InnoDB 引擎全扫描的接口，让存储引擎读取表中的第一条记录；
+ 执行器会判断读到的这条记录是否符合条件，如果不是则跳过；如果是则将记录发给客户的（Server层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。
+ 执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read _record 函数指针指向的函数，因为优化器选择的访问类型为 all， read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；
+ 一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层）返回了读取完毕的信息；
+ 执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。



索引下推 

前提：有联合索引（age，reward） 

查询：select * from t where age> 10 and reward=2000

因为第一个字段比较方式是 > ,导致第二个索引 失效。索引下推就是能够利用第二个索引字段 【重点在于定位到索引的时候先检查索引字段是否满足条件，如果不满足条件就跳过，不回表】

+ Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age＞20 的第一条记录；
+ 存储引擎定位到二级索引后，先不执行回表操作，而是先判断一下该索引中包含的列 （reward列）的条件 （reward 是否等于2000）是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给 Server层。
+ Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。
+ 如此往复，直到存储引擎把表中的所有记录读完。

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410242246015.png" alt="image-20241024224608683" style="zoom:50%;" />

update执行过程

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410242303553.png" alt="image-20241024230324498" style="zoom:50%;" />

红色的是存储引擎工作；黄色的是service层工作



redo 日志格式

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410242306721.png" alt="image-20241024230604670" style="zoom:50%;" />

分成四个文件，从write pos 开始写，写到 check point 此时将这段内容更新到数据文件中





+ redo 日志写完，但是binlog日志没写完：

  临时库恢复的时候没有对应的记录，主库数据是正确的

+ binlog日志写完，但是redo日志没写完：

  主库恢复的时候没有对应的记录，临时库数据是正确的

