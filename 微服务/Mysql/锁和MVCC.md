# 锁

![](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411022047967.png)

MYAMSM 和InnoDB 的区别：

+ Innodb 支持行锁
+ Innodb 支持事务

在RR 隔离级别行锁会升级为表锁的原因分析：

为了满足RR 隔离级别，解决不可重复读和幻读。防止扫描扫描过的索引被其他事务修改（不可重复读问题）或者间隙被其他事务插入新的数据（幻读问题），所以对扫描过的索引和间隙都上锁



MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行update、 insert、 delete操作会自动给涉及的表加写锁。
InnoDB在执行查询语句SELECT时（非串行化隔离级别的时候）不会加锁，在Update、insert、delete 操作会加写锁

 

```mysql
# 实际数据有  （1，”小红“），（2,""）（3,""） （10,""）（20,""）
select * from user where id = 18 for update
这时会锁住（10，20） 这个区间。不能在这个区间插入新的值
```

上述数据有间隙：（3，10）、（10，20），（20，正无穷）

一般查询中涉及到范围的情况下都可能加 间隙锁，比如 >,< ,in 这种范围的；并且注意是否走索引，如果是全表扫描的话，会锁整个表

kill   mysql_thread_id  ： 删除mysql 线程，避免锁等待



# MVCC

当事务开启之后，在select 查询时会生成当前事务的一致性视图 read-view 。**在可重复读隔离级别情况下，在事务结束前都不会变，但是在读已提交的情况下，每次查询都会重新生成**。事务中每次查询的结果都是 在undo 链中的数据与 read-view 比较的结果

视图由执行查询时所有未提交的事务id 数组 （数组中最小的事务id为min_id）和  已创建的最大事务 id( max_id)  这个max_id 可能时未提交的

+ 如果事务id < min_id ： 说明事务已经提交，可见
+ 如果事务id > max_id： 说明事务是将来启动的，不可见，
+ 如果  min_id  <= 事务id <=  max_id 的话，检查事务id 是否在数组里面
  + 如果在数组里面，就是未提交的事务，不可见
  + 否咋就是可见的
+ 当前事务操作的数据存在缓存里面，是可见的

事务id是递增的，较大的id说明后创建

对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx id修改成删除操作的trx id【说明那个事务删除的】，同时在该条记录的头信息 （record header）里的 （deleted flag） 标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录 如果delete flag标记位为true，意味着记录已被洲除，则不返回数据【先找可见事务ID，如果是由删除标志，不返回】。