自增主键是指在**自增列上**定义的主键。自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，索引也更紧凑。

```mysql
NOT NULL PRIMARY KEY AUTO_INCREMENT
```

# 自增主键存储位置

每张表都有自己的自增主键；

Myisam  存储在文件中，如果当前自增主键是15，重启后还是15

Innodb  在5.7 及之前的都是存储在内存里面，没有持久化，每次重启后， 都实时查表中 Max(id) + 1 作为最大值。先插入 14，15，16，再删除15，16. 重启后再插入自增主键就是 （14 + 1） = 15

在8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值

比如先插入 14，15，16，此时自增主键为17；再删除15，16（不影响自增主键），重启后恢复17.



# 自增规则

当前表的自增值y , 步长 auto_increment_increment 

1. 如果插入语句没有指定自增列的值或则为0，null， 此时根据表中的自增值填入到自增列中，并且表的自增值变成 y + auto_increment_increment

2. 如果插入语句指定了自增字段的值 x，

   a. 如果x< y ，表自增值不变

   b. 如果x>=y  表自增值为  X + auto_increment_increment（步长），将x 最为自增列的值

MySQL 维护着两个系统参数：auto_increment_offset 和 auto_increment_increment，分别用来表示自增的初始值和步长，默认值都为 1。**MySQL 修改数据表自增值是从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值**



# 自增值生成时机

**数据表的自增值修改实际上是在真正插入数据的操作之前。如果没有插入成功，MySQL 也不会将自增值再改回去**

1. 执行器调用 InnoDB 引擎接口写入一行，传入的这一行的值是 (0, ‘18500009999’, ‘小红’);
2. InnoDB 发现用户没有指定自增 id 的值，获取表 t 当前的自增值 2；
3. 将传入的行的值改成 (2, ‘18500009999’, ‘小红’);
4. 将表的自增值改成 3；
5. 继续执行插入数据操作，由于已经存在 mobile=18500009999 的记录，所以报 Duplicate key error，语句返回



在申请自增值时，为避免多个并行执行的事务申请到同一个自增 id，在申请的过程中会加锁，然后按顺序执行。自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。

数据插入失败后，不修改表的自增值是为了提高性能。

如果恢复自增id值的时候可能会出现主键冲突。比如一个事务A申请到 自增值为 15，另一个事务B申请到自增值就是16；事务A 插入失败，恢复自增值为15，后续插入的时候，任何事务申请到16 都会导致“**主键冲突**”

如果要恢复值自增值并且避免主键冲突大致有两种方式：

1. 整个语句上锁，根据语句执行情况，来恢复自增值。但是这样会导致并发性能下降，只能等这条语句执行完再执行下一条
2. 一种是每次申请 id 时，判断这个 id 是否已经存在于表中，若存在，则跳过这个 id



# 自增锁

自增 id 锁不是事务锁，在每次申请完就立马释放，以便允许其他事务可以申请。

在 MySQL 5.0 版本的时候，自增锁的范围是语句级别，即一个语句申请了表自增锁，这个锁要等到该语句执行完以后才释放，在此之前其他需要申请表自增锁的语句会被阻塞。此举虽然保证了数据一致性，但是降低了并发度。



MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，用户可根据实际情况定制锁策略，该参数有如下值 （默认值是 1）：

- 值为 0（Traditional，传统）时，采用传统锁模式，即采用之前 MySQL 5.0 版本的策略，所有 insert 操作都要申请自增锁，语句执行结束后才释放锁；
- 值为 1（Consecutive，连续）时：
  - 普通 insert 语句，自增锁在申请之后就马上释放；
  - 批量 insert 语句，类似 insert … select、replace…select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；
- 值为 2（Interleaved，交错）时，所有的申请自增主键的动作都是申请后就释放锁。



有一个批量申请自增 id 的策略：

1. 语句执行过程中，第一次申请自增 id，会分配 1 个（1）；
2. 1 个用完以后，这个语句第二次申请自增 id，会分配 2 个（2，3）；
3. 2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个（4，5，6，7）；
4. 依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。
5. 后面的sql 申请的时候分配的id就是 （8）

# 自增不连续现象

1. 手动指定自增列的值
2. 插入失败，表的自增值会增加，不会回滚
3. 事物回滚，表的自增值会增加，不会回滚
4. 批量插入语言 （select … insert，replace … select 和 load data 语句）
