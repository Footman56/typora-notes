![](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410252254449.png)



索引是帮助MySQL高效获取数据的**排好序**的**数据结构**

**mysql 中索引属于存储引擎级别的概念**，存储引擎又是表级别的概念。不同存储引擎对索引的实现方式是不同的。

Innodb  采用的是B+ Tree （聚集索引），MyISAM 采用的是B+Tree  （非聚集）



**B+树的索引不是找到具体的行， 而是行说在的页。**

索引会提高查询的效率，但是会降低增删改的效率



B- Tree、B+ Tree 都是利用节点内存储大量的数据 换取较低的高度的

B-Tree:

+ 叶节点具有相同的深度，叶节点的指针为空
+ 所有索引元素不重复
+ 节点中的数据索引从左到右递增排列
+ 每个节点都存储数据（无论是叶子节点还是非叶子节点）

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410252223650.png" alt="image-20241025222346352" style="zoom:50%;" />

B+Tree:

+ 非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引

+ 叶子节点包含所有索引字段

+ 叶子节点用指针连接，并且有序，提高区间访问的性能

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410252224901.png" alt="image-20241025222407855" style="zoom:50%;" />



问：mysql 为什么使用B+树，而不是用B-树？

因为B+ Tree 的非叶子节点不存储数据，每一页中可以容纳更多的节点，进而减少IO操作（IO操作耗时明显高于内存比较索引）

B+ Tree 的叶子节点是有序的， 并且使用指针链接，可以快速操作范围查询，范围查询的时候可以借助叶子节点之间的链表快速寻找



IO查询的时候有个“局部性原理”,就是这个数据正在使用，那么他周围的数据也有可能会被使用，

查询每页大小，通过每页大小就可以计算出每页中有多少节点，主键通常为int 占的空间比较小，一次就能查询出更多主键

**每一个节点都是一个数据页**

```mysql
# 查询一页的大小，默认一页大小是 16kB
show GLOBAL STATUS like  'Innodb_page_size';
```



Misaim 查询的时候第一步先从索引文件中找到索引，根据索引中记录的数据地址，再从数据文件获取行数据。需要执行一次回表操作



表类型为Innodb 文件结构：

.idb 存储索引、数据

Innodb 索引文件与数据文件是在一起的（聚集索引）

Innodb 只会有一个聚集索引（通常为主键，如果没有定义的话，会从行数据中找出唯一的数据作为索引列，如果还是没有找到的话，就会默认生成一个UUID 作为主键）

![image-20241025224502138](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410252245177.png)



如果是主键查询的话，直接从文件中找到主键就可以，从主键中之前获取数据内容

问：为什么Innodb 建议设置主键，并且是使用自增主键？

如果不设置主键的话，mysql 自动寻找唯一的列，如果没有找到之后默认一个长度为6的UUID,这些操作增加不必要的损耗，并且之后插入数据的时候，要保证索引的有序的，文本类型的比较用时多于数值类型的。之后进行范围查询的时候比较也比较费时。

自增主键 在插入的时候因为能够保证有序 ，所以索引树调整的次数比较少。  数值型字段相比字符串占的空间小，并且比较起来很快。





二级索引（辅助索引）也就是我们常根据业务需要创建的索引，与主键索引的区别是，节点可以不唯一，并且叶子节点存储的也不是全数据，而是**记录的主键**。

辅助索引查询的逻辑是：先从索引找到节点，获取节点对应的主键，在根据主键在主键索引中获取内容。



问：为什么不建议建立单值索引，而是建立联合索引？

能够减少索引个数，索引也是需要占空间的。联合索引能兼容单值索引的查询情况



 问：辅助节点为啥不存储内容，只存储主键？

节省磁盘空间，避免一份数据存储多份。如果一份数据维护多份的话，再更新的时候就要更新多份，如果不存数据的话，数据更新的时候只更新主键索引就可以啦



联合索引：联合索引的结构和辅助索引结构是一样的。节点存储的多个字段。有序保证：第一个字段优先，如果第一个字段相同，就比较第二个字段，第二个字段相同就比较第三个字段。如果都相同的话就放在一起。

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410252246946.png" alt="image-20241025224651901" style="zoom:50%;" />

最左前缀原则：

在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边； 当创建(a,b,c)复合索引时，想要索引生效的话，只能使用a和ab、ac和abc三种组合！

第二列、第三列的是无序的，无法进行范围查询，想要获取对应范围的只能全表扫描
