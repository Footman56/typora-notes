

# 事务

# 隔离级别

# 事务实现

## 1、锁

## 共享锁（share lock）

共享锁也叫读锁，可以允许多个事务读取，但不支持其它事务进行更新操作

允许持有锁的事务读取一行

**在sql 中手动加锁: select * from table where 1 lock in share mode**

```sql
begin;
SELECT * FROM student WHERE id =1 lock in share  MODE;


begin;
SELECT * FROM student WHERE id =2 lock in share MODE; # 执行ok ,多个事务可以共享读锁
```

## 排他锁(exclusive lock)

写锁，只要一个事务获取到这一行的排他锁之后，其他事务就不能获取这一行的共享锁和排他锁

允许持有排他锁的事务更新或者删除一行

**新增、修改、删除都会默认加上排他锁**

**在sql 中手动加锁： select * from table where 1 for update**



**共享锁和排他锁都是行锁**

```sql
BEGIN;
UPDATE student SET student_name='xxxx' WHERE id=2;
COMMIT

SELECT * FROM student WHERE id =2 for UPDATE;
```

**会针对每一行进行上锁**

事务一持有S 锁【针对同一行】：

+ 事务二可以获取s锁，不可以获取X 锁

事务一持有X 锁【针对同一行】：

+ 事务二不可以获取s锁，不可以获取X 锁



**当innodb 搜索或扫描一个表索引时，它会在遇到的索引记录上设置共享或排他锁。因此，行级锁实际上是索引记录锁。**

如果表没有创建索引的话，innodb会创建一个默认索引。

## 意向锁

意向锁是表锁，是为了快速判断表是否可以加锁，否则的话需要逐行去判断行上是否有事务。

**意向锁指示事务稍后需要表中的一行使用哪种类型的锁(共享或排他)。**

给行加上 共享锁或者排他锁之后，表会自动加上 共享意向锁或者排他意向锁：为了提高表锁效率

```sql
给表加锁
lock tables table_name write;
lock tables table_name read;
```

 intention shared lock (IS) (`IS`) ：指示事务稍后会对表中的每一行加上S Lock

 intention exclusive lock (IX) (`IS`) ：指示事务稍后会对表中的每一行加上X Lock

```sql
# 为表加上 IS
select ... for share;

# 为表加上 IX
select ... for update;
```

**事务在获取表中某一行的共享锁之前，必须首先获取表上的IS锁或更强的锁。**

**在事务可以在表中的行中获取独占锁之前，必须首先在表格上获取IX锁。**



|      | X    | S    | IX                     | IS   |
| ---- | ---- | ---- | ---------------------- | ---- |
| X    | N    | N    | N                      | N    |
| S    | N    | Y    | N(意味着后面会加入X锁) | Y    |
| IX   | N    | N    | Y                      | Y    |
| IS   | N    | Y    | Y                      | Y    |



## 记录锁(Record lock)

每一条记录，使用等值查询的时候，每一条匹配到的就是上锁。粒度最小.

可以防止对同一行进行 删除、更新。

**记录锁总是锁定索引记录，即使表没有定义索引。对于这种情况，InnoDB会创建一个隐藏的聚集索引，并使用这个索引进行记录锁定。**



## 间隙锁(gap lock)

不同索引之间的间隙

查询的记录不存在，情况是查询语句中有范围，

间隙锁主要是阻塞 insert,相同的间隙锁之间不冲突

**gap lock 可以有效避免幻读**

**间隙锁是索引记录之间的间隙上的锁，或者第一个索引记录之前或最后一个索引记录之后的间隙上的锁。**【开区间】

间隙锁是性能和并发性之间权衡的一部分，



**如果查询条件使用唯一索引的话，gap lock 会退化成 Record lock**

**如果id没有被索引或具有非唯一索引，则该语句将锁定前面的间隙。**

冲突锁可以由不同的事务在间隙上持有。例如，事务A可以持有一个间隙上的共享间隙锁(间隙s锁)，而事务B持有同一个间隙上的排他间隙锁(间隙x锁)。

**相同的间隙可以在不同的事务中持有不同的间隙锁（S或者X 都可以）**

## 临键锁(Next-key  lock)

左开右闭区见。**临键锁=记录锁+间隙锁**

外键检查约束以及重复键检查会使用间隙锁封锁区间

**next-key锁是索引记录锁加上索引记录之前的间隙锁。**

如果一个会话对索引中的记录R有一个共享或排他锁，那么另一个会话不能在紧挨着索引顺序的R**之前**的间隙插入一个新的索引记录。

## 插入意向锁（Insert Intention Locks）

插入意图锁是一种由insert操作在行插入之前设置的间隙锁类型。这个锁表明了插入的意图，如果插入到同一个索引间隙中的多个事务没有插入到间隙中的相同位置，那么它们就不需要互相等待，因为行不冲突

实例：

前提

```sql
CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;
INSERT INTO child (id) values (90),(102);
```

事务一：

```sql
在100 行之后设置间隙锁
START TRANSACTION;
SELECT * FROM child WHERE id > 100 FOR UPDATE
```

事务二：

```sql
插入
START TRANSACTION;
INSERT INTO child (id) VALUES (101);
```

此时是没有插入数据的，因为在事务一中锁住了 （100，102） 之间的间隙，导致insert 失败



## 自增锁（AUTO-INC Locks）

AUTO-INC锁是一种特殊的表级锁，由插入到带有AUTO_INCREMENT列的表中的事务获取。在最简单的情况下，如果一个事务向表中插入值，那么任何其他事务都必须等待自己向表中插入值，以便由第一个事务插入的行接收到连续的主键值。

**保证带有自增属性的列 的数值连续**



## 2、MVCC（多版本控制）

通过保存本事务的快照来控制。一个事务对应一个快照

### 原则

一个事务可见的数据：

+ 事务id < 当前事务id 
+ 本事务修改的数据

一个事务不可见的数据

+ 在事务id大于当前事务id 的新增、修改、删除
+ 活跃事务未提交的数据

### 实现

在数据库表中每行记录有两个隐藏字段。

+ DB_TRX_id:  6字节，事务id ,数据是在哪个事务中添加或者修改的就记录为哪个事务
+ DB_ROLL_id： 7字节，数据在哪个事务被删除或者别标记为旧数据就记录哪个事务id 。没有修改或者删除时为空

（1）新增一条数据并提交

此时事务id为1

| Id   | Name     | db_trx_id | db_roll_id |
| ---- | -------- | --------- | ---------- |
| 1    | Lizhi    | 1         | Null       |
| 2    | Xiaohong | 1         | Null       |

(2) 查询

此时事务id =2,查询时显示两条

(3) 新增一条数据

此时事务id=3 

| Id   | Name      | db_trx_id | db_roll_id |
| ---- | --------- | --------- | ---------- |
| 1    | Lizhi     | 1         | Null       |
| 2    | Xiaohong  | 1         | Null       |
| 3    | Xiaoliang | 3         | null       |

（4） 事务2 再查询

此时事务ID=2

此时查出两条：li zhi、xiaohong.因为第三条的事务id 大于当前事务查询不到

（5） 修改一条数据

| Id   | Name      | db_trx_id | db_roll_id |
| ---- | --------- | --------- | ---------- |
| 1    | Lizhi     | 1         | 5          |
| 2    | Xiaohong  | 1         | Null       |
| 3    | Xiaoliang | 3         | null       |
| 1    | Azhi      | 5         | Null       |

在修改时会保存之前的旧数据。

（6） 事务2 再查询

此时事务id=6

还是会显示两条。Li zhi 、xiao hong.最后一条的事务id 大于当前事务

（7） 新事务查询

此时事务id =7

会显示三条。但是是Azhi、xiao hong、xiaoliang

(8) 删除xiaohong

此时事务ID=8

| Id   | Name      | db_trx_id | db_roll_id |
| ---- | --------- | --------- | ---------- |
| 1    | Lizhi     | 1         | 5          |
| 2    | Xiaohong  | 1         | 8          |
| 3    | Xiaoliang | 3         | null       |
| 1    | Azhi      | 5         | Null       |

（9） 事务2 再查询

查到两条。Lizhi、Xiaohong。

**查询时只查找创建时间小于当前事务的，和删除时间大于当前事务的**

（10） 事务10 查询

查出两条。Azhi、Xiaoliang。查不到Xiaohong 因为删除时间小于查询时间

**数据库中的旧数据是存在 undo log 中的，每一条数据就是一条undo log  链**

### ReadView

用于记录事务。

| m_ids()                      | min_trx_id       | max_trx_id                        | creator_trx_id |
| ---------------------------- | ---------------- | --------------------------------- | -------------- |
| 在生成ReadView时活跃的事务id | m_ids 中的最小值 | 生成下一个ReadView 时需要分配的id | 当前事务id     |

事务可见行规则：

1. 从数据最早版本开始（und log）
2. 如果事务id < creator_trx_id 并且不在m_ids() 中：可见
3. 如果事务id < creator_trx_id 并且在m_ids() 中：不可见【未提交的活跃事务】
4. 如果事务id >  creator_trx_id : 不可见
5. 如果事务id =  creator_trx_id : 可见
6. 如果当前版本不可见，查看下一个版本，后续版本应该会覆盖之前版本。

## 3、事务实现

1. Read UnCommited (读未提交)

	不加锁

2. Read Commited（读已提交）

  普通读 Select 快照读，MVCC 实现

  每次select读取的时候都获取数据库最新的情况

  对于锁读(SELECT with For UPDATE or For SHARE)、UPDATE语句和DELETE语句，InnoDB只锁索引记录，而不锁索引记录之前的间隙，因此允许在锁住的记录旁边自由插入新记录。间隙锁定仅用于外键约束检查和重复键检查。

  对于UPDATE或DELETE语句，InnoDB只对它更新或删除的行持有锁。**不匹配行的记录锁在MySQL评估了WHERE条件后被释放。[执行过程]**

  **会导致幻读、不可重复读**

3. Repeatble Read（可重复读）

  普通读 Select 快照读，MVCC 实现

  每次select读取的时候都根据事务开启的时间点来读取，不会读取时间点之后的修改

  加锁的select (select ... in share mode、select ... for update) 

  更新操作（update 、delete ）使用记录锁、或者间隙锁

  + 如果使用唯一索引，只锁定找到的索引记录
  + 如果不使用唯一索引，会阻止其他会话插入到该范围所覆盖的间隙中，使用gap lock 或者 next-key lock  

4. Serializable （串行）

	所有的读都会转化成select ... in share mode 与update 、insert、delete 等隔离开。



脏读：本次事务没有提交，另一个事务就获取到更改的数据

不可重复读：事务A 读到num =100 ,另一个事务B 修改 num=99，事务A再次读取时读到 num=99 ，多次读的结果不一样

幻读：事务A 根据范围查询读到1条，另一个事务B插入一条数据，事务A 再次读取的时候会读取到两条数据。

**由修改、删除导致前后读取不一致叫不可重复读，由插入导致前后读取不一样叫幻读**



InnDB:

**默认使用可重复读**

|            | 读未提交 | 读提交 | 可重复读 | 序列化 |
| ---------- | -------- | ------ | -------- | ------ |
| 脏读       | Y        | N      | N        | N      |
| 不可重复读 | Y        | Y      | N        | N      |
| 幻读       | Y        | Y      | N        | N      |



**当InnoDB执行每次UPDATE时，它首先为每一行获取一个排他锁，然后决定是否修改它。如果InnoDB没有修改该行，则释放锁。否则，InnoDB将保留锁直到事务结束。**



# 使用

如果启用了自动提交模式，则每个SQL语句都会形成一个单独的事务。默认情况下，MySQL在启用自动提交的情况下为每个新连接启动会话

**启用了自动提交的会话可以通过显式的START transaction或BEGIN语句启动，并以COMMIT或ROLLBACK语句结束**

**在SET autocommit = 0的会话中禁用了自动提交模式**

默认情况下，连接到MySQL服务器时启用了自动提交模式

一致性读取意味着InnoDB使用多版本来为查询提供数据库某个时间点的快照。查询将看到在该时间点之前提交的事务所做的更改，而不会看到稍后或未提交的事务所做的更改。此规则的例外是，查询将看到同一事务中以前语句所做的更改。



可重复读：在本次事务中，所有的查询都是基于当前事务开始时刻的查询

# sql 语句

## select ... from 

一致读取，读取数据库快照，不设置锁，在Serializable 中会设置next-key lock ,如果找到唯一索引，会使用 record lock

## select... For update & select ... for share 

使用唯一索引的SHARE语句获取扫描行的锁，并释放不符合结果集中包含条件的行锁(例如，如果它们不满足WHERE子句中给出的条件)。但是，在某些情况下，行可能不会立即解锁，因为在查询执行期间，**结果行与其原始源之间的关系会丢失**。例如，在UNION中，从表中扫描(和锁定)的行可能会在评估它们是否符合结果集之前插入到临时表中。在这种情况下，临时表中的行与原始表中的行之间的关系将丢失，而原始表中的行直到查询执行结束时才会解锁。

+ Select  语句是使用具有唯一搜索条件的唯一索引
	+ 只锁定 找到的索引记录，可以执行 update 、delete 【针对不同索引】
+ Select  语句使用范围类型的搜索条件，非唯一索引。
	+ 锁定范围，不可执行相同范围的 update 、delete 

对于搜索遇到的索引记录，SELECT…FOR UPDATE阻止其他会话执行SELECT…FOR SHARE或从某些事务隔离级别的读取。一致性读会忽略在读取视图中存在的记录上设置的任何锁。

## update ... where ...

在搜索遇到的每条记录上设置一个独占的next-key  lock 。但是，对于使用唯一索引来搜索的唯一行而锁定行的语句，只需要一个索引记录锁。

## delete from ... where

同update ... where ...

## insert

INSERT设置插入行的排他锁。这个锁是一个索引记录锁，而不是next-key lock (也就是说，没有间隙锁)，并且不阻止其他会话在插入的行之前插入间隙。

在插入行之前，设置一种称为插入意图间隙锁的间隙锁类型。这个锁表明了插入的意图，如果插入到同一个索引间隙中的多个事务没有插入到间隙中的相同位置，那么它们就不需要互相等待。



如果出现重复键错误，则在重复索引记录上设置共享锁。如果有多个会话试图插入同一行，而另一个会话已经有独占锁，那么使用共享锁可能会导致死锁。

## insert ... on duplicate key update

意图：如果有这一行就执行更新操作

当发生重复键错误时，排它锁而不是共享锁被放在要更新的行上。对重复的主键值使用排他的索引记录锁。

# 死锁

根本原因是两个事务相互竞争资源。

|          | 事务A                          | 事务B                                                      |
| -------- | ------------------------------ | ---------------------------------------------------------- |
|          | 获取某一行的共享锁             |                                                            |
|          |                                | 删除操作，获取这一行的排他锁，与共享锁不兼容，进入等待队列 |
|          | 删除操作，需获取这一行的排他锁 |                                                            |
| 此时死锁 |                                |                                                            |

当启用死锁检测(默认)时，InnoDB会自动检测事务死锁，并通过回滚一个或多个事务来打破死锁。InnoDB尝试选择小事务回滚，其中事务的大小由插入、更新或删除的行数决定。

处理死锁：

*  [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/5.7/en/show-engine.html) 来查看近期执行的情况
* 如果频繁死锁，可以开启innodb_print_all_deadlocks变量来收集更多的调试信息
* 单独重发事务
* 事务短小，并且相关性 比较强
* 如果你使用锁读取(SELECT…更新或选择…在共享模式下锁定)，尝试使用较低的隔离级别，如READ COMMITTED。
* 如果事务要修改多个表的话，要保证修改的顺序
* 给表添加合适的索引
* 使用更少的锁定。如果您能够允许SELECT从旧快照返回数据，请不要向它添加FOR UPDATE或LOCK IN SHARE MODE子句。

# 锁兼容情况

（横向是已持有锁，纵向是正在请求的锁）：

<img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/oeLbnjmjPa9RlaNY/img/3f88e690-4c05-4b50-ac78-8dd1d8f5711d.webp" alt="img" style="zoom:50%;" />

不同锁之间的冲突就有可能导致死锁



事务的ACID 原则

+ A 原子性： 操作要么都成功，要么都失败   **undo log 保证**
+ C 一致性：在事务开始和完成时,数据都必须保持一致状态。从整体上看数据虽然有的多了，有的少了，但是总量不变
+ I  隔离性：事务之间不能相互影响
+ D 持久性：在事务提交之后，数据就永远存在



# 事务并发问题

脏读：读到未提交事务的数据

不可重复读：同一事务两次读取的**同一条**数据不一致（一个事务正在读，另一个事务写完，再读）

提交覆盖：一个事务写，另一个事务写，最后的事务覆盖了之前的事务结果【第二类丢失更新】

回滚覆盖：事务A写，事务B写，事务B提交，事务A回滚,事务A的回滚覆盖了事务B的提交，此类应是bug【第一类丢失更新】

幻读：两次读取的结果集不一致。少一些、多一些数据都算（另一个事务删除再插入也算幻读）

| 隔离级别 | 回滚覆盖 | 脏读 | 不可重复读 | 提交覆盖  | 幻读 |
| -------- | -------- | ---- | ---------- | --------- | ---- |
| 读未提交 | X        | 可能 | 可能       | 可能      | 可能 |
| 读已提交 | X        | X    | 可能       | 可能      | 可能 |
| 可重复读 | X        | X    | X          | X（可能） | 可能 |
| 序列化   | X        | X    | X          | X         | X    |

MySQL 在 RR 隔离级别下，普通的 SELECT 语句只是快照读，没有任何的加锁，和标准的 RR 是不一样的。如果要让 MySQL 在 RR 隔离级别下不发生提交覆盖，可以使用 SELECT ... LOCK IN SHARE MODE 或者 SELECT ... FOR UPDATE 。

# 传统隔离级别实现

传统的隔离级别是基于锁实现的，这种方式叫做 **基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC）**

共享锁的记录，其他事务也可以读，但不能写。

加了排它锁的记录，其他事务既不能读，也不能写。

| 读未提交   | 读事务 | 写事务    |
| ---------- | ------ | --------- |
| 其他读事务 | 不影响 | 不影响    |
| 其他写事务 | 不影响 | 阻塞      |
| 实现       | 不上锁 | 上持续X锁 |

| 读已提交   | 读事务    | 写事务    |
| ---------- | --------- | --------- |
| 其他读事务 | 不影响    | 阻塞      |
| 其他写事务 | 不影响    | 阻塞      |
| 实现       | 上临时S锁 | 上持续X锁 |

| 可重复读   | 读事务    | 写事务    |
| ---------- | --------- | --------- |
| 其他读事务 | 不影响    | 阻塞      |
| 其他写事务 | 阻塞      | 阻塞      |
| 实现       | 上持续s锁 | 上持续X锁 |

| 序列化     | 读事务 | 写事务 |
| ---------- | ------ | ------ |
| 其他读事务 | 阻塞   | 阻塞   |
| 其他写事务 | 阻塞   | 阻塞   |
| 实现       | 表锁   | 表锁   |

 **其实阻塞的是索引**

# mysql 的隔离级别

LBCC 技术都可以实现，但是它最大的问题是它只实现了并发的读读，**对于并发的读写还是冲突的**，写时不能读，读时不能写。

MVCC 的全称叫做 **Multi-Version Concurrent Control（多版本并发控制）**，InnoDb 会为每一行记录增加几个隐含的“辅助字段”，（实际上是 3 个字段：一个隐式的 ID 字段，一个事务 ID，还有一个回滚指针）

InnoDb 通过 MVCC 实现了读写并行，但是在不同的隔离级别下，读的方式也是有所区别的。首先要特别指出的是，在 read uncommit 隔离级别下，每次都是读取最新版本的数据行，所以不能用 MVCC 的多版本，而 serializable 隔离级别每次读取操作都会为记录加上读锁，也和 MVCC 不兼容，所以只有 RC 和 RR 这两个隔离级别才有 MVCC



**RC 总是读取记录的最新版本，如果该记录被锁住，则读取该记录最新的一次快照，而 RR 是读取该记录事务开始时的那个版本。**虽然这两种读取方式不一样，但是它们读取的都是快照数据，并不会被写操作阻塞，所以这种读操作称为 **快照读（Snapshot Read）**，有时候也叫做 **非阻塞读（Nonlocking Read）**，RR 隔离级别下的叫做 [**一致性非阻塞读（Consistent Nonlocking Read）**](https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html)。

除了 **快照读** ，MySQL 还提供了另一种读取方式：**当前读（Current Read）**，有时候又叫做 **加锁读（Locking Read）** 或者 **阻塞读（Blocking Read）**，这种读操作读的不再是数据的快照版本，而是数据的最新版本，并会对数据加锁，根据加锁的不同，又分成两类：

- SELECT ... LOCK IN SHARE MODE：加 S 锁
- SELECT ... FOR UPDATE：加 X 锁
- INSERT / UPDATE / DELETE：加 X 锁

当前读在 RR 和 RC 两种隔离级别下的实现也是不一样的：**RC 只加记录锁，RR 除了加记录锁，还会加间隙锁，用于解决幻读问题*

修改mysql的会话事务隔离级别（只对当前会话的**下一次事务生效**）

- set transaction isolation level read uncommitted;
- set transaction isolation level read committed;
- set transaction isolation level repeatable read;
- set transaction isolation level serializable;

修改mysql全局事务隔离级别（不会改变当前会话的隔离级别，而是对新的会话有影响）

set global transaction isolation level read committed;



# 隔离性

有四种隔离级别，mysql 默认是 RR (读已提交)

| 事务隔离级别 | 设置方式                             | 问题                                                         | 实现方式                                                     |
| ------------ | ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 读未提交(RU) | set tx_isolation= 'read-uncommitted' | 会读到其他事务中未提交的数据                                 | 无                                                           |
| 读已提交(RC) | set tx_isolation='read-committed'    | 不会读到其他事务中未提交的数据<br />多次读取相同数据结果不一样 | MVCC 通过不同的可见策略导致看到不同的数据                    |
| 可重复读     | set tx_isolation='repeatable-read'   | 多次读取结果相同<br />会读到其他事务新插入的数据             | MVCC <br />select 操作不会更新版本号[快照读]<br />update、delete、insert 会更新版本号，当前读 |
| 串行化       | set tx_isolation='serializable'      | 不会出现读取、更新错误的情况                                 | select 加读锁<br />update、delete、insert 加写锁             |

MVCC  是通过 undo 日志处理，

如果执行了插入操作的话，undo里面就记录一条删除语句

如果执行了更新操作的话，undo里面就记录了原始数据



在table 中 自动维护 trx_id: 事务id 、 roll_pointer: 回滚指针  指向上一步操作



# 解读 SHOW ENGINE INNODB STATUS;

**显示的不是当前状态，是过去一段时间范围内innoDB 执行情况**

| BACKGROUND THREAD                     | 后台Master线程                                               |
| :------------------------------------ | :----------------------------------------------------------- |
| SEMAPHORES                            | 信号量信息                                                   |
| LATEST DETECTED DEADLOCK              | 最近一次死锁信息，只有产生过死锁才会有                       |
| TRANSACTIONS                          | 事物信息                                                     |
| FILE I/O                              | IO Thread信息                                                |
| INSERT BUFFER AND ADAPTIVE HASH INDEX | INSERT BUFFER和自适应HASH索引                                |
| LOG                                   | 日志                                                         |
| BUFFER POOL AND MEMORY                | BUFFER POOL和内存                                            |
| INDIVIDUAL BUFFER POOL INFO           | 如果设置了多个BUFFER POOL实例，这里显示每个BUFFER POOL信息。可通过innodb_buffer_pool_instances参数设置 |
| ROW OPERATIONS‍‍                        | 行操作统计信息‍‍                                               |
| END OF INNODB MONITOR OUTPU           | 输出结束语                                                   |

```sql
# 当前日期
=====================================
2021-12-23 18:53:51 7f0c9cd28700 INNODB MONITOR OUTPUT
=====================================
# 自上次输出以来的时间
Per second averages calculated from the last 39 seconds

-----------------
BACKGROUND THREAD
-----------------
# master Thread 执行情况
# srv_active为之前的每秒的循环，srv_idle为每10秒的的循环；srv_shutdown为停止的循环，通常为0，只在MySQL关闭时才会增加。
# 根据循环次数可大概判断当前数据库负载情况。如果每秒循环次数少，每10秒次数多，证明当前负载很低；如果每秒循环次数多，每10秒次数少，远大于10：1，证明当前负载很高。
srv_master_thread loops: 4346148 srv_active,  0 srv_shutdown, 2170504 srv_idle
srv_master_thread log flush and writes: 6516648

---------
高并发相关
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 7814572
OS WAIT ARRAY INFO: signal count 12055502
Mutex spin waits 67497239, rounds 115662293, OS waits 610936
RW-shared spins 20467070, rounds 416284062, OS waits 6686750
RW-excl spins 1874510, rounds 19984783, OS waits 189941
Spin rounds per wait: 1.71 mutex, 20.34 RW-shared, 10.66 RW-excl

------------------------
上次死锁情况
LATEST DETECTED DEADLOCK
------------------------
2021-12-22 20:11:40 7f0bf43d2700
# 第一个事务
*** (1) TRANSACTION:
# ACTIVE 表示事务活动时间 ,inserting:事务当前运行状态，其他状态：fetching rows，updating，deleting，inserting
TRANSACTION 1191064881, ACTIVE 24 sec inserting
# 有几张表被使用，是否有表锁，有几个表锁
mysql tables in use 1, locked 1
# 事务正在等待锁，锁链表结构的长度，每个结构表示持有的锁。为事务分配的堆内存大小，多少个行锁，有多少 undo 操作
LOCK WAIT 4 lock struct(s), heap size 1184, 4 row lock(s), undo log entries 2
MySQL thread id 8000428, OS thread handle 0x7f0bf6cf4700, query id 1632526539 218.106.117.210 saas update
# 正在等待锁的sql语句,有可能不是罪魁祸首
insert into account values(null,'Jay',100)
# 正在等待的锁类型
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
# 锁类型，要加锁的位置
RECORD LOCKS space id 8985 page no 4 n bits 72 index `idx_name` of table `logs`.`account` trx id 1191064881 
lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 3; hex 576569; asc Wei;;
 1: len 4; hex 80000002; asc     ;;

# 第二个事务
*** (2) TRANSACTION:
# 执行的操作类型
TRANSACTION 1191068252, ACTIVE 13 sec inserting
# 当前事务使用1个表，持有1个锁
mysql tables in use 1, locked 1
# LOCK WAIT表示正在等待锁, 6 lock struct(s) = 锁链表的长度为6 每个链表节点代表该事务持有的一个锁结构；heap size=表示事务分配的锁堆内存大小；5 row lock(s) = 该事物持有锁的个数
5 lock struct(s), heap size 1184, 4 row lock(s), undo log entries 2
MySQL thread id 8000380, OS thread handle 0x7f0bf43d2700, query id 1632530059 218.106.117.210 saas update
# 执行的操作类型
insert into account values(null,'Yan',100)
*** (2) HOLDS THE LOCK(S):
# 锁住的资源 index：加锁的索引 table：锁定记录的表，
# page no =事务锁定页的数量，若是表锁，该值为null
RECORD LOCKS space id 8985 page no 4 n bits 72 index `idx_name` of table `logs`.`account` trx id 1191068252 lock_mode X locks gap before rec
Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 3; hex 576569; asc Wei;;
 1: len 4; hex 80000002; asc     ;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 8985 page no 4 n bits 72 index `idx_name` of table `logs`.`account` trx id 1191068252 lock_mode X insert intention waiting
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

# 回归的事务
*** WE ROLL BACK TRANSACTION (1)

# 事务信息
------------
TRANSACTIONS
------------
Trx id counter 1214468655
Purge done for trx's n:o < 1214468577 undo n:o < 0 state: running but idle
History list length 1220
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 0, not started
MySQL thread id 8106341, OS thread handle 0x7f0c9cd28700, query id 1678904121 11.192.101.45 saas init
/* Query from DMS-WEBSQL-0-Qid_1640256830846 by user 279411300834433704 */ SHOW ENGINE INNODB STATUS
---TRANSACTION 1214467717, not started
MySQL thread id 8106333, OS thread handle 0x7f0bf43d2700, query id 1678902294 

--------
FILE I/O
--------
I/O thread 0 state: waiting for completed aio requests (insert buffer thread)
I/O thread 1 state: waiting for completed aio requests (log thread)
I/O thread 2 state: waiting for completed aio requests (read thread)
I/O thread 8 state: waiting for completed aio requests (write thread)
Pending normal aio reads: 0 [0, 0, 0, 0] , aio writes: 0 [0, 0, 0, 0] ,
 ibuf aio reads: 0, log i/o's: 0, sync i/o's: 0
Pending flushes (fsync) log: 0; buffer pool: 0
226529896 OS file reads, 58068025 OS file writes, 28146659 OS fsyncs
23.23 reads/s, 16384 avg bytes/read, 13.36 writes/s, 5.62 fsyncs/s
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 3079, seg size 3081, 794285 merges
merged operations:
 insert 1444947, delete mark 120928, delete 46386
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 276671, node heap has 264 buffer(s)
5353.43 hash searches/s, 1740.62 non-hash searches/s
---
LOG
---
Log sequence number 59275700043
Log flushed up to   59275700025
Pages flushed up to 59275693466
Last checkpoint at  59275693466
0 pending log writes, 0 pending chkp writes
22166060 log i/o's done, 4.59 log i/o's/second

# buffer pool 信息
----------------------
BUFFER POOL AND MEMORY
----------------------
# 分配给缓冲池的总内存(以字节为单位)。
Total memory allocated 137363456; in additional pool allocated 0
# 分配给InnoDB数据字典的总内存(以字节为单位)。
Dictionary memory allocated 10573223
# 分配给缓冲池的页面的总大小。
Buffer pool size   8191
# 缓冲池空闲列表的总页大小。
Free buffers       1022
# buffer pool LRU列表的总页面大小。
Database pages     6905
# buffer pool old LRU子列表的总页面大小。
Old database pages 2528
Modified db pages  32
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 94310767, not young 8050267524
10.82 youngs/s, 836.34 non-youngs/s
Pages read 226502422, created 614802, written 34141947
23.23 reads/s, 0.10 creates/s, 8.56 writes/s
Buffer pool hit rate 999 / 1000, young-making rate 0 / 1000 not 38 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 6905, unzip_LRU len: 0
I/O sum[2140]:cur[2], unzip sum[0]:cur[0]

--------------
ROW OPERATIONS
--------------
0 queries inside InnoDB, 0 queries in queue
0 read views open inside InnoDB
Main thread process no. 1, id 139692453914368, state: sleeping
Number of rows inserted 5027305, updated 15495535, deleted 381933, read 64931462045
0.64 inserts/s, 2.31 updates/s, 0.46 deletes/s, 7336.97 reads/s
----------------------------
END OF INNODB MONITOR OUTPUT
============================
```

