# 简单对象，不配置rollback

bean 对象是基础对象，非代理对象

```java
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(BeanConfig.class);
UserService bean = (UserService) context.getBean("userService");
bean.save(); 


@Transactional()
    public void save() {
        System.out.println("orderService = " + orderService);
        jdbcTemplate.execute("insert  into  user  values (8,\"bbbbbb\"); ");
        throw new NullPointerException();
    }
```

结果：会回滚，配置不配置rollbackFor 不影响事务

原因：rollbackFor 默认配置的是 RuntimeException



# 代理对象，配置rollbackFor

结果：会回滚，

原因：最终代理对象执行的还是通过 目标对象去执行，目标对象是能被@Transactional 增强的





# 调用同类方法

```java
  @Transactional(rollbackFor = Exception.class)
    public void save() {
        System.out.println("orderService = " + orderService);
        jdbcTemplate.execute("insert  into  user  values (8,\"bbbbbb\"); ");
        update();
    }
    
    @Transactional(propagation = Propagation.NEVER)
    public void update() {
        System.out.println("a ");
    }
```

结果：不会回滚

![image-20241108002443797](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411080024871.png)



解决方法

注入字节

```java
@Component
public class UserService {

    @Autowired
    private OrderService orderService;

    @Autowired
    private UserService userService;
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
}
```

![image-20241108003041213](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411080030257.png)

target 的userService 是代理对象，因为要从容器中获取，容器中是代理对象

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411080034746.png" alt="image-20241108003434700" style="zoom:50%;" />

在执行的时候，update是由代理对象去执行，并且是同一个代理对象。在执行代理类方法的时候会走切面逻辑【事务切面】，如果执行目标对象的时候，就是直接执行。

**想要事务生效的话，需要指定的类为代理类，因为代理类才会执行切面**