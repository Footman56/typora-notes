期望统一处理项目中遇到的异常，业务不需要关注异常的处理，并且转换成对用户友好的提示。

拦截异常需要重点考虑的请求执行的**时间**，**顺序**，**对结果的封装**

执行的顺序：

Filter > Interceptor > ControllerAdvice > Aspect > Controller

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202306061423917.png" alt="image-20230606142317610" style="zoom:50%;" />

# 一、filter

**过滤器**，并不是SpringBoot的内容，是依赖于Servlet容器，属于Servlet规范的一部分

Filter的执行由Servlet容器回调完成

Filter的生命周期由Servlet容器管理

##  实现一

1. 先定义过滤器，实现Filter 接口，重写doFilter，如果需要继续执行的话，必须执行**filterChain.doFilter(servletRequest, servletResponse);**

   可以继承OncePerRequestFilter, 重写doFilterInternal()，优点是请求只会被过滤一次，不会重复过滤

   请求发向 servlet 时会被 Filter 拦截，如果 servlet 将请求转发给另一个 servlet，请求发向第二个 servlet 时，依旧会被相同的 Filter 拦截。结果就是一个请求被同一个 Filter 拦截了两次。

   `OncePerRequestFilter` 一个请求只被过滤器拦截一次。请求转发不会第二次触发过滤器。

```java
/**
 * 执行时间过滤器
 * @author peilizhi
 * @date 2023/5/25 23:04
 **/
@Slf4j
public class PerformTimeFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
    }

    /**
     * 过滤器
     *
     * @param servletRequest  请求
     * @param servletResponse 响应
     * @param filterChain     过滤器链
     */
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        log.info("PerformTimeFilter 开始拦截");
        long start = System.currentTimeMillis();
        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
        // 获取请求方式
        String method = httpServletRequest.getMethod();
        String requestURI = httpServletRequest.getRequestURI();
        // 继续执行过滤链，如果不写的话，就不会交给controller
        filterChain.doFilter(servletRequest, servletResponse);
        long spentTime = System.currentTimeMillis() - start;
        log.info("请求执行用时,requestURI:{},method:{},spentTime:{}", requestURI, method, spentTime);
    }

    @Override
    public void destroy() {
        Filter.super.destroy();
    }
}

```

2. 添加到ioc 中

   ```java
   /**
    * @author peilizhi
    * @date 2023/5/25 23:09
    **/
   @Configuration
   public class FilterConfig {
       @Bean
       public FilterRegistrationBean<PerformTimeFilter> registrationPerformTimeFilter() {
           FilterRegistrationBean<PerformTimeFilter> filterRegistrationBean = new FilterRegistrationBean<>();
           // 添加过滤器
           filterRegistrationBean.setFilter(new PerformTimeFilter());
           // 配置拦截的路径
           filterRegistrationBean.addUrlPatterns("/*");
           // 配置序号，序号越小越优先执行
           filterRegistrationBean.setOrder(1);
           filterRegistrationBean.setName("performTimeFilter");
           return filterRegistrationBean;
       }
   }
   ```

   如果是上述注册方法，PerformTimeFilter类里面无法使用IOC 容器中的bean，仅是创建PerformTimeFilter实例，没有给实例中的属性进行初始化，可以使用@Bean来进行初始化

   ```java
       @Bean
       public PerformTimeFilter performTimeFilter() {
           return new PerformTimeFilter();
       }
       
       @Bean
       public FilterRegistrationBean<PerformTimeFilter> registrationPerformTimeFilter() {
           FilterRegistrationBean<PerformTimeFilter> filterRegistrationBean = new FilterRegistrationBean<>();
           // 添加过滤器
           filterRegistrationBean.setFilter(performTimeFilter());
           // 配置拦截的路径
           filterRegistrationBean.addUrlPatterns("/*");
           // 配置序号
           filterRegistrationBean.setOrder(5);
           filterRegistrationBean.setName("performTimeFilter");
           return filterRegistrationBean;
       }
   ```

   

   ## 实现二

   通过@WebFilter注解，注解中可以指定过滤url，过滤器名称

   1. 创建过滤器

   ```java
   /**
    * 登陆拦截器
    *
    * @author peilizhi
    * @date 2023/5/26 00:24
    **/
   @WebFilter(filterName = "loginFilter", urlPatterns = "/*")
   @Slf4j
   public class LoginFilter implements Filter {
       @Override
       public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
           log.info("开始执行loginFilter");
           HttpServletRequest httpServletRequest = (HttpServletRequest) request;
           final String remoteUser = httpServletRequest.getRemoteUser();
           log.info("remoteUser :{}", remoteUser);
           chain.doFilter(request, response);
           log.info("loginFilter执行完");
       }
   }
   
   ```

   2. 添加到容器中

      + @Bean
      + @ServletComponentScan("com.huochai.infrastructure.filters")

      **可以直接使用IOC 容器里面的bean**

   使用@WebFilter 注解的Filter 默认会**落后**于采用FilterRegistrationBean 注册的。多个含有@WebFilter 注解的执行顺序是类的执行顺序依赖于Filter的名称，是根据Filter类名的字母顺序排列(A优先）

   **结束的顺序与执行的顺序相反**

# 二、interceptor

**拦截器**，拦截器则是独立存在的，可以在任何情况下使用，**是Spring 框架的拦截器**

拦截器通常通过动态代理的方式来执行。**拦截器则可以通过IoC容器来管理**，因此可以通过注入等方式来获取其他Bean的实例

拦截器可以分为两部分：

+ WebMVC：负责拦截请求，类似于过滤器，对用户的请求在Controller接收前进行处理，在Controller处理完成后加工结果等。使用时需实现HandlerInterceptor接口
+ AOP：拦截指定类型的方法，通过动态代理模式实现，可以在方法的调用前和调用后添加功能处理。使用时需要实现MethodInterceptor接口。
  + 实现MethodInterceptor接口
  + 利用Aspect的注解或配置

1. 实现HandlerInterceptor 接口，重写preHandle，postHandle，afterCompletion 方法

```java
/**
 * 登陆拦截
 *
 * @author peilizhi
 * @date 2023/6/5 17:47
 **/
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 在请求之前执行
     *
     * @return true 继续执行后续拦截或者执行controller，false 提前退出
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (handler instanceof HandlerMethod) {
            HandlerMethod method = (HandlerMethod) handler;
            Method methodMethod = method.getMethod();
            log.info("当前拦截的方法为：{}", methodMethod.getName());
            log.info("当前拦截的方法参数长度为：{}", methodMethod.getParameters().length);
            log.info("当前拦截的方法为：{}", method.getBean().getClass().getName());
            String uri = request.getRequestURI();
            System.out.println("拦截的uri：" + uri);
        }
        // 设置为false 不会继续执行controller ，但是会继续执行filter,客户端接受不到返回数据
        return true;
    }

    /**
     * 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后），不一定会触发[Restful 风格的不需要渲染视图]
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        log.info("执行LoginInterceptor.postHandle");
    }

    /**
     * 在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行
     * （主要是用于进行资源清理工作），肯定会触发
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        log.info("执行LoginInterceptor.afterCompletion");
    }
}

```

2. 配置拦截器

   + xml 文件形式（忽略）

   + Bean 注册

     ```java
     /**
      * @author peilizhi
      * @date 2023/6/6 10:14
      **/
     @Configuration
     public class InterceptorConfig {
     
         /**
          * 注册成MappedInterceptor 格式的，
          * DispatcherServlet 获取过滤器链的时候会从容器中获取是MappedInterceptor 类型的
          */
         @Bean
         public MappedInterceptor loginInterceptor() {
             return new MappedInterceptor(new String[]{"/**"}, new String[]{"/login"}, new LoginInterceptor());
         }
     }
     ```

   + API

     ```java
     /**
      * @author peilizhi
      * @date 2023/6/6 11:42
      **/
     @Configuration
     public class Interceptor2Config implements WebMvcConfigurer {
     		/**
          * Add Spring MVC lifecycle interceptors for pre- and post-processing of
          * controller method invocations and resource handler requests.
          * Interceptors can be registered to apply to all requests or be limited
          * to a subset of URL patterns.
          */
         @Override
         public void addInterceptors(InterceptorRegistry registry) {
             registry.addInterceptor(new LoginInterceptor()).addPathPatterns("/**").order(3);
             // 添加拦截器
             registry.addInterceptor(accessLimitInterceptor())
                     // 配置拦截路径
                     .addPathPatterns("/**").order(6);
         }
     
         @Bean
         public AccessLimitInterceptor accessLimitInterceptor() {
             return new AccessLimitInterceptor();
         }
     
     }
     
     ```

     注：此时不用同时出现实现WebMvcConfigurer 和继承 WebMvcConfigurationSupport 的配置类，如果同时存在的话，会重写addInterceptor() 导致实际一个配置类生效，并不是想象中的每个配置类都生效。**推荐使用WebMvcConfigurer方式**

3. 排序
   + 默认按照注册的顺序
   + 可以在注册时指定order，值越小优先级越高

# 三、@ControllerAdvice

用于对**Controller进行切面环绕**的，而具体的业务织入方式则是通过结合其他的注解来实现的。@ControllerAdvice是在类上声明的注解，其用法主要有三点：

1.全局异常处理：结合方法型注解@ExceptionHandler，用于捕获Controller中抛出的指定类型的异常，从而达到不同类型的异常区别处理的目的。

2.全局数据预处理：结合方法型注解@InitBinder，用于request中自定义参数解析方式进行注册，从而达到自定义指定格式参数的目的。

3.全局数据绑定：结合方法型注解@ModelAttribute，表示其注解的方法将会在目标Controller方法执行之前执行。

## @ModelAttribute

用于在执行controller 之前绑定一些公共参数,**作用于参数、方法上，并且在运行时生效**

```java
/**
 * controller 增强类
 * @author peilizhi
 * @date 2023/6/6 14:34
 * 如果不指定basePackages,annotations 就是对所有controller 做增强,
 * 如果指定的话就是对具体范围
 **/
@Slf4j
@ControllerAdvice(annotations = RestController.class)
public class MyControllerAdvice {
    /**
     * 把值绑定到Model中，使全局@RequestMapping可以获取到该值
     */
    @ModelAttribute
    public void addAttributes(Model model) {
        // 手动执行参数名称
        model.addAttribute("nandao", "hello world");
    }
  
    /**
     * 指定参数名称为msg
     */
    @ModelAttribute(value = "msg")
    public String msg() {
        System.out.println("hello word。");
        return "msg";
    }

    /**
     * 指定参数名称为person
     */
    @ModelAttribute(name = "person")
    public Map<String, Object> person() {
        HashMap<String, Object> map = new HashMap<>();
        map.put("age", 99);
        map.put("gender", "人");
        return map;
    }
}
```

```java
 /**
     * 获取modelMap 中设置的值
     */
    @RequestMapping("get-model")
    public void getModel(ModelMap modelMap) {
        Object nandao = modelMap.get("nandao");
        Object msg = modelMap.get("msg");
        Object person = modelMap.get("person");
    }

    /**
     * 参数从Model 中获取
     */
    @RequestMapping("from-model")
    public void fromModel(@ModelAttribute("msg") String msg) {
        System.out.println("msg = " + msg);
    }

```



## @InitBinder

解析一些自定义参数，保证前端可以很灵活的传递参数给后端，仅作用于方法上，运行时生效

如果@InitBinder 写在具体Controller 内，仅对当前Controller中@RequestMapping注解方法生效，如果写在含@ControllerAdvice注解的类里面的话，就是对所有@RequestMapping注解方法

```java
		/**
     * 应用到所有被@RequestMapping注解的方法，在其执行之前初始化数据绑定器
     */
    @InitBinder
    public void globalInitBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
    }

     /**
     * 如果出现重名的属性时候，指定对应的前缀
     * @param binder
     */
    @InitBinder("nan")
    public void b(WebDataBinder binder) {
        binder.setFieldDefaultPrefix("nan.");
    }

    @InitBinder("nv")
    public void a(WebDataBinder binder) {
        binder.setFieldDefaultPrefix("nv.");
    }
```

```java
@RequestMapping("get-date")
    public void getDate(Date date) {
        System.out.println("date = " + date);
    }


    @PostMapping("get-object")
    public void getObject(@ModelAttribute("nan") Demo demo) {
        System.out.println("demo = " + demo);
    }
```

如果不指定的@InitBinder 的话，传过来“2022-10-23” 格式的数据就无法解析成Date 对象

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202306061645778.png" alt="image-20230606164511593" style="zoom:50%;" />

并且使用的时候必须加上@ModelAttribute(name) name 的值必须与绑定的@InitBinder 设置的值一致

## @ExceptionHandler

用于处理指定的异常，进行转换友好处理，**作用于方法上，并且只在运行时生效**。 value 指定0个或者多个异常，没有设置的时候就是默认全部 Throwable 及子类

```java
/**
     * 此注解主要是自定义异常功能,返回json格式的数据
     */
    @ExceptionHandler(value = NullPointerException.class)
    @ResponseBody
    public Object logicExceptionHandler(Exception e) {
        //如果是业务逻辑异常，返回具体的错误码与提示信息，即可以自定义多种异常类型
        log.info("处理空指针异常,e", e);
        return null;
    }
```

**推荐使用@ExceptionHandler  + @ControllerAdvice 配置来进行异常处理**，一般业务中会自定义一些异常类，来处理不同的情景，，但是不够统一，并且也会bim不了出现一些空指针问题，这种异常就不合适展示给客户，需要进行统一异常拦截。

也可以作用于Controller 类内部，仅对当前类生效。还可以在@ControllerAdvice 类中对全局生效

# 四、@RestControllerAdvice

与@ControllerAdvice 功能类似，但是返回的数据都是json ,@ControllerAdvice 返回的数据是ModelView 形式的

# 五、HandlerExceptionResolver

```java
public interface HandlerExceptionResolver {
	@Nullable
	ModelAndView resolveException(
			HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);
}
```

所有自定义异常捕获类都要继承HandlerExceptionResolver，并且重写resolveException(), 只能对一种异常进行处理，不推荐，推荐使用@ExceptionHandler

```java
@Slf4j
@Component
public class MyExceptionHandler implements HandlerExceptionResolver {

    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        if (ex instanceof NullPointerException) {
            log.info("MyExceptionHandler 捕获空指针异常");
        }
        return new ModelAndView();
    }
}
```

通常一类异常只会有一个异常捕获类处理，

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202306072015599.png" alt="image-20230607201509020" style="zoom:50%;" />

如果自定义HandlerExceptionResolver不重写Ordered 接口的话，默认是会排在@ExceptionHandler注解之后的。在这条链路中任意一个处理类返回非null 值的话，后面的处理类就不会再继续执行

# 六、aspect

