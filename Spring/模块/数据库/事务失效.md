# 一、@Transactional失效

1. 在同类中A方法没有配置@Transactional ，B方法配置@Transactional，外界调用A方法,B方法的事务失效

   原因：由于使用`Spring AOP`代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由`Spring`生成的代理对象来管理。

   解决：采用编程式事务；或者获取代理类，代理类调用

   ```java
   @GetMapping("/test")
       private Integer A() throws Exception {
           CityInfoDict cityInfoDict = new CityInfoDict();
           cityInfoDict.setCityName("2");
          
          // B 插入字段为 3的数据,获取代理类
           Test test = (Test)AopContext.currentProxy();
    
           int insert=test.insertB();
          
           int insert = cityInfoDictMapper.insert(cityInfoDict);
    
           return insert;
       }
    
       @Transactional()
       public Integer insertB() throws Exception {
           CityInfoDict cityInfoDict = new CityInfoDict();
           cityInfoDict.setCityName("3");
           cityInfoDict.setParentCityId(3);
    
           return cityInfoDictMapper.insert(cityInfoDict);
       }
   
   ```

   

2. 注解放在private、protected 上失效

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/19/170f0e025a51a1b4~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述" style="zoom:50%;" />

失效是因为在Spring AOP 代理时，如上图所示 `TransactionInterceptor` （事务拦截器）在目标方法执行前后进行拦截，`DynamicAdvisedInterceptor`（CglibAopProxy 的内部类）的 intercept 方法或 `JdkDynamicAopProxy` 的 invoke 方法会间接调用 `AbstractFallbackTransactionAttributeSource`的 `computeTransactionAttribute` 方法，获取Transactional 注解的事务配置信息。

```java
protected TransactionAttribute computeTransactionAttribute(Method method,
    Class<?> targetClass) {
        // Don't allow no-public methods as required.
        if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
        return null;
}
```

3. @Transactional 注解属性 propagation 设置错误

`TransactionDefinition.PROPAGATION_SUPPORTS`：如果当前存在事务，则加入该事务；如果当前没有事务，则以**非事务的方式**继续运行。

 `TransactionDefinition.PROPAGATION_NOT_SUPPORTED`：**以非事务方式运行**，如果当前存在事务，则把当前事务挂起。 `TransactionDefinition.PROPAGATION_NEVER`：**以非事务方式运行**，如果当前存在事务，则抛出异常。

4. @Transactional 注解属性 rollbackFor 设置错误

   `rollbackFor` 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查`unchecked`异常（继承自 `RuntimeException` 的异常）或者 `Error`才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 **rollbackFor**属性。

5. 数据库引擎不支持事务

   一旦数据库引擎切换成不支持事务的`myisam`，那事务就从根本上失效了。

6. 方法内捕获异常，并内部处理，不抛出