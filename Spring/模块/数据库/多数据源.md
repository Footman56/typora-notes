通常一个项目只访问一个数据库，但是一些特殊的情况，可能会访问多个数据库。此时就需要多数据源配置。一个数据源有着自己要访问的数据库，自己的sql 文件，自己的事务。

可以简单的分成三种实现：多套数据源，动态数据源，参数化变更源。

# 多套数据源

多套数据源的实现很简单，就是数据库、事务、链接池等都是独立的。

实现起来简单，但是有大量冗余的代码，有可能数据库下的内容一致，但是还是需要多搞一套数据库，sql

资源浪费：针对每一个数据源写一套操作，连接数据库的资源也是独立的，分别占用同样多的资源。`SqlSessionFactory` 是一个工厂，建议是使用单例，完全可以重用，不需要建立多个，只需要更改数据源即可，跟多线程，使用线程池减少资源消耗是同一道理。

缺乏灵活：所有需要使用的地方都需要引入对应的mapper，对于很多操作，只是选择数据源的不一样，代码逻辑是一致的。另外，对于一主多从的情况，若需要对多个从库进行负载均衡，相对比较麻烦。

1. 数据库连接配置

   ```jdbc1.properties
   spring.database.master.url=jdbc:mysql://localhost:3306/test?useUnicode=true&zeroDateTimeBehavior=convertToNull&autoReconnect=true&characterEncoding=utf-8&useSSL=false&allowPublicKeyRetrieval=true
   spring.database.master.username=huochai
   spring.database.master.password=asdf1234
   spring.database.master.driver-class-name=com.mysql.cj.jdbc.Driver
   ```

   ```jdbc2.properties
   spring.database.salve.url=jdbc:mysql://localhost:3306/test1?useUnicode=true&zeroDateTimeBehavior=convertToNull&autoReconnect=true&characterEncoding=utf-8&useSSL=false&allowPublicKeyRetrieval=true
   spring.database.salve.username=huochai
   spring.database.salve.password=asdf1234
   spring.database.salve.driver-class-name=com.mysql.cj.jdbc.Driver
   ```

2. 配置类

   ```java
   
   /**
    *
    *@author peilizhi
    *@date 2023/11/7 11:17
    **/
   @Configuration
   @PropertySource("classpath:jdbc1.properties")
   // 扫描的mapper 类
   @MapperScan(basePackages = {"com.huochai.domain.**.mapper.master"}, sqlSessionFactoryRef = "masterSqlSessionFactory")
   public class MasterDataSourceConfig {
   
       //==================================数据库配置 start=====================================//
   
   
       /**
        * 配置主数据源-使用 durid 连接池
        * @return
        */
       @Primary
       @Bean("masterDataSource")
       @ConfigurationProperties(prefix = "spring.database.master")
       public DataSource masterDataBase() throws SQLException {
           DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
           druidDataSource.setInitialSize(5);
           druidDataSource.setMinIdle(10);
           druidDataSource.setMaxActive(20);
           druidDataSource.setMaxWait(6000);
           druidDataSource.setTimeBetweenEvictionRunsMillis(2000);
           druidDataSource.setMinEvictableIdleTimeMillis(600000);
           druidDataSource.setMaxEvictableIdleTimeMillis(900000);
           druidDataSource.setValidationQuery("select 1");
           druidDataSource.setTestOnReturn(false);
           druidDataSource.setTestOnBorrow(false);
           druidDataSource.setKeepAlive(true);
           druidDataSource.setPhyMaxUseCount(500);
           druidDataSource.setFilters("stat");
           return druidDataSource;
       }
   
       //==================================数据库配置 end=====================================//
   
   
       //==================================mybatis配置 start=====================================//
       @Primary
       @Bean("masterSqlSessionFactory")
       public SqlSessionFactory masterSqlSessionFactory(@Qualifier("masterDataSource") DataSource dataSource) throws Exception {
           // 设置数据源
           SqlSessionFactoryBean masterSqlFactory = new SqlSessionFactoryBean();
           masterSqlFactory.setDataSource(dataSource);
           //mapper的xml文件位置
           PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
           String locationPattern = "classpath*:/mapper/master/*.xml";
           masterSqlFactory.setMapperLocations(resolver.getResources(locationPattern));
           return masterSqlFactory.getObject();
       }
   
   
       /**
        * 配置事务管理器
        */
       @Primary
       @Bean("masterPlatformTransaction")
       public DataSourceTransactionManager masterPlatformTransactionManager(@Qualifier("masterDataSource") DataSource dataSource) {
           return new DataSourceTransactionManager(dataSource);
       }
   
       //==================================mybatis配置 start=====================================//
   }
   ```

   

```java
/**
 *
 *@author peilizhi
 *@date 2023/11/7 11:52
 **/
@Configuration
@PropertySource("classpath:jdbc2.properties")
@MapperScan(basePackages = "com.huochai.domain.**.mapper.slave", sqlSessionFactoryRef = "salveSqlSessionFactory")
public class SlaveDataSourceConfig {


    @Bean("slaveDataSource")
    @ConfigurationProperties(prefix = "spring.database.salve")
    public DataSource slaveDataSource() throws SQLException {
        DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
        druidDataSource.setInitialSize(5);
        druidDataSource.setMinIdle(10);
        druidDataSource.setMaxActive(20);
        druidDataSource.setMaxWait(6000);
        druidDataSource.setTimeBetweenEvictionRunsMillis(2000);
        druidDataSource.setMinEvictableIdleTimeMillis(600000);
        druidDataSource.setMaxEvictableIdleTimeMillis(900000);
        druidDataSource.setValidationQuery("select 1");
        druidDataSource.setTestOnReturn(false);
        druidDataSource.setTestOnBorrow(false);
        druidDataSource.setKeepAlive(true);
        druidDataSource.setPhyMaxUseCount(500);
        druidDataSource.setFilters("stat");
        return druidDataSource;
    }


    @Bean("salveSqlSessionFactory")
    public SqlSessionFactory salveSqlSessionFactory(@Qualifier("slaveDataSource") DataSource dataSource) throws Exception {
        // 设置数据源
        SqlSessionFactoryBean masterSqlFactory = new SqlSessionFactoryBean();
        masterSqlFactory.setDataSource(dataSource);
        //mapper的xml文件位置
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        String locationPattern = "classpath*:/mapper/slave/*.xml";
        masterSqlFactory.setMapperLocations(resolver.getResources(locationPattern));
        return masterSqlFactory.getObject();
    }


    @Bean("salveDataSourceTransaction")
    public DataSourceTransactionManager salveDataSourceTransaction(@Qualifier("slaveDataSource") DataSource dataSource) {
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }
}

```

# 动态数据源

动态数据源可以根据自己的需要实时切换数据源，就不用写两套代码。通过注解来区别不同的数据源。

1. 先配置一个数据源

```java
/**
 *第一个数据源
 *@author peilizhi
 *@date 2023/11/7 11:17
 **/
@Configuration
@PropertySource("classpath:jdbc1.properties")
// 扫描的mapper 类
@MapperScan(basePackages = {"com.huochai.domain.**.mapper.master"}, sqlSessionFactoryRef = "masterSqlSessionFactory")
public class MasterDataSourceConfig {

    //==================================数据库配置 start=====================================//
    /**
     * 配置主数据源-使用 durid 连接池
     * @return
     */
    @Bean(BaseConstant.MASTER_DATABASE)
    @ConfigurationProperties(prefix = "spring.database.master")
    public DataSource masterDataBase() throws SQLException {
        DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
        druidDataSource.setInitialSize(5);
        druidDataSource.setMinIdle(10);
        druidDataSource.setMaxActive(20);
        druidDataSource.setMaxWait(6000);
        druidDataSource.setTimeBetweenEvictionRunsMillis(2000);
        druidDataSource.setMinEvictableIdleTimeMillis(600000);
        druidDataSource.setMaxEvictableIdleTimeMillis(900000);
        druidDataSource.setValidationQuery("select 1");
        druidDataSource.setTestOnReturn(false);
        druidDataSource.setTestOnBorrow(false);
        druidDataSource.setKeepAlive(true);
        druidDataSource.setPhyMaxUseCount(500);
        druidDataSource.setFilters("stat");
        druidDataSource.setName("masterDataBase");
        return druidDataSource;
    }

    //==================================数据库配置 end=====================================//


    //==================================mybatis配置 start=====================================//
    @Bean("masterSqlSessionFactory")
    public SqlSessionFactory masterSqlSessionFactory(@Qualifier(BaseConstant.MASTER_DATABASE) DataSource dataSource) throws Exception {
        // 设置数据源
        SqlSessionFactoryBean masterSqlFactory = new SqlSessionFactoryBean();
        masterSqlFactory.setDataSource(dataSource);
        // mapper的xml文件位置
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        String locationPattern = "classpath*:/mapper/master/*.xml";
        masterSqlFactory.setMapperLocations(resolver.getResources(locationPattern));
        return masterSqlFactory.getObject();
    }
    /**
     * 配置事务管理器
     */
    @Bean("masterPlatformTransaction")
    public DataSourceTransactionManager masterPlatformTransactionManager(@Qualifier(BaseConstant.MASTER_DATABASE) DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    //==================================mybatis配置 start=====================================//
}
```

2. 配置第二个数据源

```java
/**
 * 第二个数据源
 *@author peilizhi
 *@date 2023/11/7 11:52
 **/
@Configuration
@PropertySource("classpath:jdbc2.properties")
@MapperScan(basePackages = "com.huochai.domain.**.mapper.slave", sqlSessionFactoryRef = "salveSqlSessionFactory")
public class SlaveDataSourceConfig {
    @Bean(BaseConstant.SLAVE_DATABASE)
    @ConfigurationProperties(prefix = "spring.database.salve")
    public DataSource slaveDataSource() throws SQLException {
        DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
        druidDataSource.setInitialSize(5);
        druidDataSource.setMinIdle(10);
        druidDataSource.setMaxActive(20);
        druidDataSource.setMaxWait(6000);
        druidDataSource.setTimeBetweenEvictionRunsMillis(2000);
        druidDataSource.setMinEvictableIdleTimeMillis(600000);
        druidDataSource.setMaxEvictableIdleTimeMillis(900000);
        druidDataSource.setValidationQuery("select 1");
        druidDataSource.setTestOnReturn(false);
        druidDataSource.setTestOnBorrow(false);
        druidDataSource.setKeepAlive(true);
        druidDataSource.setPhyMaxUseCount(500);
        druidDataSource.setFilters("stat");
        druidDataSource.setName("slaveDataSource");
        return druidDataSource;
    }


    @Bean("salveSqlSessionFactory")
    public SqlSessionFactory salveSqlSessionFactory(@Qualifier(BaseConstant.SLAVE_DATABASE) DataSource dataSource) throws Exception {
        // 设置数据源
        SqlSessionFactoryBean masterSqlFactory = new SqlSessionFactoryBean();
        masterSqlFactory.setDataSource(dataSource);
        //mapper的xml文件位置
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        String locationPattern = "classpath*:/mapper/slave/*.xml";
        masterSqlFactory.setMapperLocations(resolver.getResources(locationPattern));
        return masterSqlFactory.getObject();
    }


    @Bean("salveDataSourceTransaction")
    public DataSourceTransactionManager salveDataSourceTransaction(@Qualifier(BaseConstant.SLAVE_DATABASE) DataSource dataSource) {
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }
}
```

3. 配置代理数据源（根据实际情况可以切换成不同的数据源）

   事物相关的就使用代理数据源

```java
/**
 *@author peilizhi
 *@date 2023/11/27 18:12
 **/
public class DynamicDataSourceContextHolder {
    /**
     * 动态数据源名称上下文
     */
    private static final ThreadLocal<String> DATASOURCE_CONTEXT_KEY_HOLDER = new ThreadLocal<>();

    /**
     * 设置/切换数据源 在上下文中
     */
    public static void setContextKey(String key) {
        DATASOURCE_CONTEXT_KEY_HOLDER.set(key);
    }

    /**
     * 从上下文中获取数据源名称
     */
    public static String getContextKey() {
        String key = DATASOURCE_CONTEXT_KEY_HOLDER.get();
        // 设置默认
        return key == null ? BaseConstant.MASTER_DATABASE : key;
    }

    /**
     * 删除当前数据源名称,保证下次请求时根据实际情况获取数据源
     */
    public static void removeContextKey() {
        DATASOURCE_CONTEXT_KEY_HOLDER.remove();
    }
}

```

配置了这个AbstractRoutingDataSource 在获取Connection的时候动态获取数据源

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202401041722324.png" alt="img" style="zoom:100%;" />

```java
/**
 * 重载动态数据源
 *@author peilizhi
 *@date 2023/11/8 18:06
 **/
public class DynamicDataSource extends AbstractRoutingDataSource {
    /**
     * 确定当前查找键。这通常用于检查线程绑定事务上下文。
     * 允许使用任意键。返回的密钥需要与存储的查找密钥类型匹配，
     * 如该 resolveSpecifiedLookupKey 方法所解析的那样。 获取数据源的key
     * 获取数据源的key
     */
    @Override
    protected Object determineCurrentLookupKey() {
        return DynamicDataSourceContextHolder.getContextKey();
    }
}
```



```java
/**
 * 动态数据源
 *@author peilizhi
 *@date 2023/11/8 17:56
 **/
@Configuration
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
// 只要custom.database = dynamic 才生效
@ConditionalOnProperty(name = "custom.database", havingValue  = "dynamic")
@MapperScan(basePackages = "com.huochai.domain.testDomain.mapper", sqlSessionFactoryRef = "dynamicSqlSessionFactory")
public class DynamicDataSourceConfig {

    @Resource
    private MasterDataSourceConfig masterDataSourceConfig;
    @Resource
    private SlaveDataSourceConfig slaveDataSourceConfig;

    @Primary
    @Bean("dynamicDataSource")
    public DataSource dynamicDataSource() throws SQLException {
        DynamicDataSource dataSource = new DynamicDataSource();
        // 备选数据源,后续根据参数从备选数据源中获取
        Map<Object, Object> targetDataSources = new HashMap<>(2);
        targetDataSources.put(BaseConstant.MASTER_DATABASE, masterDataSourceConfig.masterDataBase());
        targetDataSources.put(BaseConstant.SLAVE_DATABASE, slaveDataSourceConfig.slaveDataSource());
        dataSource.setTargetDataSources(targetDataSources);
        // 默认数据源
        dataSource.setDefaultTargetDataSource(masterDataSourceConfig.masterDataBase());
        return dataSource;
    }

    @Primary
    @Bean("dynamicSqlSessionFactory")
    public SqlSessionFactory dynamicSqlSessionFactory(@Qualifier("dynamicDataSource") DataSource dataSource) throws Exception {
        // 设置数据源
        SqlSessionFactoryBean masterSqlFactory = new SqlSessionFactoryBean();
        masterSqlFactory.setDataSource(dataSource);
        // mapper的xml文件位置
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        String locationPattern = "classpath*:/mapper/master/*.xml";
        masterSqlFactory.setMapperLocations(resolver.getResources(locationPattern));
        return masterSqlFactory.getObject();
    }

    /**
     * 配置事务管理器
     */
    @Primary
    @Bean("dynamicPlatformTransaction")
    public DataSourceTransactionManager dynamicPlatformTransactionManager(@Qualifier("dynamicDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

4. 切面配置动态切换

```java
/**
 * 数据源
 * @date 2023/11/27 18:17
 * @author by peilizhi
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface DS {
    /**
     * 手动制定数据源
     * @return
     */
    String value() default BaseConstant.MASTER_DATABASE;
}
```



```java
/**
 *@author peilizhi
 *@date 2023/11/27 18:19
 **/
@Aspect
@Component()
public class DsAspect {

    @Pointcut("@annotation(com.huochai.infrastructure.aop.annotation.DS)")
    public void pointCut() {
    }

    @Around("pointCut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        DS dsAnnotation = getDSAnnotation(joinPoint);
        String dsKey = null == dsAnnotation ? BaseConstant.MASTER_DATABASE : dsAnnotation.value();
        DynamicDataSourceContextHolder.setContextKey(dsKey);
        try {
            // 在执行的时候
            return joinPoint.proceed();
        } finally {
            DynamicDataSourceContextHolder.removeContextKey();
        }
    }

    /**
     * 根据类或方法获取数据源注解
     */
    private DS getDSAnnotation(ProceedingJoinPoint joinPoint) throws NoSuchMethodException {

        Class<?> targetClass = ClassUtil.getClass(joinPoint.getTarget());

        DS dsAnnotation = targetClass.getAnnotation(DS.class);
        // 先判断类的注解，再判断方法注解
        if (Objects.nonNull(dsAnnotation)) {
            return dsAnnotation;
        } else {
            MethodSignature signature = (MethodSignature) joinPoint.getSignature();
            String methodName = signature.getName();
            Method method = signature.getMethod();
            // 获取注解配置的参数
            Method declaredMethod = targetClass.getDeclaredMethod(methodName, method.getParameterTypes());
            Annotation[] annotations = declaredMethod.getAnnotations();
            DS annotation = declaredMethod.getAnnotation(DS.class);
            return annotation;
        }
    }
}
```

