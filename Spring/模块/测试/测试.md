# 一、SpringBoot

## 1、依赖

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <!--默认使用junit5-->
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
```

## 2、测试Service

```
使用Ide自动的测试类
能够自动补充需要测试的方法
```

<img src="/Users/mac/Pictures/截图/屏幕快照 2021-04-12 21.43.57.png" style="zoom:50%;" />

```java
//SpringBoot1.4版本之前用的是SpringJUnit4ClassRunner.class
@RunWith(SpringRunner.class)
//SpringBoot1.4版本之前用的是@SpringApplicationConfiguration(classes = Application.class)
@SpringBootTest
class HelloServiceImplTest {
    
  	// 依赖注入
    @Autowired
    HelloService helloService;


    @Test
    void sayHello() {
        helloService.sayHello();
    }

    @Test
    void sayByb() {
        helloService.sayByb("xiaoli");
    }
}
```

## 3、测试controller

```
需要对Controller层（API）做测试，这时候就得用到MockMvc了，你可以不必启动工程就能测试这些接口。
MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用

junit4.x版本之前使用的是@Before注解

junit5.x版本以后使用的是@BeforeEach注解

两个注解功能相同 表示在测试类中任何一个测试方法执行之前都先执行该注解标注的方法

实例化MockMvc有两种形式，一种是使用StandaloneMockMvcBuilder，
另外一种是使用DefaultMockMvcBuilder。测试类及初始化MockMvc初始化：
```

```java
/**
 * @author by peilizhi
 * @date 2021/4/12 19:53
 */
@RunWith(SpringRunner.class)
@SpringBootTest
class HelloControllerTest {

    @Autowired
    private WebApplicationContext wac;

    private MockMvc mvc;
    private MockHttpSession session;
    
    @BeforeEach
    public void setupMockMvc(){
       
        
      // 实例化方式一 可能service没有值
				mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build();
	   // 实例化方式二 建议使用
      	mvc = MockMvcBuilders.webAppContextSetup(wac).build(); 
        session = new MockHttpSession();
    }
    
    final MvcResult result = mvc.perform(MockMvcRequestBuilders.get("/electricPower/ajax-query-electricPower-by-machineNum")
                .param("machineNum", "111111110")
                // 手动指定格式
                                      
                .accept("application/json;charset=UTF-8")
        )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andDo(MockMvcResultHandlers.print())
                .andReturn();
    
    
    
    @Test
    void hello() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get("/learn/resource/1001")
                .contentType(MediaType.APPLICATION_JSON_UTF8)
                .accept(MediaType.APPLICATION_JSON_UTF8)
                .param()
                .param()
                .param()
                .session(session)
        )
       .andExpect(MockMvcResultMatchers.status().isOk())
       .andExpect(MockMvcResultMatchers.jsonPath("$.author").value("嘟嘟MD独立博客"))
       .andExpect(MockMvcResultMatchers.jsonPath("$.title").value("Spring Boot干货系列"))
       .andDo(MockMvcResultHandlers.print());
    }
}
```

```java
/*
	 * 1、mockMvc.perform执行一个请求。
	 * 2、MockMvcRequestBuilders.get("XXX")构造一个请求。
	 * 3、MockHttpServletRequestBuilder.param添加请求传值
	 contentType(MediaType.APPLICATION_JSON_UTF8)代表发送端发送的数据格式是application/json;charset=UTF-8
	 * 4、ResultActions.accept(MediaType.TEXT_HTML_VALUE))设置返回类型
	 * 5、ResultActions.andExpect添加执行完成后的断言。
	 * 6、ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情
	 *   比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。
	 * 7、ResultActions.andReturn表示执行完成后返回相应的结果。
	 */

使用 MockMvc来模拟http请求
  

ResultActions
  andExpect()
  andDo()
  andReturn()  
  
```

```java
测试普通控制器
mockMvc.perform(get("/user/{id}", 1)) //执行请求  
            .andExpect(model().attributeExists("user")) //验证存储模型数据  
            .andExpect(view().name("user/view")) //验证viewName  
            .andExpect(forwardedUrl("/WEB-INF/jsp/user/view.jsp"))//验证视图渲染时forward到的jsp  
            .andExpect(status().isOk())//验证状态码  
            .andDo(print()); //输出MvcResult到控制台

得到MvcResult自定义验证
MvcResult result = mockMvc.perform(get("/user/{id}", 1))//执行请求  
        .andReturn(); //返回MvcResult  
Assert.assertNotNull(result.getModelAndView().getModel().get("user")); //自定义断言

验证请求参数绑定到模型数据及Flash属性
mockMvc.perform(post("/user").param("name", "zhang")) //执行传递参数的POST请求(也可以post("/user?name=zhang"))  
            .andExpect(handler().handlerType(UserController.class)) //验证执行的控制器类型  
            .andExpect(handler().methodName("create")) //验证执行的控制器方法名  
            .andExpect(model().hasNoErrors()) //验证页面没有错误  
            .andExpect(flash().attributeExists("success")) //验证存在flash属性  
            .andExpect(view().name("redirect:/user")); //验证视图 

文件上传
byte[] bytes = new byte[] {1, 2};  
mockMvc.perform(fileUpload("/user/{id}/icon", 1L).file("icon", bytes)) //执行文件上传  
        .andExpect(model().attribute("icon", bytes)) //验证属性相等性  
        .andExpect(view().name("success")); //验证视图 


JSON请求/响应验证
String requestBody = "{\"id\":1, \"name\":\"zhang\"}";  
    mockMvc.perform(post("/user")  
            .contentType(MediaType.APPLICATION_JSON).content(requestBody)  
            .accept(MediaType.APPLICATION_JSON)) //执行请求  
            .andExpect(content().contentType(MediaType.APPLICATION_JSON)) //验证响应contentType  
            .andExpect(jsonPath("$.id").value(1)); //使用Json path验证JSON 请参考http://goessner.net/articles/JsonPath/  
      
    String errorBody = "{id:1, name:zhang}";  
    MvcResult result = mockMvc.perform(post("/user")  
            .contentType(MediaType.APPLICATION_JSON).content(errorBody)  
            .accept(MediaType.APPLICATION_JSON)) //执行请求  
            .andExpect(status().isBadRequest()) //400错误请求  
            .andReturn();  
      
    Assert.assertTrue(HttpMessageNotReadableException.class.isAssignableFrom(result.getResolvedException().getClass()));//错误的请求内容体



异步测试
//Callable  
    MvcResult result = mockMvc.perform(get("/user/async1?id=1&name=zhang")) //执行请求  
            .andExpect(request().asyncStarted())  
            .andExpect(request().asyncResult(CoreMatchers.instanceOf(User.class))) //默认会等10秒超时  
            .andReturn();  
      
    mockMvc.perform(asyncDispatch(result))  
            .andExpect(status().isOk())  
            .andExpect(content().contentType(MediaType.APPLICATION_JSON))  
            .andExpect(jsonPath("$.id").value(1));  


全局配置
mockMvc = webAppContextSetup(wac)  
            .defaultRequest(get("/user/1").requestAttr("default", true)) //默认请求 如果其是Mergeable类型的，会自动合并的哦mockMvc.perform中的RequestBuilder  
            .alwaysDo(print())  //默认每次执行请求后都做的动作  
            .alwaysExpect(request().attribute("default", true)) //默认每次执行后进行验证的断言  
            .build();  
      
    mockMvc.perform(get("/user/1"))  
            .andExpect(model().attributeExists("user"));

```

## 4、junit

```java
Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库
@ExtendWith(SpringExtension.class)
//@SpringBootTest 注解告诉 Spring Boot 查找带 @SpringBootApplication 注解的主配置类，
//并使用该类启动 Spring 应用程序上下文。
@SpringBootTest
public class ApplicationTests {
    @Test
    public void contextLoads() {
    }
}


@BeforeEach 替换 @Before
@BeforeAll 替换 @BeforeClass
@AfterEach 替换 @After
@AfterAll 替换 @AfterClass
```

## 5、assert

```java
 String n = "xiao";
// containsString：字符串变量中包含指定字符串时，测试通过
assertThat(n, containsString("xiao"));
// startsWith：字符串变量以指定字符串开头时，测试通过
assertThat(n, startsWith("xi"));
// endsWith：字符串变量以指定字符串结尾时，测试通过
assertThat(n, endsWith("ao"));
// euqalTo：字符串变量等于指定字符串时，测试通过
assertThat(n, equalTo("xiao"));
// equalToIgnoringCase：字符串变量在忽略大小写的情况下等于指定字符串时，测试通过
assertThat(n, equalToIgnoringCase("xiao"));
// equalToIgnoringWhiteSpace：字符串变量在忽略头尾任意空格的情况下等于指定字符串时，测试通过
assertThat(n, equalToIgnoringWhiteSpace(" xiao   "));


int s = 1;
// allOf：所有条件必须都成立，测试才通过（大于1同时小于3）
assertThat(s, allOf(greaterThan(1), lessThan(3)));
// anyOf：只要有一个条件成立，测试就通过 （大于1或者小于2）
assertThat(s, anyOf(greaterThan(1), lessThan(2)));
// anything：无论什么条件，测试都通过
assertThat(s, anything());
// is：变量的值等于指定值时，测试通过
assertThat(s, is(2));
// not：和is相反，变量的值不等于指定值时，测试通过
assertThat(s, not(1));

List<String> list = new ArrayList();
// hasItem：Iterable变量中含有指定元素时，测试通过
assertThat(list, hasItem("xiao"));
Map<String, String> m = new HashMap<>();
// hasEntry：Map变量中含有指定键值对时，测试通过
assertThat(m, hasEntry("xi", "xiao"));
// hasKey：Map变量中含有指定key时，测试通过
assertThat(m, hasKey("x"));
// hasValue：Map变量中含有指定value值时，测试通过
assertThat(m, hasValue("x"));


double d = 1D;
// closeTo：浮点型变量的值在3.0±0.5范围内，测试通过
assertThat(d, closeTo(3.0, 0.5));
// greaterThan：变量的值大于指定值时，测试通过
assertThat(d, greaterThan(3.0));
// lessThan：变量的值小于指定值时，测试通过
assertThat(d, lessThan(3.5));
// greaterThanOrEuqalTo：变量的值大于等于指定值时，测试通过
assertThat(d, greaterThanOrEqualTo(3.3));
// lessThanOrEqualTo：变量的值小于等于指定值时，测试通过
assertThat(d, lessThanOrEqualTo(3.4));
```

```yaml
spring:
  application:
    # 应用名称
    name: machine-monitor-webapp
   # 数据库连接
  datasource:
    username: huochai
    password: Admin123@
    url: jdbc:mysql://47.96.235.128:3306/machine_monitor?useSSL=false&serverTimezone=UTC
    driver-class-name: com.mysql.cj.jdbc.Driver
# 服务端口号
server:
  port: 8080    
```

