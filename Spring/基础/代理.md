# 定义

```jade
AOP 即 Aspect Oriented Program 面向切面编程
```

**AOP能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。**

```
切面(Aspect)： Aspect 声明类似于 Java 中的类声明，事务管理是AOP一个最典型的应用。在AOP中，切面一般使用 @Aspect 注解来使用，在XML 中，可以使用 <aop:aspect> 来定义一个切面。

连接点(Join Point): 一个在程序执行期间的某一个操作，就像是执行一个方法或者处理一个异常。在Spring AOP中，一个连接点就代表了一个方法的执行。

通知(Advice):在切面中(类)的某个连接点(方法出)采取的动作，会有四种不同的通知方式： around(环绕通知)，before(前置通知)，after(后置通知)， exception(异常通知)，return(返回通知)。许多AOP框架（包括Spring）将建议把通知作为为拦截器，并在连接点周围维护一系列拦截器。

切入点(Pointcut):表示一组连接点，通知与切入点表达式有关，并在切入点匹配的任何连接点处运行(例如执行具有特定名称的方法)。由切入点表达式匹配的连接点的概念是AOP的核心，Spring默认使用AspectJ切入点表达式语言。
介绍(Introduction): introduction可以为原有的对象增加新的属性和方法。例如，你可以使用introduction使bean实现IsModified接口，以简化缓存。

目标对象(Target Object): 由一个或者多个切面代理的对象。也被称为"切面对象"。由于Spring AOP是使用运行时代理实现的，因此该对象始终是代理对象。

AOP代理(AOP proxy): 由AOP框架创建的对象，在Spring框架中，AOP代理对象有两种：JDK动态代理和CGLIB代理
织入(Weaving): 是指把增强应用到目标对象来创建新的代理对象的过程，它(例如 AspectJ 编译器)可以在编译时期，加载时期或者运行时期完成。与其他纯Java AOP框架一样，Spring AOP在运行时进行织入。
```

```
前置通知(Before Advice): 在目标方法被调用前调用通知功能；相关的类org.springframework.aop.MethodBeforeAdvice
后置通知(After Advice): 在目标方法被调用之后调用通知功能；相关的类org.springframework.aop.AfterReturningAdvice
返回通知(After-returning): 在目标方法成功执行之后调用通知功能；
异常通知(After-throwing): 在目标方法抛出异常之后调用通知功能；相关的类org.springframework.aop.ThrowsAdvice
环绕通知(Around): 把整个目标方法包裹起来，在被调用前和调用之后分别调用通知功能相关的类org.aopalliance.intercept.MethodInterceptor
```

```
编译期: 切面在目标类编译时被织入，这种方式需要特殊的编译器。AspectJ 的织入编译器就是以这种方式织入切面的。
类加载期: 切面在目标类加载到 JVM 时被织入，这种方式需要特殊的类加载器( ClassLoader )，它可以在目标类引入应用之前增强目标类的字节码。
运行期: 切面在应用运行的某个时期被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态创建一个代理对象，Spring AOP 采用的就是这种织入方式。
```

两种实现：基于动态代理来实现的



# cglib

```
AspectJ 是一个采用Java 实现的AOP框架，它能够对代码进行编译(一般在编译期进行)

ApectJ 主要采用的是编译期静态织入的方式。在这个期间使用 AspectJ 的 acj 编译器(类似 javac)把 aspect 类编译成 class 字节码后，在 java 目标类编译时织入，即先编译 aspect 类再编译目标类。

如果类没有实现接口的时候就无法使用jdk 代理，此时springboot就使用cglib动态代理生成代理类，CGLib直接操作字节码，生成类的子类，重写类的方法完成代理。

CGLib生成的代理类，则继承了需要进行代理的那个类

# 缺点
由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；
由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；
CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；


# 优点
使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；
CGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；
CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；

```

# jdk代理

【Springboot 默认使用】

```
jdk代理必须实现一个接口，否则方法无法被拦截
JDK动态代理生成的代理类继承了Proxy这个类


# 缺点
如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；
JDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。
JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；

# 优点
JDK动态代理是JDK原生的，不需要任何依赖即可使用；
通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；
```

**Aop机制来控制 注解**

```
对注解的前置、后置、环绕通知
```

# 自定义注解

可以通过自定义注解来表明特殊的功能，并且使用切面来实现自定义注解携带的功能

```java
/**
 * 用于统计接口耗时
 * @author by peilizhi
 * @date 2022/4/24 10:47
 */
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface SpendTime {
}
```

## @Target

用于指定注解生效的位置，

常见的是：

+ TAPE: 类、接口、注解、枚举
+ FILED:字段声明（包括枚举常量）
+ METHOD：方法声明
+  PARAMETER：  正式的参数声明 
+  CONSTRUCTOR：构造函数声明  
+  LOCAL_VARIABLE：局部变量声明    
+  ANNOTATION_TYPE：注释类型声明
+  PACKAGE：包声明  
+  TYPE_PARAMETER： 类型参数声明      @since 1.8     
+  TYPE_USE： 使用的类型   @since 1.8    

## @Retention

Reteniton的作用是定义被它所注解的注解保留多久

+ SOURCE： 被编译器忽略

+ CLASS： 注解将会被保留在Class文件中，但在运行时并不会被VM保留。这是默认行为，所有没有用Retention注解的注解，都会采用这种策略

+ RUNTIME：保留至运行时。所以我们可以通过反射去获取注解信息

  

## 自定义切面

```java
/**
 * SpendTime的切面
 * @author peilizhi
 * @date 2022/4/24 10:48
 **/
@Component
@Aspect
public class SpendTimeAop {

    @Around("@annotation(com.huochai.infrastructure.annotation.SpendTime)")
  // 最好是有返回值，否则的话就是出现空指针
    public void aroud(ProceedingJoinPoint joinpoint){
        // 获取开始时间
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        // 执行方法
        try {
             joinpoint.proceed(joinpoint.getArgs());
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }finally {
            // 获取结束时间
            stopWatch.stop();
            // 打印函数用时
            MethodSignature signature = (MethodSignature) joinpoint.getSignature();
            String methodName = signature.getName();
            System.out.println(methodName + " 执行用时" + stopWatch.prettyPrint());
        }
    }
}
```

@Component 用于加入到容器中

@Aspect 用于声明这是一个切面

**在执行方法的时候，可以引入ProceedingJoinPoint 对象用于表示反射的方法**

```java
public interface ProceedingJoinPoint extends JoinPoint {

    /**
     * The joinpoint needs to know about its closure so that proceed can delegate to closure.run().
     * This internal method should not be called directly, and won't be visible to the end-user when
     * packed in a jar (synthetic method).
     *
     * @param arc the around closure to associate with this joinpoint
     */
    void set$AroundClosure(AroundClosure arc);

    /**
     * The joinpoint needs to know about its closure so that proceed can delegate to closure.run().
     * This internal method should not be called directly, and won't be visible to the end-user when
     * packed in a jar (synthetic method). This should maintain a stack of closures as multiple around
     * advice with proceed are targeting a joinpoint and the stack will need to be unwound when
     * exiting nested advice. Passing a non null arc indicates a push, passing null indicates a pop.
     *
     * @param arc the around closure to associate with this joinpoint
     */
     default void stack$AroundClosure(AroundClosure arc) {
    	 throw new UnsupportedOperationException();
     }

    /**
     * Proceed with the next advice or target method invocation
     * 执行反射方法
     *
     * @return the result of proceeding
     * @throws Throwable if the invoked proceed throws anything
     */
    public Object proceed() throws Throwable;

    /**
     *
     */
    public Object proceed(Object[] args) throws Throwable;

}

```



```
		【普通前置】
 		{
		try{
           环绕前置
           环绕执行目标方法：目标方法执行
           环绕返回
       }catch(){
           环绕异常
       }finally
           环绕后置
           }
       }
       【普通方法返回/方法异常】
       【普通后置】
     
     *  新的顺序：
     *      环绕前置 ---> 普通前置 ---> 目标方法执行 ---> 环绕返回/异常 --- >环绕后置 ---> 普通返回/异常 ---> 普通后置
```

**环绕通知里面的异常一定要抛出去**

## 切入点

用于表明要对哪些方法进行增强，通过切点表达式来统一说明规则

切点表达式以切点指示符开始。开发人员使切点指示符来告诉切点将要匹配什么，有以下9种切点指示符：execution、within、this、target、args、@target、@args、@within、@annotation。

### execution

表示执行时匹配的方法签名：

方法签名使用全限定名，包括访问修饰符（public/private/protected）、返回类型，包名、类名、方法名、参数，其中返回类型，包名，类名，方法，参数是必须的

切点表达式

```
execution(modifier? ret-type declaring-type?name-pattern(param-pattern) throws-pattern?)
```

**带？的时候可以省略的**

- **modifier**：匹配修饰符，`public, private` 等，省略时匹配任意修饰符
- **ret-type**：匹配返回类型，使用 `*` 匹配任意类型
- **declaring-type**：匹配目标类，省略时匹配任意类型

- - `..` 匹配包及其子包的所有类

- **name-pattern**：匹配方法名称，使用 `*` 表示通配符

- - `*` 匹配任意方法
  - `set*` 匹配名称以 `set` 开头的方法

- **param-pattern**：匹配参数类型和数量

- - `()` 匹配没有参数的方法
  - `(..)` 匹配有任意数量参数的方法
  - `(*)` 匹配有一个任意类型参数的方法
  - `(*,String)` 匹配有两个参数的方法，并且第一个为任意类型，第二个为 `String` 类型

- **throws-pattern**：匹配抛出异常类型，省略时匹配任意类型

```java
/**
     * 切点表达式
     */
    @Pointcut("execution(* com.huochai.interfaces.facade.*.*(..))")
    public void getAspect() {
    }
// 第一个统配符 匹配所有返回类型
// 第二个统配符 匹配所有类
// 第三个统配符 匹配类中所有方法
// .. 匹配任意个参数，包括0个


// 匹配public方法
execution(public * *(..))
// 匹配名称以set开头的方法
execution(* set*(..))
// 匹配AccountService接口或类的方法
execution(* com.xyz.service.AccountService.*(..))
// 匹配service包及其子包的类或接口
execution(* com.xyz.service..*(..))
```

### within

使用within切点批示符可以达到上面例子一样的效果，within用来限定连接点属于某个确定类型的类，匹配指定类型。匹配指定类的任意方法，**不能匹配接口**。

```java
/**
* 指定类
*/
    @Pointcut("within(com.huochai.interfaces.facade.ExcelController)")
    public void getWithinAspect() {
    }

// 匹配service包的类
within(com.xyz.service.*)
// 匹配service包及其子包的类
within(com.xyz.service..*)
// 匹配AccountServiceImpl类
within(com.xyz.service.AccountServiceImpl)
```

###  this

this用来匹配的连接点所属的对象引用是某个特定类型的实例,如果当前要代理的类对象没有实现某个接口的话，spring aop配置属性：proxyTargetClass设为true时,则使用this.本质上使用CGLIB的动态字节码来反射代理时，使用this

```java
@Pointcut("this(com.huochai.domain.testDomain.bean.domain.Demo)")
    public void getthisAspect() {
    }

@Data
public class Demo {
    private Long id;
    private String name;
    private Integer age;
}

```

### target

target用来匹配的连接点所属目标对象必须是指定类型的实例,target指示符用于基于JDK动态代理的代理类，通俗的来讲就是如果当前要代理的目标对象有实现了某个接口的话，则使用target.

```java
@Pointcut("target(com.huochai.domain.threadDomain.bean.UserDO)")
    public void getTargetAspect() {
    }

/**
 * 实现ConvertSerive 用于类型转换
 * @author peilizhi
 * @date 2022/4/22 16:46
 **/
public class UserDO implements ConvertSerive<UserDO,UserPO> {

    private String name;

    private String sex;

    @Override
    public UserPO converToDO(UserDO userDO) {
        return null;
    }
}
```

### @Target

这个指示器匹配指定连接点，这个连接点所属的目标对象的类有一个指定的注解:

```java
// 类中含有Repository 注解
@Pointcut("@target(org.springframework.stereotype.Repository)")
```

### @args

这个指示符是用来匹配连接点的参数的，@args指出连接点在运行时传过来的参数的类必须要有指定的注解，假设我们希望切入所有在运行时接受实@Entity注解的bean对象的方法：

```java
// 运行时方法的参数必须有 指定的注解
@Pointcut("@args(org.baeldung.aop.annotations.Entity)")
```

### @annotation

```java
// 运行方法上必须有 Loggable 注解
@Pointcut("@annotation(org.baeldung.aop.annotations.Loggable)")
```

**切点表达式 可以使用&&、||、!、三种运算符来组合切点表达式，表示与或非的关系。**

## 使用切面

**使用的自定义注解的位置是必须在容器内的**

```java
/**
 * @author peilizhi
 * @date 2022/4/24 11:46
 **/
@RestController("excel/")
public class ExcelController {


    @GetMapping("export-hssf")
    @SpendTime
    public void exportHssf(){
        ExcelUtil.exportFileHSSF();
    }
}
```

**注解放在静态方法上的时候做处理失败，感觉不能对静态方法进行增强**





想要实现AOP 功能 ，@EnableAspectJAutoProxy 不是必须使用的，如果引入了AopAutoConfiguration 类的话，也能实现同样的效果。

如果在pom 中引入了[spring-boot-starter-web](https://so.csdn.net/so/search?q=spring-boot-starter-web&spm=1001.2101.3001.7020)  依赖，会自动将AopAutoConfiguration 加入到容器中。**在配置文件中有”spring.aop.auto“的配置，如果不配置为true，否则可以配置为false，为false 的话，aop相关的注解就不可以用了**

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnProperty(prefix = "spring.aop", name = "auto", havingValue = "true", matchIfMissing = true)
public class AopAutoConfiguration {
}
```





@EnableAspectJAutoProxy 中有两个参数

```java
/**
* false: 采用jdk代理 true: 采用cglib 代理
**/
boolean proxyTargetClass() default false;

	/**
	 * Indicate that the proxy should be exposed by the AOP framework as a {@code ThreadLocal}
	 * for retrieval via the {@link org.springframework.aop.framework.AopContext} class.
	 * Off by default, i.e. no guarantees that {@code AopContext} access will work.
	 * @since 4.3.1
	 */
	boolean exposeProxy() default false;
```







自定义注解失效：

1. 如果是jdk 代理的话，切面虽然在公有方法，但不是接口的方法

2. 如果是本类方法A调用本类方法B ,B上有自定义注解，此时也是失效的。因为容器中的是代理对象，代理对象方法上没有注解。

   ```java
   # 重新引入类
   AppraisalAllServiceImpl appraisalAllService = (AppraisalAllServiceImpl) AopContext.currentProxy();
   
   
   Map<String, Integer> un360DoCount = appraisalAllService.get360UnDoCount(headId, companyId, employeeId);
   
   @EnvironmentExceptionHandler
   public Map<String, Integer> get360UnDoCount(String headId, String companyId, String employeeId) {
           ResponseObject<Map<String, Integer>> responseObject = appraisal360RpcService.getUnDoCount(headId, companyId, employeeId);
           if (!responseObject.getMsg().isSuccess()) {
               throw new XrxsException(EAppraisalErrorCode.BIZ_FAILED_CODE.getCode(), "业务异常");
           }
           return responseObject.getData();
       }
   ```

   
