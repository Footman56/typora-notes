依赖循环引用是不鼓励的，默认情况下是禁止的。更新应用程序以删除bean之间的依赖循环。作为最后的手段，可以通过设置spring.main来自动打破循环。allow-circular-references为true。【极不推荐】

在springboot 2.6 之后，可以通过

```properties
spring.main.allow-circular-references=true
```



```java
public class SingleBean {

    // 饿汉模式
    //private static SingleBean singleBean = new SingleBean();

    // 使用volatile 可以避免指令重排
    // 等同于三个指令 1.定义变量 2.分配空间 3.对象赋值
    private static volatile SingleBean singleBean;

    private SingleBean getSingleBean() {
        // 双重检查锁
        // 1. 第一次检查没有值之后，再上锁，
        // 2. 上锁之后再次检查是否有值，有值可能是另一个线程已经赋值啦
        if (null == singleBean) {
            // 第一个线程执行到这里的时候，会获取到锁
            // 但是第二个线程执行到时候因为别的线程已经获取到锁，所以会等待。
            synchronized (this) {
                // 为什么需要再次检查呢？是因为线程在等待的过程中，可能其他线程已经赋值啦
                if (null == singleBean) {
                    return singleBean = new SingleBean();
                }
            }
        }
        // 有值直接返回
        return singleBean;
    }
}
```

借助单例模式可以修改从单例池中获取数据逻辑

```java
public Object getBean(String beanName) {
        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);
        if (null == beanDefinition) {
            System.out.println("没有对应的beanDefinition");
            return null;
        }
        String scope = beanDefinition.getScope();
        if ("singleton".equals(scope)) {
            //  并发问题
            Object object = singletonObjects.get(beanName);
            if (null == object) {
                // 解决并发访问问题
                synchronized (singletonObjects) {
                    if (null == singletonObjects.get(beanName)) {
                        object = createBean(beanDefinition);
                        singletonObjects.put(beanName, object);
                    }
                }
            }
            return object;
        }
        return createBean(beanDefinition);
    }
```

但是解决不了循环依赖的问题。循环依赖就是 A -> B ,B -> A

思路：在A依赖注入B的时候，不注入完整的B,注入一个中间态的B. 可以参考bean 生命周期，其实在实例化就能获取到bean【中间态】

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202411210003315.png" alt="image-20241121000319968" style="zoom:50%;" />

二级缓存可以解决简单对象直接的循环依赖

```java
 public Object getBean(String beanName) {
        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);
        if (null == beanDefinition) {
            System.out.println("没有对应的beanDefinition");
            return null;
        }
        String scope = beanDefinition.getScope();
        if ("singleton".equals(scope)) {
            //  并发问题
            Object object = singletonObjects.get(beanName);
            if (null == object) {
                // 解决并发访问问题
                synchronized (singletonObjects) {
                    if (null == singletonObjects.get(beanName)) {
                        // 实例池中仍没有对象的话，检查中间态是否有
                        Object earlyBean = earlySingletonObjects.get(beanName);
                        if (earlyBean != null) {
                            // 中间态有的话先返回，避免创建对象【创建对象就可能导致循环依赖】
                            return earlyBean;
                        } else {
                            object = createBean(beanDefinition);
                            singletonObjects.put(beanName, object);
                          // 这个时候需要排除掉 earlySingletonObjects中，因为已经创建好啦
                            earlySingletonObjects.remove(beanName);
                            return object;
                        }
                    }
                }
            }
            return object;
        }
        return createBean(beanDefinition);
    }


 private Object createBean(BeanDefinition beanDefinition) {

        Class<?> clazz = beanDefinition.getClazz();

        String beanName = beanDefinition.getBeanName();

        Object bean = null;
        try {
            bean = clazz.newInstance();
            // 实例化后存入二级缓存中
            earlySingletonObjects.put(beanName, bean);

            // 实现依赖注入--> 给属性设置值
            for (Field field : clazz.getDeclaredFields()) {
                if (field.isAnnotationPresent(Autowired.class)) {
                    Autowired autowiredAnnotation = field.getAnnotation(Autowired.class);
                    String fileName = autowiredAnnotation.name();
                    if (StrUtil.isEmpty(fileName)) {
                        // 如果Autowired 注解没有设置名称的话，名称就取字段的名称
                        fileName = field.getName();
                    }
                    Object fieldBean = getBean(fileName);
                    field.setAccessible(true);
                    field.set(bean, fieldBean);
                }
            }

        } catch (Exception e) {
            System.out.println("创建对象失败");
        }
        return bean;
    }
```

但是解决不了代理类，如果Bean被AOP增强的话，容器中存的就是代理类。

所以引入三级缓存，三级缓存存储代理类。