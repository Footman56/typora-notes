1. bean 与对象的区别？

   普通通过 new 构造方法创建的对象的属性一般是没有值的，

   bean可以通过在创建过程中的依赖注入设置属性，并且可以在创建的过程中有附加的操作，对ben a执行初始化前、初始化、初始化后操作。丰富了bean创建过程，便于动态在合适的实际执行合适的动作

2. 依赖注入的时候，先根据类型从容器去寻找bean，如果找到一个使用，否则如果有多个bean 的话，再根据名称去找，如果找不到的话就会报错。容器本质是一个Map <beanName,bean对象>

3. 在创建对象的时候是要选择构造器的。如果容器中仅有一个构造器（无论是无参构造器还是别的）就使用这个构造器，如果有多个构造器但是有无参构造器就使用无参构造器，如果没有无参构造器的话就会报错

4. 在创建bean 的过程中会在初始化之后 执行AOP逻辑，扫描所有切面，获取切面下所有的切入点，如果范围里面包含当前要 创建的bean  就会创建一个代理对象（可能是cglib，也可能是jdk），加入到容器中，**代理对象的属性是没有值的**，但是会有一个target 属性用于指向原始对象。在执行方法的时候调用的是原始对象的方法，而原始对象的属性是有值的

5. 在执行切面的时候，会缓存切面里面配置的方法，在业务调用的时候从缓存中获取切面的方法

6. Glib 代理对象的实际是通过继承原始对象来实现的，并且重写原始对象的方法

7. 为什么代理对象的属性没有值？

   因为代理对象已经通过target 指向原始对象了，执行方法的时候通过调用原始对象的方法来实现

8. Spring事物(@Transactional)的本质和aop 是一样的，也会**创建代理对象放在容器中**。

9. 事物失效分析
   1. 判断事物的传播特性
   2. 判断方法执行的时候是代理对象，还是原始对象，对象是否有事物

10. InitializingBean 是针对单个类来进行初始化的，BeanPostProcessor 中的两个方法适合对有所be an进行处理，就可以实现一些通用的方法，比如AOP,自定义注解实现、@Autowired、@PostConstruct、@PreDestroy

    

    ```java
    @Component
    public class HuochaiAopBeanPostProcessor implements BeanPostProcessor {
        /**
         * 返回一个创建好的bean ，bean既可以是原始bean，也可以是代理bean
         * @param bean
         * @param beanName
         * @return
         */
        @Override
        public Object postProcessBeforeInitialization(Object bean, String beanName) {
            if (bean instanceof UserService) {
                System.out.println(" 初始化后逻辑");
                // 判断bean全部字段
                Field[] fields = bean.getClass().getDeclaredFields();
                for (Field field : fields) {
                    // 判断字段是否存在注解
                    if (field.isAnnotationPresent(HuochaiValue.class)) {
                        HuochaiValue huochaiValueAnnotation = field.getAnnotation(HuochaiValue.class);
                        String value = huochaiValueAnnotation.value();
    
                        try {
                            field.setAccessible(true);
                            field.set(bean, value);
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        }
    
                    }
                }
            }
            return bean;
        }
    
        @Override
        public Object postProcessAfterInitialization(Object bean, String beanName) {
            // 如果只想特定类型的bean 执行次方法的话，可以判断bean的类型
            if (bean instanceof UserService) {
                System.out.println(" 初始化前逻辑");
                // 可以创建代理对象
                Object proxyInstance = Proxy.newProxyInstance(HuochaiAopBeanPostProcessor.class.getClassLoader(),
                        bean.getClass().getInterfaces(), new InvocationHandler() {
                            @Override
                            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                System.out.println("执行代理方法");
                                return method.invoke(bean, args);
                            }
                        });
                // 返回代理对象
                return proxyInstance;
            }
            return bean;
        }
    }
    ```

11. 要注意从容器中获取的对象是真实对象还是代理对象，是哪种代理对象？是否多层代理对象？

    代理对象是否没有属性值的，要获取真实对象的属性

12. getFields(): **获取某个类的所有的public字段，其中是包括父类的public字段的**。

    getDeclaredFields()：**获取某个类的自身的所有字段，不包括父类的字段**。

13.  在debug的过程中实际上调了很多次toString(在鼠标悬浮的时候，在查看对象属性的时候)

14. BeanFactory 获取bean

    ListableBeanFactory ： 获取bean 统计信息、根据类型获取bean

    HierarchicalBeanFactory： 获取父工厂（父容器）

15. 通过BeanFactory 创建的对象，是不会经过初始化、初始化前、初始化后流程的

