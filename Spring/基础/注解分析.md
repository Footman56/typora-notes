**很多注解功能的实现都是借助springboot创建容器的时候，执行一些类似后置处理的方法**

# @SpringBootApplication:

表明这是`*主配置类*`，Springboot就应用这个类的main方法来启动SpringBoot应用

```java
//注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication 
```

## @SpringBootConfiguration: 

 表明是springBoot的配置类，实际上与@Configuration 功能相同，并加入到IOC容器内，

应用程序应该只包含一个@SpringBootConfiguration并且大多数惯用的 Spring Boot 应用程序将从@SpringBootApplication继承它。

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration
```

### @Configuration 

表明这是一个配置类，声明了一个或多个@Bean方法，并且可以被 Spring 容器处理以在运行时为这些 bean 生成 bean 定义和服务请求

## @EnableAutoConfiguration：

启用 Spring Application Context 的自动配置，尝试猜测和配置您可能需要的 bean（提供一些默认配置），主要使用Import功能

**Springboot所有以@Enable开头的注解都是使用Import，来收集和注册特定场景相关的bean定义。**　

 有了这个注解就可以自动配置一些类,会装载主程序类所在的包以及子包下所有Bean,与@ComponentScan所扫描的对象不一样，会扫描@Entity类，是@ComponentScan无法支持的

使用@EnableAutoConfiguration注释的类的包，通常通过@SpringBootApplication ，具有特定的意义，通常用作“默认值”

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(EnableAutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration
```

### @AutoConfigurationPackage：

指示包含注释类的包应注册到AutoConfigurationPackages （用于存储自动配置包以供以后参考的类）

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage
```

​		@Import 是Spring的底层注解，表示引用这个类，将这个类加入到容器中

```java
@Order(Ordered.HIGHEST_PRECEDENCE)
// ImportBeanDefinitionRegistrar用于存储来自导入配置的基本包。
static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {

   @Override
   public void registerBeanDefinitions(AnnotationMetadata metadata,
         BeanDefinitionRegistry registry) {
      register(registry, new PackageImport(metadata).getPackageName());
      // 将主配置类所在的包里面的所有组件加载到容器中
   }

   @Override
   public Set<Object> determineImports(AnnotationMetadata metadata) {
      return Collections.<Object>singleton(new PackageImport(metadata));
   }
}
```

注册**当前启动类的根package**；

注册org.springframework.boot.autoconfigure.**AutoConfigurationPackages**的**BeanDefinition**。



### AutoConfigurationImportSelector

```java
@Override
	public String[] selectImports(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return NO_IMPORTS;
		}
		AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader
				.loadMetadata(this.beanClassLoader);
		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,
				annotationMetadata);
		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
	}


protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,
			AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return EMPTY_ENTRY;
		}
		AnnotationAttributes attributes = getAttributes(annotationMetadata);
    // 返回应考虑的自动配置类名称，此方法将使用SpringFactoriesLoader和getSpringFactoriesLoaderFactoryClass()加载候选人
		List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
		configurations = removeDuplicates(configurations);
		Set<String> exclusions = getExclusions(annotationMetadata, attributes);
		checkExcludedClasses(configurations, exclusions);
		configurations.removeAll(exclusions);
		configurations = filter(configurations, autoConfigurationMetadata);
		fireAutoConfigurationImportEvents(configurations, exclusions);
		return new AutoConfigurationEntry(configurations, exclusions);
	}


// 使用给定的类加载器从"META-INF/spring.factories"加载给定类型的工厂实现的完全限定类名
// factoryType：EnableAutoConfiguration.class
// classLoader：类解析器
public static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {
		String factoryTypeName = factoryType.getName();
  // 获取key,如果没有获取到就返回空集合
		return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
	}
//loadSpringFactories（）会从META-INF/spring.factories  获取所有配置类，返回的Map,再从Map中获取EnableAutoConfiguration相关的类
```

```java
private static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {
		MultiValueMap<String, String> result = cache.get(classLoader);
		if (result != null) {
			return result;
		}

		try {
      // 指定要加载类的位置
			Enumeration<URL> urls = (classLoader != null ?
          //FACTORIES_RESOURCE_LOCATION: META-INF/spring.factories
					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
      // 一个key可以对应多个value
			result = new LinkedMultiValueMap<>();
			while (urls.hasMoreElements()) {
				URL url = urls.nextElement();
				UrlResource resource = new UrlResource(url);
        // 解析文件
				Properties properties = PropertiesLoaderUtils.loadProperties(resource);
				for (Map.Entry<?, ?> entry : properties.entrySet()) {
					String factoryTypeName = ((String) entry.getKey()).trim();
					for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {
						result.add(factoryTypeName, factoryImplementationName.trim());
					}
				}
			}
      // 放到缓存中
			cache.put(classLoader, result);
			return result;
		}
		catch (IOException ex) {
			throw new IllegalArgumentException("Unable to load factories from location [" +
					FACTORIES_RESOURCE_LOCATION + "]", ex);
		}
	}
```



会给容器中导入很多的自动配置类（xxxxAutoConfiguration）

自动配置类可以免去大量的编写配置来加载功能组件

**Spring启动的时候会扫描所有jar路径下的`META-INF/spring.factories`，将其文件包装成Properties对象**

<img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220501192814709.png" alt="image-20220501192814709" style="zoom:50%;" />



**此方法会在bean实例化前被执行**

# @ComponentScan

**根据相应的规则把bean 注册到容器中**

没有指定basePackages 时，会默认扫描 @ComponentScan标注的类所在包 下所有包含@Componet

注解的类

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {

	/**
	 * 包扫描路径，会讲路径上所有包含@Component 注解的bean加入到容器中
	 */
	@AliasFor("basePackages")
	String[] value() default {};

	/**
   * 同value
	 */
	@AliasFor("value")
	String[] basePackages() default {};

	/**
	* 指定扫描类
	 */
	Class<?>[] basePackageClasses () default {};

	/**
   * 对应的bean名称的生成器 默认的是BeanNameGenerator。
	 */
	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

	/**
	 * 用于解析检测到的组件的范围。
	 */
	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;

	/**
	 */
	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

	/**
	 */
	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

	/**
	 * 指示是否应启用使用@Component @Repository 、 @Service或@Controller注释的类的自动检测
	 */
	boolean useDefaultFilters() default true;

	/**
	 * 指定哪些类型适合组件扫描。
   * 进一步将候选组件集从basePackages中的所有内容缩小到与给定过滤器或过滤器匹配的基本包中的所有内容。
	 */
	Filter[] includeFilters() default {};

	/**
	 * Specifies which types are not eligible for component scanning.
	 * @see #resourcePattern
	 */
	Filter[] excludeFilters() default {};

	/**
	 * 指定是否应为延迟初始化注册扫描的 bean。
	 */
	boolean lazyInit() default false;
```

1. 先去basePackages 、basePackageClasses的并集
2. 与includeFilters取交集

## @Filter

```java
@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {

		/**
		* ANNOTATION :筛选标有给定注释的候选
		* ASSIGNABLE_TYPE:筛选可分配给给定类型的候选人。(实际的类)
		* ASPECTJ:过滤匹配给定 AspectJ 类型模式表达式的候选者。
		* REGEX:过滤匹配给定正则表达式模式的候选者。
		* CUSTOM:使用给定的自定义org.springframework.core.type.filter.TypeFilter实现过滤候选者。
		*/
		FilterType type() default FilterType.ANNOTATION;

		/**
		 * Alias for {@link #classes}.
		 * @see #classes
		 */
		@AliasFor("classes")
		Class<?>[] value() default {};

		/**
		 */
		@AliasFor("value")
		Class<?>[] classes() default {};

		/**
		 */
		String[] pattern() default {};

	}

```

```java
@ComponentScan(value = "spring.annotation.componentscan",includeFilters = {
   @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class, Service.class}),
   @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {SchoolDao.class}),
   @ComponentScan.Filter(type = FilterType.CUSTOM, classes = {MyTypeFilter.class}),
   @ComponentScan.Filter(type = FilterType.ASPECTJ, pattern = "spring.annotation..*"),
   @ComponentScan.Filter(type = FilterType.REGEX, pattern = "^[A-Za-z.]+Dao$")
  },useDefaultFilters = false)
// useDefaultFilters必须选择 false
```

# @Scope

声明bean的作用范围

singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。

prototype : 每次请求都会创建一个新的 bean 实例。

request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。

session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。

```java
@Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}
```

# @Bean

配置bean定义，并且将bean定义的返回值加入到IOC容器内，方法名将默认成该bean定义的id

```java
/**
     * 默认使用方法名作为id
     * @return
     */
    @Bean(value = "person")
    public Person person1() {
        Person person = new Person();
        person.setAge(15);
        person.setName("小张");
        return person;
    }
```

Bean之间的依赖关系可以通过构造器，或者setter方法来声明



# @Import

指示要导入的一个或多个组件类——通常是@Configuration类。允许导入@Configuration类、 ImportSelector和ImportBeanDefinitionRegistrar实现，以及常规组件类到容器中



# @ConditionalOnBean

@ConditionalOnClass、@ConditionalOnExpression、@ConditionalOnMissingBean等注解与之功能类似

会检查类加载器中是否存在对应的类或者对应的bean，如果有的话被注解修饰的类就有资格被Spring容器所注册，否则会被skip。

```java
@Configuration
@ConditionalOnClass({ freemarker.template.Configuration.class,
        FreeMarkerConfigurationFactory.class })
@AutoConfigureAfter(WebMvcAutoConfiguration.class)
@EnableConfigurationProperties(FreeMarkerProperties.class)
public class FreeMarkerAutoConfiguration
```

含义：如果类加载器中都有freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class时候，Spring容器才会加载FreeMarkerAutoConfiguration类

## 实现

SpringBoot使用ConditionEvaluator这个内部类完成条件注解的解析和判断。在Spring容器的refresh过程中，只有跟解析或者注册bean有关系的类都会使用ConditionEvaluator完成条件注解的判断，这个过程中一些类不满足条件的话就会被skip。这些类比如有AnnotatedBeanDefinitionReader、ConfigurationClassBeanDefinitionReader、ConfigurationClassParse、ClassPathScanningCandidateComponentProvider等。

ConfigurationClassParser对每个配置类进行解析的时候都会使用ConditionEvaluator：

```java
if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
  return;
}
```

ConditionEvaluator的skip方法：

```java
public boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {
  // 如果这个类没有被@Conditional注解所修饰，不会skip
  if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {
    return false;
  }
  // 如果参数中沒有设置条件注解的生效阶段
  if (phase == null) {
    // 是配置类的话直接使用PARSE_CONFIGURATION阶段
    if (metadata instanceof AnnotationMetadata &&
        ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {
      return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);
    }
    // 否则使用REGISTER_BEAN阶段
    return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);
  }
  // 要解析的配置类的条件集合
  List<Condition> conditions = new ArrayList<Condition>();
  // 获取配置类的条件注解得到条件数据，并添加到集合中
  for (String[] conditionClasses : getConditionClasses(metadata)) {
    for (String conditionClass : conditionClasses) {
      Condition condition = getCondition(conditionClass, this.context.getClassLoader());
      conditions.add(condition);
    }
  }
  // 对条件集合做个排序
  AnnotationAwareOrderComparator.sort(conditions);
  // 遍历条件集合
  for (Condition condition : conditions) {
    ConfigurationPhase requiredPhase = null;
    if (condition instanceof ConfigurationCondition) {
      requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();
    }
    // 没有这个解析类不需要阶段的判断或者解析类和参数中的阶段一致才会继续进行
    if (requiredPhase == null || requiredPhase == phase) {
      // 阶段一致切不满足条件的话，返回true并跳过这个bean的解析
      if (!condition.matches(this.context, metadata)) {
        return true;
      }
    }
  }
  return false;
}
```

使用Map来构造缓存能够有效加快解析、获取对象的效率，一般都在含有容器意义的对象内创建Map，

MultiValueMap<String, String> result： 一个key可以对应多个value



# @Qualifier

根据具体的bean名称来注入对象。适用于容器中一个类型有多个实例的情景。是对@Autowired 的注解补充。@Autowired 仅是根据类型来判断，如果有多个实例的时候会有问题。





# @ConditionalOnProperty

根据实际情况来考虑是否加载类

name : 指定配置参数

havingValue : 指定具体的值，如果匹配才会加载



# @Value 

@value 注解不能给静态属性赋值，也不能给容器外的对象赋值

```java
 /**
     * jwt私钥
     */
    @Value("${jwt.secret}")
    private String secret;
// 这样定义是失败的，无法获取到secret 的值
private SecretKey key = Keys.hmacShaKeyFor(secret.getBytes());
```



