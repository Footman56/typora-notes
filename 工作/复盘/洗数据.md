**洗数据很关键，决不可掉以轻心**

一、洗之前

1. 确定好影响范围

2. 要确定是否需要代码清洗，还是sql 清洗。（sql 也是可以执行一些复杂的逻辑。可以通过string 参数替换函数、left join 组合多个条件）

通过多个left join 来组合条件

```sql
SELECT kai.*
FROM kpi_assessment_info kai
LEFT JOIN (
SELECT COUNT( *) c1 , assessment_id  FROM kpi_target_group  WHERE addtime <=1659369600 and addtime >=1659110400  and is_del =0 GROUP BY assessment_id 
) t1 on kai.assessment_id = t1.assessment_id
LEFT JOIN (
SELECT COUNT( *) c2  , assessment_id  FROM kpi_target_group  WHERE group_type = 8 or( group_type =5 and is_group_weight  = 0) and   addtime <=1659369600 and addtime >=1659110400  and is_del =0 GROUP BY assessment_id 
) t2 on kai.assessment_id = t2.assessment_id
WHERE kai.limit_weight =1  and kai.addtime <=1659369600 and kai.addtime >=1659110400 and kai.is_del =0 and t1.c1 = t2.c2
```

```
UPDATE kpi_plan_json_data  SET  biz_data  = REPLACE ( biz_data,'"assessmentLimitWeight":1','"assessmentLimitWeight":0')   WHERE  biz_id ='f96fb0cfda1c4051b20616fecccffffc';

```

3. 如果不能重复清洗的话，最好**备份数据**，保证在清洗失败之后能够恢复

二、开始洗

1. 要有对清洗的监控，统计成功的个数、**重点关注失败的个数**。清洗的时间

2. 提供多粒度的清洗，支持全部数据、单个公司，单个人

3. 如果功能紧密的话就做成事务，否则就内部处理异常，记录错误信息，**让程序继续执行**

4. 适当使用多线程，但不是过分关注性能。最多半小时之内解决。在使用多线程的时候，不要一个线程只处理一个实体对象，因为全量数据中有很多实体对象，就有可能导致主线程关闭，但是子线程还没有执行完，一些关键资源获取不到。

5. 尽量保证清洗代码能够重复清洗，可以先查询，如果存在的话就做更新操作，否则就是插入操作

6. 在清洗代码的过程中一些不是特别重要的日志可以不打，避免洗数据的时候,错过关键流程信息

7. 全量接口与单独数据的接口一定要不同，避免在执行的时候，因为输出接口错误导致全部数据清洗

8. 在清洗代码的时候可以分批次清洗

9. **在更新sql 的时候一定要只更新改动的字段，并且关注其他不相关的字段**。不要影响其他字段！不要影响其他字段！不要影响其他字段！【在清洗360协作人的时候，修改了表中其他字段，导致客户无法正常使用】

   **需要统一一些清洗代码的模版**

三、验证

1. **清洗完成之后必须验证**。可以提供相应的接口或者在页面上查看项目或者直接查看数据库中数据
2. 要验证清洗的字段，以及未清洗的字段