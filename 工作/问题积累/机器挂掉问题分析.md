现象： 机器jvm 内存打满 容量到达机器内存

思路：

+ 本质是内存中有大量的数据，可以从入口和出口来分析，入口故名思义就是进入到内存中，出口就是垃圾回收的问题

+ 首先确认是否有内存泄露问题：确定方法是看gc日志
+ 如果是有内存泄露的话，就尽量dump下内存来看【内存泄露的情况应很少】
+ 如果不是的话，就需要查看哪些会造成大量数据进入内存的

分析方式：

1. 最重要的是**确定案发时间**，案发时间要精确到秒，因为机器性能很好，一秒就可以做很多事

2. 查询gc 日志，这个日志是比较清晰反馈垃圾回收情况的话，其实也可以通过别的工具去看，本质是查看gc 的情况，（查看gc 的话最好是拿一段正常的时间去做对比，才能发现频率、效率的问题）

   1. 看gc 的回收频率，如果频率过于频繁的话，就需要查看这一段时间做了什么操作，导致有大量的数据进入到内存，如果不太频繁的话应该就是正常逻辑
   2. 看gc 回收的效率，如果效率很高的话，就不会是内存泄露导致的，如果效率不高的话，就有可能是内存泄露

3. 查看慢sql ，sql 极大概率导致有大量数据加载都内存中，造成内存急剧扩张，如果垃圾回收机制不太合理的话，会频繁回收，如果到达full gc 的话，会暂时中断服务响应

4. 查看此时哪些接口、rpc 比较耗时, 重点看贯穿这段时间的   因为统计耗时的话是在接口完成时统计出来的，但是内存实在这个时间断内增加的。忽略在方案时间太靠后的耗时，因为这些接口是果非因。

5. dump 下当时的内存文件，逐个对象的进行分析，查看哪些是可达的，要重点分析可达对象（因为不可达对象必定回收，可达对象才是造成内存泄露的元凶）【这个方法首先需要确定是有内存泄露，否则就是浪费时间】

   + 因为dump 的是此时的内存情况，所以内存中会有很多正常的对象，这些对象比如 log日志、mybatis 、springboot 框架下的，这些需要排除掉

   + 留意一些比较容易造成内存泄露的对象，比如 ThreadLocal、Map【静态map，一直在增加，不清掉】

     + ```java
       Temp1 = new BYTE[100];
       Temp2 = new BYTE[100];
       Temp2 = Temp1;
       Temp2的内存地址就丢掉了，而且永远都找不回了
       ```

     + 静态集合类：这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏，注意长生命周期的

     + 各种连接， 如数据库，i o 连接，使用后不关闭

     + 变量不合理的作用域: 变量定义范围大于使用范围

       ```java
       public class UsingRandom {
         private String msg;
         public void receiveMsg(){
           readFromNet();// 从网络中接受数据保存到msg中
           saveDB();// 把msg保存到数据库中
         }
       }
       // 通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。
       // 定义范围：与对象的周期一致；使用范围：receiveMsg 方法内
       ```

     + 内部类持有外部类

       一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

       ```java
       public class A {
        class B{
           public A ddd(){}
        }
       }
       ```

     + 改变哈希值

       当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露

       【不要对map的value进行修改】

     + 过期引用

       一个对象引用被无意识地保留了，垃圾回收机制不仅不会回收这个对象，而且不会回收被这个对象所引用的所有其他对象。解决方法：一旦对象引用已经过期，只需清空这些引用即可

       ```java
       public class Stack {
           private Object[] elements;
           private int size = 0;
           private static final int DEFAULT_INITIAL_CAPACITY = 16;
       
           public Stack() {
               elements = new Object[DEFAULT_INITIAL_CAPACITY];
           }
       
           public void push(Object e) {
               ensureCapacity();
               elements[size++] = e;
           }
       
           public Object pop() {
               if (size == 0)
                   throw new EmptyStackException();
               return elements[--size];
             // 问题在这里，只是返回栈顶元素，但是栈仍保留这个引用，解决方式 ,不在使用的数据设置为null
             // elements[size] = null;
           }
       
           private void ensureCapacity() {
               if (elements.length == size)
                   elements = Arrays.copyOf(elements, 2 * size + 1);
           }
       }
       ```

     + 缓存泄露

       ```java
       public class MapTest {
           static Map wMap = new WeakHashMap();
           static Map map = new HashMap();
           public static void main(String[] args) {
               init();
               testWeakHashMap();
               testHashMap();
           }
           public static void init(){
               String ref1= new String("obejct1");
               String ref2 = new String("obejct2");
               String ref3 = new String ("obejct3");
               String ref4 = new String ("obejct4");
               wMap.put(ref1, "chaheObject1");
               wMap.put(ref2, "chaheObject2");
               map.put(ref3, "chaheObject3");
               map.put(ref4, "chaheObject4");
               System.out.println("String引用ref1，ref2，ref3，ref4 消失");
           }
           public static void testWeakHashMap(){
               System.out.println("WeakHashMap GC之前");
               for (Object o : wMap.entrySet()) {
                   System.out.println(o);
               }
               try {
                   System.gc();
                   TimeUnit.SECONDS.sleep(20);
               } catch (InterruptedException e) {
                   // TODO Auto-generated catch block
                   e.printStackTrace();
               }
               System.out.println("WeakHashMap GC之后");
               for (Object o : wMap.entrySet()) {
                   System.out.println(o);
               }
           }
           public static void testHashMap(){
               System.out.println("HashMap GC之前");
               for (Object o : map.entrySet()) {
                   System.out.println(o);
               }
               try {
                   System.gc();
                   TimeUnit.SECONDS.sleep(20);
               } catch (InterruptedException e) {
                   // TODO Auto-generated catch block
                   e.printStackTrace();
               }
               System.out.println("HashMap GC之后");
               for (Object o : map.entrySet()) {
                   System.out.println(o);
               }
           }
       }
       // WeakHashMap 会释放，在gc的时候会回收
       // HashMap 不会释放，因为他的作用域是类的作用域
       ```

6. 内存问题在线程方案体现的不明显