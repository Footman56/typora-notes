异步锁使用

```java
 String redisKey = String.format(KpiConstants.CALIBRATION_MESSAGE_PRE, todoDO.getPlanId(), todoDO.getRoundGroupId());
        String traceId = tracing.currentTraceContext().get().traceIdString();
//  存在锁，或者上锁失败的话，就不执行
        if (distributedLockRedisDao.existLock(redisKey) ||
                !distributedLockRedisDao.lock(redisKey, traceId, 5 * 60 * 1000)) {
            log.warn("handleAllNextProcessBusiness 绩效校准环节发送通知 获取锁失败 planId:{},roundGroupId:{},employeeId:{}", todoDO.getPlanId(), todoDO.getRoundGroupId(), kpiAssesseeInfoDO.getEmployeeId());
            return;
        }
        try {
            pushRemindMessage(kpiAssesseeInfoDO.getCompanyId(), kpiAssesseeInfoDO.getPlanId(), kpiAssesseeInfoDO.getEmployeeId());
        } finally {
            // 释放锁
            distributedLockRedisDao.unlock(redisKey, traceId);
            log.warn("handleAllNextProcessBusiness 绩效校准环节发送通知 释放锁 planId:{},roundGroupId:{},employeeId:{}", todoDO.getPlanId(), todoDO.getRoundGroupId(), kpiAssesseeInfoDO.getEmployeeId());

        }
```

问题是 如果业务执行的太快的话，就可能导致锁释放之后 再执行进来。导致重复操作

+ 可以sleep 1～2s