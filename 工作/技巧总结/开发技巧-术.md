

# 一、开发流程

```shell
1、自己确定好需求（多问，多问，多问）
2、开发代码
3、在测试环境测试
4、在预发布环境测试
5、合并master代码
6、review代码
7、上灰度
8、合并代码
9、上线测试
```

# 二、项目部署

```shell
1、Git 来管理代码
2、使用jar包启动，
java -server -Dspring.profiles.active=docker -Denv_config=docker -Dapp.key=web.bankgate -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Duser.timezone=GMT+8 -Djava.net.preferIPv6Addresses=false -Xms512m -Xmx512m -Ddubbo.registry.address=zoo1:2181 -jar ${package_path}  


4、docker 构建
remuneration:
  image: 10.26.34.24:5000/oracle_jdk8:2.0
  ports:
  - 9627:9027
  - 26527:20527
  - 46345:44345
  volumes:
  - /etc/localtime:/etc/localtime:ro
  - /qjyd/app/devtest/java/remuneration:/qjyd/app/remuneration
  - /qjyd/app/devtest/log/remuneration:/qjyd/log/remuneration
  networks:
  - devtest_net
  entrypoint: /qjyd/app/remuneration/remuneration.sh
```

# 三、远程debug

## 1、开放新的端口

<img src="/Users/mac/Pictures/截图/屏幕快照 2021-04-06 17.40.44.png" style="zoom:50%;" />

## 2、添加启动参数

```java
java -server -Dspring.profiles.active=docker -Denv_config=docker -Dapp.key=web.bankgate -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Duser.timezone=GMT+8 -Djava.net.preferIPv6Addresses=false -Xms512m -Xmx512m -Ddubbo.registry.address=zoo1:2181 -agentlib:jdwp=transport=dt_socket,address=12300,server=y,suspend=n -jar ${package_path}



-agentlib:jdwp=transport=dt_socket,address=21993,server=y,suspend=n

指定运行的被调试应用和调试者之间的通信协议，(ie: transport=dt_socket)
远程被调试应用开通的端口，(ie: address=1043)， 可定义其他端口，比如9999
server=y 表示这个 JVM 即将被调试
suspend=n 用来告知 JVM 立即执行，不要等待未来将要附着上/连上（attached）的调试者。如果设成 y, 则应用将暂停不运行，直到有调试者连接上
```

## 3、在idea配置

<img src="/Users/mac/Pictures/截图/屏幕快照 2021-04-06 17.42.35.png" style="zoom:50%;" />

## 4、验证

<img src="/Users/mac/Pictures/截图/屏幕快照 2021-04-06 17.45.25.png" style="zoom:50%;" />

## 5、原理

```tex
远程JVM调试怎么工作的？

一切源于被称作Agents的东西。
运行着各种编译过的.class文件的JVM，有一种特性，可以允许外部的库（Java或C++写的libraries）在运行时注入到JVM中。这些外部的库就称作Agents, 他们有能力修改运行中 .class 文件的内容。
这些 Agents拥有的这些JVM的功能权限，是在JVM内运行的Java Code所无法获取的，他们能用来做一些有趣的事情，比如修改运行中的源码，性能分析等。像JRebel工具就是用了这些功能达到魔术般的效果。
传递一个Agent Lib给JVM, 通过添加 agentlib:libname[=options] 格式的启动参数即可办到。像上面的远程调试我们用的就是**-agentlib:jdwp=... **来引入jdwp这个 Agent的。
jdwp是一个JVM特定的JDWP（Java Debug Wire Protocol）可选实现，用来定义调试者与运行JVM之间的通讯，它的是通过JVM本地库的jdwp.so或者jdwp.dll支持实现的。

它到底是怎么工作的呢？

简单来说，jdwp agent会建立运行应用的JVM和调试者（本地或者远程）之间的桥梁。既然他是一个Agent Library, 它就有能力拦截运行的代码。
在JVM架构里，debugging功能在JVM本身的内部是找不到的，它是一种抽象到外部工具的方式（也称作调试者 debugger）。这些调试工具或者运行在 JVM 的本地 或者在远程。这是一种解耦，模块化的架构。
```

# 四、代码开发

## 1、类

```
1、类名要了意,类是对象，命名时使用名词.这个名词能够充分概括类的含义
2、类中的方法要精简，符合这个类的实际意义
3、属性要合理，尽量不要使用Object作为类型
4、在类上注明这个类的作用
5、这是面向对象开发
```

## 2、方法

```
1、方法命名要 名词+动词形式
动词：get,list,add,delete,update（更新）,edit(修改)
2、方法的含义、参数、返回值、异常情况要做注解说明
3、不能长度过程
4、为了后续维护，需要控制参数，尽量减少不合理的参数
5、如虽然现在有一些接口，但接口不能完美适配现在的内容，可以适当根据接口来提供新的接口
```

## 3、层级

```

```

## 4、技巧

```shell
所有实体类使用包装对象
函数的长度不能超过60 (精简逻辑)、
测试、小修改、测试、小修改.....
使用Builder来处理对象，不要使用构造器中传入对象的方法，这样比较耦合。
依赖注入的时候要保证这两者有紧密的联系。
```

**ClassLoader的getResource方法获取路径时，获取到的路径被URLEncoder.encode(path,"utf-8")编码了，当路径中存在中文和空格时，他会对这些字符进行转换**

解决方式：

```java
 URL resource = ResourceUtil.getResource("static/维度.xls");
 String decode = URLDecoder.decode(resource.getPath(), "utf-8");
```

一些固定的数据是可以放在json 里面，一些需要变化的数据是要放在Mysql。json等同于归档。



问题：原有逻辑很复杂或者修改后的逻辑很复杂的话，怎么实现新的逻辑？是重写还是在原有的基础上改造？如果是重写怎么保证不影响老数据？如果是改造,其中涉及原有逻辑不太容易阅读怎么处理？请从java工程师的角度去分析问题

```
重写：原有逻辑结构混乱、不易维护或者已经过时时，可以考虑重写。这种情况下，通过全新的代码实现可以更清晰地表达需求，提高代码的可读性和可维护性。

改造：如果原有逻辑基本正确但难以理解或扩展，可以选择改造。改造可以保留现有代码的核心结构和逻辑，通过优化、重构或者模块化等手段提升代码质量和可维护性。
```





问题：不知道接口的定义,比如返回值是什么样的？入参是什么样的？如果可能返回的有多个类型的话怎么定义。请给出函数定义的规范

```
参数类型：方法参数应尽量使用具体的类型或接口类型，而不是具体实现类

返回类型：如果方法可能返回多种类型，通常可以使用以下方式处理：
	泛型（Generics）：使用泛型定义方法，使得方法可以返回多种类型的对象。
	封装结果类：定义一个结果类（如Response、Result），该类包含状态码、消息、数据等信息，可以统一 封装多种返回结果。
	多态：返回接口类型或抽象类类型的对象，具体实现由调用者决定。
	
注意事项：
保持接口的单一职责：一个接口应该只定义一组相关的方法。
避免过多参数：方法的参数数量应该控制在合理范围内，避免过多的参数。如果参数较多，可以考虑使用对象封装参数。
清晰的命名和注释：方法名和参数名应该清晰地描述其功能，注释应该提供足够的信息以便理解。
```



问题：代码中有很多独立的待办块，这种代码块是否都需要封装成函数

```
考虑因素
	代码的复杂性：如果待办块的逻辑较复杂或涉及多个步骤，封装成函数可以帮助理清逻辑。
	重复性：如果相同或类似的逻辑块在代码中多次出现，封装成函数可以避免代码重复，提高复用性。
	功能的独立性：如果待办块代表一个独立的功能模块，封装成函数可以清晰地定义这个功能。
	代码长度：过长的代码块难以阅读和维护，将其拆分为函数可以使代码更模块化。
	调试和测试：封装成函数有助于单元测试和调试，每个函数都可以独立测试，确保其正确性。
```





问题：如何优雅的查询数据,只需要查询一次,如果查询过就使用查询过的数据,需要兼容没有结果的时候,没有结果时也不再次查询
1. 缓存

   缓存是一种常见的优化策略，可以避免重复查询，提高性能。缓存可以存储查询结果，并在需要时直接返回缓存的数据，而不是重新查询数据库或其他数据源。

   ```java
   public class DataService {
       private Data cachedData = null;
       private boolean isDataFetched = false;
       private Redis redis
   
       /**
        * 查询数据，如果已经查询过则返回缓存的数据。
        * @return 查询到的数据，或者null如果没有结果。
        */
       public Data getData() {
           if (!redis.exist(key)) {
               object value queryDataFromDataSource();
               redis.set(key,value)
           }
           return redis.get(key);
       }
   
       /**
        * 模拟从数据源查询数据。
        * @return 数据，或者null如果没有查询到结果。
        */
       private Data queryDataFromDataSource() {
           // 实际查询逻辑
           return null; // 示例返回null，表示没有数据
       }
   }
   ```

2. 懒加载

   懒加载是一种延迟初始化的策略，只有在第一次访问数据时才进行查询，并缓存结果。适用于可能不会使用到某些数据的情况。

   ```java
   public class LazyDataLoader {
       private Data data;
       private boolean isDataLoaded = false;
   
       /**
        * 获取数据，首次调用时查询数据并缓存。
        * @return 数据，或者null如果没有查询到结果。
        */
       public Data getData() {
           if (!isDataLoaded) {
               data = loadData();
               isDataLoaded = true;
           }
           return data;
       }
   
       /**
        * 实际的数据加载逻辑。
        * @return 数据，或者null如果没有查询到结果。
        */
       private Data loadData() {
           // 从数据源加载数据
           return null; // 示例返回null，表示没有数据
       }
   }
   
   ```

   3. optional

      Optional 类可以用于优雅地处理可能不存在的数据，避免显式的null检查。

```java
 Optional<List<Integer>> optionalIntegers = Optional.empty();

        for (int i = 0; i < 10; i++) {
          // 这一步是没有数据的时候查询数据
            if (!optionalIntegers.isPresent()){
                List<Integer> list = new ArrayList<>();
                list.add(1);
                list.add(3);
                list.add(5);
                optionalIntegers = Optional.ofNullable(null);
            }
          // 此刻应该是有数据，就直接使用数据，不需要再次查询
            if (optionalIntegers.isPresent()){
                List<Integer> integers = optionalIntegers.get();
                System.out.println("integers = " + integers);
            }
        }
```



**如果一个对象需要进行序列化和反序列化的时候，函数方法不能get开头，因为get开头是需要有对应的字段，否则的话就会序列化失败。**



