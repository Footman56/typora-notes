一、如果不能保证对方代码是否正确，可以复制自己的开发分支，将另一个分支合并过来。不要让对方代码侵入自己的开发分支，不然出现问题之后，不容易排查。

二、合分支的时候使用pull ，合master的时候使用merge

三、在使用**异步方法的时候尽量保证方法是独立**的，不需要执行操作数据的结果

并且注意事物的范围，**尽量不要使用事物内部方法执行的结果**







问题一 debug 查询出数据条数与数据库中实际的条数不一致。

```java
 @Transactional(rollbackFor = Exception.class)

//处理前先查一下 之前链中的人员信息, 便于插入考核记录, 原流程节点代办人是实时算出来的,所以要再查一遍流程
// debug 这里时 查询的条数与数据库中的数据一致 
        List<KpiProcessNodeDO> oldProcessModelList = getEmpProcessNodeSettingForAdmin(companyId, planId, assesseeEmpId, EFilterEvalRoleType.ROLE_TYPE);
// debug 这里时 查询的条数就与数据库中的数据不一致
// 之后就都不一致

            List<KpiProcessEmpInfoDO> withoutCuringCalibration = kpiProcessEmpInfoService.getProcessEmpInfoListWithoutCuringCalibration(companyId, planId, assesseeEmpId);
```

首先整个方法 @Transactional 包围，处于同一个事务中。代码的事务与数据库中查询的事务不是同一个，所以怀疑 getEmpProcessNodeSettingForAdmin 中执行了插入数据的逻辑。

之后 分析代码getEmpProcessNodeSettingForAdmin 确实没有做任何插入数据逻辑。

getEmpProcessNodeSettingForAdmin 方法里面也调用了 查询相同的manager方法。【此方法查询全部数据，包括代码拼接的数据】

getProcessEmpInfoListWithoutCuringCalibration 中获取出来的数据也是多了 拼接的数据。并且在日志中没有manager 查询数据库的sql日志，也就是说此时**没有真正的查询数据库，有可能是使用了查询结果的缓存**。

```java
// getEmpProcessNodeSettingForAdmin 下调用的manager方法
@Override
    public List<KpiProcessEmpInfoDO> getProcessEmpInfoList(String companyId, String planId, String assessEmpId) {
        List<KpiProcessEmpInfoPO> res = processEmpInfoManager.getProcessEmpInfoList(companyId, planId, assessEmpId);
        // 查校准的固化数据
        List<KpiProcessEmpInfoPO> calibrationProcessEmps = getCalibrationProcessEmp(companyId, Lists.newArrayList(planId), null, Lists.newArrayList(assessEmpId));
        List<KpiProcessEmpInfoPO> result = mergeProcessEmpInfoWithCalibration(res, calibrationProcessEmps);
        return convertDOList(result);
    }


// getProcessEmpInfoListWithoutCuringCalibration 下调用的manager方法
    @Override
    public List<KpiProcessEmpInfoDO> getProcessEmpInfoListWithoutCuringCalibration(String companyId, String planId, String assessEmpId) {
        log.info("获取被考核人所有被指定人信息,planId:{},assessEmpId:{}", planId, assessEmpId);
        List<KpiProcessEmpInfoPO> posList = processEmpInfoManager.getProcessEmpInfoList(companyId, planId, assessEmpId);

        log.info("获取被考核人所有被指定人信息,res:{}", JsonUtil.toJson(posList));

        List<KpiProcessEmpInfoDO> processEmpInfoDOS = new ArrayList<>(posList.size());
        for (KpiProcessEmpInfoPO kpiProcessEmpInfoPO : posList) {
            KpiProcessEmpInfoDO processEmpInfoDO = KpiProcessEmpInfoDO.convertDO(kpiProcessEmpInfoPO);
            processEmpInfoDOS.add(processEmpInfoDO);
        }

        return processEmpInfoDOS;
    }
```

可见调用的都是同一个 mapper 方法 ，也就是说**两个方法执行的sql 是一致的**。可是为啥后执行的getProcessEmpInfoListWithoutCuringCalibration返回的结果与数据库中的不一样呢？然而 getProcessEmpInfoList 方法调用Mapper 查询数据库的数据与数据库中的结果是一致的？

发现两者都是BeanCopierUtil.copyList() ,是不是BeanCopy的问题呢？又一想也不对，因为getProcessEmpInfoListWithoutCuringCalibration的结果是在BeanCopy 调用之前，debug也清晰发现返回的是PO对象。

 根据自己粗略知识，mysql 查询的时候会有缓存的，至于缓存是什么样子的就不清楚了。

突然灵感一闪，先执行getProcessEmpInfoList 的时候 结果是PoList， 之后对PoList 的做了出来，使得PoList 多了些数据，但是mysql 缓存指向的还是同样的PoList 地址，后续查询的时候没有真正查询数据库 直接使用相同的poList 地址。导致结果与上次的结果一致。

之后debug 验证果然如此

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202401301122568.png" alt="image-20240130110838431" style="zoom:50%;" />



<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202401301122751.png" alt="image-20240130110843889" style="zoom:50%;" />



上图中，方法不一致，但是结果的地址是一致的。

再想是不是 @Transactional 注解导致的呢？如果第二次查询的时候 真正查询数据库的话，就不会出现这个问题。

如果去掉事务之后，第二次查询会不会真的走数据库呢。

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202401301123738.png" alt="image-20240130111542948" style="zoom:50%;" />

实际测试之后，确实是真的执行了查询数据库。

但是却掉@Transactional 事务之后又不符合逻辑，看看还是不走查询，但是第一次的时候不对结果集进行修改的话，是不是也是相同的效果



一定要注意，不要修改事务中查询结果PO,因为如果后面有相同的sql 的话是不会重新执行的。

**同一个事务使用同一个 SqlSession** ,**没有事务的话，一次查询一个SqlSession**



**Stream#allmatch()  : 如果集合为空的时候，会返回true**





```
问题描述：IDEA使用Git时显示如下异常
xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun


需要在终端输入 xcode-select --install

之后重启Idea 
```

