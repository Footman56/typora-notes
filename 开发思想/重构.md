# 一、定义

```
重构是在写好的代码基础上进行优化设计
```

# 二、测试机制

```
测试是保证
多次测试，每次测试的内容要修改尽量少
```

# 三、经验

```
1、将过长的函数精简
2、需要抽取逻辑泥团作为函数
3、确定函数的局部变量，参数和返回值：没有改变的适合作为参数，只有一个变量被改变就作为返回值
4、测试，测试是否能够执行
5、改名，函数内变量的名称，函数的名称
6、检查函数的位置是否正确（函数应该放在它所使用的数据的所属对象）
7、迁移函数，修改参数
8、更改函数名
9、找出旧程序所有函数引用点并修改（可以去掉）
10、去掉临时变量，（可以避免同一个量被传来传去，如果被计算多次就可以转换成类的属性）
11、测试
12、局部变量如果不涉及读取，但做了修改的话，可以在函数中返回变化量
13、局部变量可以利用查询函数来代替。
14、switch 语句中尽量使用自己的数据。如果类A有变化的趋势，B类没有，就把B类放在A类中。减小变化类的影响范围
		switch 语句可以转换成多个类（子类），
```

# 四、思考

```
在把局部变量用查询函数表示的时候，如果涉及到循环操作，效率变成原来的2倍，怎么选择？
```

# 五、坏味道

## 1、重复代码

```
重复的代码是没有任何价值的
表现形式：
	类中的两个函数有着相同的表达式    ：提取表达式
	两个互为兄弟的子类中有着相同的表达式   ：提取公共的部分，推送给超类
	两个不相干类中有相同的表达式      将重复代码提取到一个新类中
很多时候不是完全相同的代码，就需要提取公共的逻辑
```

## 2、过长函数

```markdown
过长的函数不利于程序员理解
**函数应该简短，对象程序中存在的各种委托就是极简函数的例子**（一个函数基本就没做什么，都是通过调用其他函数来实现效果）
委托就是充分利用“间接层”
分解函数的原则：***在需要注解的才能描述清楚的地方，抽取函数。用描述函数的作用来命名***
在分解的时候可能会遇到很多个局部变脸导致函数的参数变多，如果一个参数能够通过另一个参数获取，就不需要额外传递。
如果不方面的话就用查询函数来替代这个变量
条件和循环是提炼的标志
```

## 3、过大的类

```
类中有太多的实例实例就会造成类的过于臃肿
可以将联系紧密的实例变量构成新的类。
如果类的实例变量有着相同的前缀或者后缀，就很适合抽取出来作为新的类
```

## 4、过长的参数列表

```
过长的参数列表是函数的调用成了问题，我们需要记住参数的名称，位置
超过四个参数就算过长
我们可以将这些参数抽象成对象，用于传参 Param
如果可以推倒出来就没有必要传递过去
```

## 5、发散式变化

```markdown
一个类或者受多种变化影响
类的功能应该是单一的，
***单一职责原则***
如果类受到多个变化的影响，就需要砍掉一些函数和实例变量
```

## 6、散弹式修改

```markdown
一个变化影响多处代码
如果需要修改的代码分散四周就很不容易找到，并且修改完全
可以将需要修改的代码放在一个类中，没有就创造一个
***单一职责原则***
```

## 7、依恋情结

```
函数对某个类的兴趣高于自己的类的兴趣
函数中为了获取某个值而调动另一个类中大量的方法。
解决方法：将这部分代码移到另一个类中
函数中用到多个类的方法，采用少数服从多数的方法
就是将一些变化的数据整理起来，整理到合适的地方
```

## 8、数据泥团

```
数据出现的时候会结伴出现，那就抽取成对象
如果删掉众多数据中的一项，那么这些数据就失去了意义，那就值的抽取成对象
```

## 9、基本类型偏执

```
就算类中只有一个参数也是有必要抽取成类的
```

## 10、switch

```
使用多态来替换switch
每一情况都可以抽取成函数
并且将状态码作为参数来使用工程模式来创建对象，并调用执行
状态模式
```

## 11、平行继承体系

```
为一个类添加子类的时候需要为另一个类同样添加子类
解决方案：让一个继承体系去依赖另一个继承体系的实例
```

## 12、冗赘类

```
去掉不会使用的类
合理的存在
```

## 13、夸夸其谈未来性

```
去除掉抽象类中没有必要的方法
```

## 14、令人迷惑的暂时字段

```
在类中存在一些字段，他们的用处只有在特殊情况下，那就离开这个类
```

## 15、过度耦合的消息链

```
在函数调用中存在一个函数调用另一个函数，另一个函数还在调用其他函数
分析最后的函数，是否可以整合
```

## 16、类之间过于狎昵

```
两个类经常使用对方的私有部分，就应该将两个类中公共的部分抽取出来。
封装不不需要过于暴露私有属性的
```

## 17、异曲同工的类

```
如果两个函数他们做的是相同的事，只是函数名不同，就需要整理函数
```

## 18、子类与父类

```
父子之间要保持严格的 is-a 关系
能不用继承的时候就使用依赖
```

## 19、过多的注解

```
注解是可以使用函数重构来避免的。
```



# 六、自动测试

```
可以考虑在编写代码初期
```

# 七、重构

```
函数的引用点要找全，不能只改一部分
```

## 1、Extract Method

```
将功能相同的代码抽取成函数，用函数名来解释函数的用途
抽取成函数后检查是否引用作用域限于原函数的变量，如果有考虑作为参数。

需要注意局部变量
	如果在提取代码之后，后面的代码对局部变量做了修改，建议函数返回这个局部变量，如果局部变量是对象就没有这种麻烦
	局部变量可以在函数内声明：代码块仅进行简单初始化
```



## 2、inline Method

```
使用函数本体，不在调用函数。
函数的名称和本体一样清晰易懂。
比如简单的布尔，判断语句

做法：
检查函数是否不具有多态性，具有就不要动，避免影响子类
找到这个函数的所有引用点
替换
测试
删除函数定义

如果函数中的局部变量与函数的关联性不是很强，但是函数中还是使用到了，就可以将参数的获取做成查询函数，之后在函数内调用查询函数，这样就避免了传参进来
```



## 3、inline Temp

```
局部变量仅被简单赋值一次，替换为表达式

做法：
检查给临时变量赋值语句，确保等号左右无副作用
声明为final（表明局部变量只需赋值一次）
替换表达式
测试
删除声明语句和赋值语句
```

## 4、Replace temp with Query

```
把表达式抽取成函数，之后这个临时变量调用的位置用这个函数来代替
把局部变量表达式转变成函数的时候，就对这个类公开（这样就不需要传参进来）

做法：
1、找的只被赋值一次的变量
2、声明为final变量
3、测试是否正确
4、将给变量赋值语句提取到右边
5、实施 inline temp
```

## 5、introduce Explaining variable

```
将复杂的表达式的中间过程放在一个局部变量
```

## 6、split temporary variable

```
对局部变量进行多次赋值的时候，针对每次赋值。创造一个独立、对应的临时变量
```

## 7、remove Assignment  to paramtes

```
不要对参数进行赋值，
```

## 8、replace method with method object

```
如果函数内局部变量过多，可以将这些变量组装对类
```

## 9、move method 

```
如果这个函数在这个类中不合适就迁移到其他类中，或者新建一个类
不合适表现为：这个函数中过多调用其他类的属性

在迁移之前需要检查这个函数的影响范围，被引用，被继承
检查要迁移的函数中有哪些是和本类关系密切的，就不要动
```

## 10、 move field

```
同 move method
```

## 11、 extracr class

```
将本类中的一些属性和方法提取到一个新的类
修改引用
```

## 12、inline class

```
如果一个类不在负责，就将类的属性和方法移到另一个类中
```

## 13、hide delegate

```
在服务器类上建立客户所需的所有函数，隐藏委托关系
```

<img src="/Users/mac/Pictures/截图/屏幕快照 2021-04-11 18.40.52.png" style="zoom:50%;" />

## 14、self Encapsulate Field

```
在类中通过访问函数来访问属性，属性最好设置为私有
便于子类使用父类的字段
在构造函数中尽量不要使用访问函数
```

