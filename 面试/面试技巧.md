# 个人介绍

面试官，你好，我是裴立志。我面试的是java工程师，我  精通的技能有springboot ，多线程， dubbo（为其他业务模块提供服务，同时也引用其他服务），

mysql、redis、elasticsearch、mongodb 数据库 并有数据库调优经验。（mysql 索引三个字段a,b,c 实际查询使用的是b,c，修改查询语句的。es调优：使用filter代替bool 查询，bool会计算分数，实际不需要只返回查询结构就可以啦。同时仅返回需要的字段） 

消息队列精通 rabbitmq ，

了解过分布式缓存，security安全框架



解决过 服务器内存压力告警，排除原因是慢sql 导致大量数据加载到内存中，解决方式是优化查询语句，增加更多的限制条件。

老年代不回收问题：排除原因是新生代太小，接口比较慢，很容易达到晋升到老年队。解决思路是jvm 堆内存由4G调大16G,并且统计出用时2s以上的慢接口，调节一个参数 ，每月分配随项目上线优化。

个人平时喜欢写文档，在学习一个新知识的时候，喜欢用笔记记录下来。

独立负责绩效模块（重点提示）。



‘

# 项目经验

项目描述：通过图表形式展示绩效的个人考核，指标考核，我的团队下成员绩效，绩效校准等级分布。
项目实现：elactricsearch+mysql 形式来存储数据，负责数据结构设计，数据查询优化，数据定期校准。
项目效果：查询通常在2s以内返回结果，无慢查询，内存问题。为什么必须使用es查询，

es 大数据查询比较快，因为倒排索引能直接根据字段去定为文件。有聚合

难点在于：es 与mysql 数据出现不一致的情况。导致的原因是多线程同时操作es的一个文档时导致冲突写失败。

问题原因是：e s采用_seq_no 和 `_primary_term`来实现乐关锁。更新前先查询文档这两个字段，更新操作时携带着两个字段，比较文档的最新值与请求中的是否一致，一致就更新，不一致就跑出异常

解决方式有两个：

1. 晚上空闲时定时将mysql数据同步到es中，根据表中有更新时间再今天内操作的mysql记录，再同步到es中，这个方案不好，因为mysql数据量太大了，并且有好多没必要处理的数据。
2. 在发生同步异常时，将错误的数据记录下来，发送到rabbitmq队列里面，由队列的消费者重新去更新es。 队列的先入先出就能保证一定顺序的。
3. 仍有极特殊情况，这种就是极少数客户反馈过来的，后台开发根据公司纠察接口，并且根据公司刷新es数据的接口
4. 后面思考： 1. 代码书写时尽量将查询es 与更新es的代码接近一点，避免竞争。





面试前几分钟要了解公司薪资，位置，



详细问题：

1. 公司的业务，后续开发做什么工作的，发展行情，技术栈
2. 薪资，加班情况，
3. 不需要关注北京、天津。工作地点都无所谓的







如果是具体问题的话，尽量使用流程图来回答。要有重试机制、错误机制、监控机制。不需要有具体实现的。

模版：针对这个问题，我想以流程图的形式展示。





接口幂等：

1. 提现时生成唯一的token， 返回给前端，前端请求时携带这个to ken， 检查是否有效果，有效就处理，处理完成失效token

2. 数据库唯一索引防重
3. 数据库乐观锁控制字段 （增加版本字段，符合版本才能操作）
4. 分布式锁防止并发 redis 
5. 事物与回滚机制， 插入和更新在一个事务里面
6. 结果缓存和快速响应，缓存这次操作的结果



分布式缓存：

采用redis 来做 ：

+ 无中心架构
+ 数据自动分片
+ 支持主从复制

解决关键问题：

1. 缓存穿透：查询不存在的数据，每次都查DB

   ```java
   @Service
   public class CachePenetrationSolve {
       
       @Autowired
       private RedisTemplate<String, Object> redisTemplate;
       
       public Object getData(String key) {
           // 1. 查缓存
           Object value = redisTemplate.opsForValue().get(key);
           
           if (value != null) {
               return value;
           }
           
           // 2. 使用布隆过滤器（快速判断key是否存在）
           if (!bloomFilter.mightContain(key)) {
               return null; // 一定不存在
           }
           
           // 3. 分布式锁，防止缓存击穿
           String lockKey = "lock:" + key;
           RLock lock = redissonClient.getLock(lockKey);
           
           try {
               if (lock.tryLock(3, 10, TimeUnit.SECONDS)) {
                   // 双重检查
                   value = redisTemplate.opsForValue().get(key);
                   if (value != null) {
                       return value;
                   }
                   
                   // 4. 查数据库
                   value = database.query(key);
                   
                   // 5. 写入缓存（即使是空值也缓存）
                   if (value == null) {
                       redisTemplate.opsForValue().set(key, "NULL", 5, TimeUnit.MINUTES);
                   } else {
                       redisTemplate.opsForValue().set(key, value, 30, TimeUnit.MINUTES);
                   }
                   
                   return value;
               }
           } finally {
               lock.unlock();
           }
           return null;
       }
   }
   ```

   2. 缓存击穿

      现象：热点key过期，高并发同时查DB

      ```java
      // 方案1：互斥锁（如上所示）
      
      // 方案2：热点key永不过期 + 后台更新
      @Component
      public class HotKeyManager {
          
          @PostConstruct
          public void initHotKeys() {
              // 启动时加载热点key
              List<String> hotKeys = loadHotKeysFromDB();
              
              for (String key : hotKeys) {
                  refreshHotKey(key);
              }
              
              // 定时刷新
              scheduledExecutor.scheduleAtFixedRate(() -> {
                  for (String key : hotKeys) {
                      refreshHotKey(key);
                  }
              }, 5, 5, TimeUnit.MINUTES);
          }
          
          private void refreshHotKey(String key) {
              // 更新缓存（不设置过期时间）
              Object value = database.query(key);
              redisTemplate.opsForValue().set("hot:" + key, value);
              
              // 在value中保存时间戳
              HotKeyWrapper wrapper = new HotKeyWrapper(value, System.currentTimeMillis());
              redisTemplate.opsForValue().set("hot:" + key, wrapper);
          }
      }
      ```

      3. 缓存雪崩

      **现象**：大量key同时过期，导致DB压力暴增

      ```java
      @Component
      public class CacheAvalancheSolve {
          
          // 1. 设置随机过期时间
          public void setWithRandomExpire(String key, Object value) {
              int baseExpire = 3600; // 1小时
              int randomExpire = new Random().nextInt(600); // 0-10分钟随机
              
              redisTemplate.opsForValue().set(
                  key, value, 
                  baseExpire + randomExpire, 
                  TimeUnit.SECONDS
              );
          }
          
          // 2. 二级缓存
          @Cacheable(value = "user", key = "#userId")
          public User getUser(String userId) {
              // 先从本地缓存查
              User user = localCache.get(userId);
              if (user != null) {
                  return user;
              }
              
              // 再从Redis查
              user = redisTemplate.opsForValue().get("user:" + userId);
              if (user != null) {
                  localCache.put(userId, user);
                  return user;
              }
              
              // 最后查DB
              user = userMapper.selectById(userId);
              redisTemplate.opsForValue().set("user:" + userId, user, 30, TimeUnit.MINUTES);
              return user;
          }
          
          // 3. 熔断降级
          @HystrixCommand(fallbackMethod = "getUserFallback")
          public User getUserWithHystrix(String userId) {
              // 正常逻辑
          }
          
          public User getUserFallback(String userId) {
              // 返回降级数据
              return new User(); // 空用户或默认值
          }
      }
      ```

      4. 数据一致性

      **现象**：DB和缓存数据不一致

      ```java
      @Service
      public class CacheConsistencyManager {
          
          // 方案1：先更新DB，后删缓存（推荐）
          @Transactional
          public void updateUser(User user) {
              // 1. 更新数据库
              userMapper.updateById(user);
              
              // 2. 删除缓存（事务提交后执行）
              TransactionSynchronizationManager.registerSynchronization(
                  new TransactionSynchronizationAdapter() {
                      @Override
                      public void afterCommit() {
                          redisTemplate.delete("user:" + user.getId());
                      }
                  }
              );
          }
          
          // 方案2：延迟双删
          public void updateUserWithDelayDelete(User user) {
              // 1. 先删缓存
              redisTemplate.delete("user:" + user.getId());
              
              // 2. 更新数据库
              userMapper.updateById(user);
              
              // 3. 延迟再删一次（处理并发读可能导致的脏数据）
              scheduledExecutor.schedule(() -> {
                  redisTemplate.delete("user:" + user.getId());
              }, 500, TimeUnit.MILLISECONDS);
          }
          
          // 方案3：使用Canal监听binlog
          @EventListener
          public void handleDatabaseChange(CanalEvent event) {
              // 收到binlog变更，删除对应缓存
              String tableName = event.getTable();
              String id = event.getData().get("id").toString();
              
              redisTemplate.delete(tableName + ":" + id);
          }
      }
      ```

      

      