# 消息实时通信

# 轮询

### 短轮询

指定时间间隔由浏览器向服务器发起HTTP请求。 （定时请求由服务器压力）

### 长轮询

```
Client ----请求----> Server
        <----挂起----
(有数据/超时)
        <----响应----
Client 再发请求
```



Spring MVC  DeferredResult

```java
@GetMapping("/poll")
public DeferredResult<String> poll() {
    DeferredResult<String> result = new DeferredResult<>(30000L);
    new Thread(() -> {
        try {
            Thread.sleep(10000);
            result.setResult("new message");
        } catch (Exception e) {
            result.setErrorResult("error");
        }
    }).start();

    return result;
}
# 缺点：仍配置线程池，高并发需要TaskExecutor
```

Spring webFlux

```java
@GetMapping(value = "/poll", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<String> poll() {
    return Flux.interval(Duration.ofSeconds(10))
               .map(seq -> "new message");
}

基于netty 非阻塞IO 
```



高并发场景下推荐使用 WebFlux 或 WebSocket。



实现websocket

webScoket是在TCP 连接上进行的全双工通信协议，浏览器与服务器仅需要一次握手，就能建立持久性连接

![image-20260227175540351](/Users/peilizhi/Library/Application Support/typora-user-images/image-20260227175540351.png)

```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new MyHandler(), "/ws")
                .setAllowedOrigins("*");
    }
}


import org.springframework.web.socket.*;
public class MyHandler implements WebSocketHandler {

    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        System.out.println("连接建立");
    }

    @Override
    public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {
        session.sendMessage(new TextMessage("服务器回复: " + message.getPayload()));
    }

    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) {
        exception.printStackTrace();
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) {
        System.out.println("连接关闭");
    }

    @Override
    public boolean supportsPartialMessages() {
        return false;
    }
}
```





# 正向、反向代理

正向代理就是代理客户端，反响代理就是代理服务器