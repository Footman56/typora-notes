union all 比 union 性能好，但是会有重复的

![image-20260228110349327](https://raw.githubusercontent.com/Footman56/images-2/master/img202602281103374.png)





深度分页怎么优化：

1. 按需查询字段，减少IO 消耗
2. 查询字段尽量保证索引覆盖，减少回表
3. 借助nodal缓存来 缓解mysql 数据库压力
4. 借助id 范围来优化



优先使用datetime 来保持日期和时间，存储范围大，并且和时区无关



mysql 选RR 隔离级别？

1. 主从复制时，通过binlog 日志来完成数据同步的， 从库执行sql的时候的结果会与主库有些区别（不同mysql的采样预估导致执行过程不一样）。可重复读的间隙锁和记录锁能避免事务乱序问题。

大厂改成RC

+ 实时性需求：RC 每次都是读最新的
+ 减少死锁：RR 会加间隙锁和记录锁
+ 简化主从复制 ，RC 使用行式binlog
+ 提高并发性能：RC锁的力度小



not in 问题

1. 索引失效
2. 不会返回null 的记录



自增健不连续

+ 插入时唯一建冲突，再次插入自增值会增加
+ 事务回滚时
+ 批量插入时 （如果批量插入5条， 新的自增值会变成8） 第一次插入时，分配1个；第二次插入时，分配2个；第三次插入时，分配4个







分裤分表下怎么实现精准分页

1. 获取足量的数据，在服务层排序分组

   1. 将order by time offset X limit Y	 改写成 order by time offset  limit  X+Y
   2. 各分库执行sql
   3. 服务层将得到的数据分库返回的数据
   4. 服务层对这些汇总的数据进行内存排序，排序后取偏移量X 后的Y记录。

   精准返回需要的数据； 分库返回更多的数据；服务层进行二次排序，增加服务层计算量；

2. 禁止跳页查询（只提供下一页功能）
   1. 将第一次查询之后返回了一个最大值   order by time where time >> $time_max limit 100
   2. 第二次查询的时候，分库基于这个最大值获取  分页数100
   3. 服务层内存排序返回符合条件的数据
3. 数据均衡原理 （不需要精确的数据）
   1. 使用partition key 进行分库