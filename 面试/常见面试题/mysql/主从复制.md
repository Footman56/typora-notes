一、配置两个数据源

```java
spring:
  datasource:
    master:
      url: jdbc:mysql://master:3306/test
      username: root
      password: 123456
    slave:
      url: jdbc:mysql://slave:3306/test
      username: root
      password: 123456
```

二、定义数据源枚举

```java
public enum DataSourceType {
    MASTER,
    SLAVE
}
```

三、使用 ThreadLocal 保存当前数据源

```java
public class DataSourceContextHolder {

    private static final ThreadLocal<DataSourceType> contextHolder = new ThreadLocal<>();

    public static void set(DataSourceType type) {
        contextHolder.set(type);
    }

    public static DataSourceType get() {
        return contextHolder.get();
    }

    public static void clear() {
        contextHolder.remove();
    }
}
```

四、实现动态数据源

```java
public class DynamicDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.get();
    }
}
```

五、AOP 控制读写

```java
@Aspect
@Component
public class DataSourceAspect {

    @Before("@annotation(ReadOnly)")
    public void setReadDataSource() {
        DataSourceContextHolder.set(DataSourceType.SLAVE);
    }

    @Before("@annotation(WriteOnly)")
    public void setWriteDataSource() {
        DataSourceContextHolder.set(DataSourceType.MASTER);
    }

		// 执行后是否ThreadLocal
    @After("@annotation(ReadOnly) || @annotation(WriteOnly)")
    public void clear() {
        DataSourceContextHolder.clear();
    }
}
```

注意点：

+ 事务内走主库 
+ 主从延迟 ：写后强制的读主库，判断有事务就走主库





**生产中最好使用ProxySQL**

解决：

+ 读写分离
+ 主库切换
  + Orchestrator 或 MGR 选出新主库
  + ProxySQL 自动更新主库节点
  + 应用无感知
+ 连接数过多
+ SQL 路由控制
  + 指定某个表只走主库
  + 分库分表支持
  + 指定某些用户走特定实例

Orchestrator 负责怎么选，ProxySQL 负责选完之后怎么连