倒排索引就是将这些词汇映射到包含这些词汇的文档列表中的。

# 倒排索引构成

1. 单词词典
   + 记录所有不重复的单词
   + 通常使用B+树或者哈希表来实现
   + 快速定位单词的倒排列表
2. 倒排列表
   + 记录包含改单词的所有文档ID
   + 包括词频、位置信息

# es 构建过程

## 步骤1：文本分析（Analysis）

```json
原始文档：{"title": "Elasticsearch is awesome"}

分词过程：
1. 字符过滤：去除HTML标签等
2. 分词器：分成单词
   → ["Elasticsearch", "is", "awesome"]
3. Token过滤：转小写、去除停用词
   → ["elasticsearch", "awesome"]
```

## 步骤2：建立索引

```json
文档1：elasticsearch, awesome
文档2：elasticsearch, java
文档3：awesome, programming

生成的倒排索引：
elasticsearch → [1,2]
awesome       → [1,3]
java          → [2]
programming   → [3]
```

## 步骤3：写入磁盘

+ 生成Segment文件
+ 包括倒排索引和存储字段



# 倒排索引结构优化

1. FOR 压缩

   ```java
   // 未压缩的文档ID列表
   [1, 3, 4, 7, 10, 1000, 1001, 1002]
   
   // 1. 先排序（已经是排序的）
   // 2. 计算差值（Delta Encoding）
   [1, 2, 1, 3, 3, 990, 1, 1]  // 相邻差值
   
   // 3. 按块压缩
   块1: [1,2,1,3,3] → 最大3，用2bit存储
   块2: [990,1,1]   → 最大990，用10bit存储
   
   // 节省大量空间
   ```

2.  Roaring Bitmaps（位图优化）
3. 跳表 

elastic search 使用倒排索引和正排索引：

倒排索引用于搜索。

正排索引用于排序和聚合

# es 查询为什么那么快？

1. 倒排索引  能直接找到关键词的页面 ，从O(n)降到O(1)

2. 不可变Segment + 缓存 ： 写入页面后不可变、热门segment常驻缓存、充分利用系统的Page Cache

3. 压缩算法 减少IO   FOR压缩、Roaring Bitmaps

4. 分布式并行查询

   ```java
   // 1. 协调节点接收请求
   // 2. 计算目标分片（默认所有分片）
   // 3. 并行发送请求到各分片
   // 4. 每个分片本地查询返回top N
   // 5. 协调节点归并排序
   ```

5. 字段数据缓存
   + 节点级别缓存：所有分片共享
   + LRU 淘汰： 最近最少使用
   + 内存优化，使用堆外内存
6. 跳表加速 ： 有跳表层
7. 索引分片与路由     // 指定routing值，直接定位分片

# es 数据多了怎么调优

1. 控制内存大小不能超过 32G(java 使用指针压缩技术，将64位压缩到32位)   保留 50%内存给文件系统缓存

2. 冷热分离 与分片策略   单个分片大小最好在 30～50GB. ILM 实现

   1. 给节点打角色标签
   2. 定义生命周期策略 （多少天为冷？多少天为热）

   本质：冷热分离 = 用 ILM 把不同时间段的索引迁移到不同性能节点，减少热节点的 shard 数量，从而提升查询性能并降低成本。

    业务搜索冷热不是由时间决定的

   1. 将索引拆成冷、热两个索引
   2. 应用层实现 不让冷数据参与搜索
      + redis 缓存热门结果
      + 热数据预计算
      + 冷数据 只在深度翻页时查询

   使用Rollover API ，当索引 Size > 50GB 或者Time > 7days 时自动滚动

   ```java
   Rollover 依赖一个 写别名（write alias）。
   1. 创建生命周期策略
   PUT _ilm/policy/my_policy
   {
     "policy": {
       "phases": {
         "hot": {
           "actions": {
             "rollover": {
               "max_size": "30gb",
               "max_age": "7d"
             }
           }
         }
       }
     }
   }
   
   2. 创建索引模板
   PUT _index_template/my_template
   {
     "index_patterns": ["my_index-*"],
     "template": {
       "settings": {
         "index.lifecycle.name": "my_policy",
         "index.lifecycle.rollover_alias": "my_index_write",
         "number_of_shards": 3
       }
     }
   }
   3.  创建第一个索引
   PUT my_index-000001
   {
     "aliases": {
       "my_index_write": {
         "is_write_index": true
       }
     }
   }
   4. 创建别名
   POST _aliases
   {
     "actions": [
       {
         "add": {
           "index": "my_index-*",
           "alias": "my_index_read"
         }
       }
     ]
   }
   5.查询
    GET my_index_read/_search
   {
     "query": {
       "match": {
         "name": "iphone"
       }
     }
   }
   ```

3. 海量写入 CPU 飙升

   + 使用Bulk API ，每次5～15MB
   + 将refresh_interval  调大到30s  (默认1s刷新生成新的segment)
   + 将Translog 设置为 Async   (默认同步落盘保证数据不丢)

4. 查询慢 

   + 禁止使用 From +size 深分野，使用Search After



# es 与mysql 对比

mysql 适合事务ACID , 精准查询，数据强一致性

es: 适合模糊搜索、全文搜索、海量数据分析、最终一致性



# 分片是什么？

分片的作用就是将大索引分出多份，散落在集群的多个节点上

数据时通过 ： hash(_id) % shard_cout 

+ 主分片：负责增、删、改  必须在主分片上完成，创建索引时指定主分片的数量，并且不能修改
+ 副本分片： 主分片的完整拷贝
  + 高可用：主分片挂后，自动晋升主分片
  + 读写分离

```json
PUT product_index
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1
  }
}

PUT product_index/_settings
{
  "number_of_replicas": 2
}
```

# 保证查询性能

```
1.索引设计：选择合适的分片数量和副本数量，以平衡查询性能和数据冗余需求。使用适当的字段类型和映射设置，减少存储空间和提高查询效率。
2.查询优化：编写高效的查询语句，避免使用复杂的正则表达式、通配符查询等。使用过滤器查询
（filter query）替代普通查询（bool query），可以显著提高性能。将查询结果限制为必要的字段，避免返回
不必要的数据。
3.优化Elasticsearch的内存管理：合理设置Elasticsearch的内存阈值，以确保查询过程中不会出现内存溢出或性能下降问题。
4. 定期合并段（merge segments）来减少磁盘碎片和优化索引性能。
5. 使用高效的数据结构和算法：利用Elasticsearch提供的各种数据结构和算法，如桶（bucket）、聚合（aggregation）、排序（sort）等，来提高查询效率。
6. 优化网络连接和通信：确保服务器硬件和网络性能足够好，以减少搜索响应时间。合理设置网络连接的超时时间，避免长时间等待导致查询超时。
7.监控和优化Elasticsearch的性能指标：通过监控系统跟踪集群的健康状况和性能指标，如查询响应时间、CPU使用率、内存占用率等。根据监控数据调整Elasticsearch的配置参数，以优化查询性能。
```

# 高并发下保证数据安全与稳定性

```java
1. 备份和恢复策略：定期备份数据，并制定恢复策略，以防止数据丢失或损坏。
2.分散负载：通过合理分配索引和分片，避免所有请求都指向同一个节点。
3. 使用复制分片：将数据复制到多个分片中，以提高数据的可靠性和可用性。
4.监控和警报：通过监控系统跟踪集群的健康状况和性能指标，设置警报阈值，及时发现并解决问题。
5. 使用安全认证：确保只有授权的用户可以访问Elasticsearch集群，防止未经授权的访问和恶意攻击。
6.限制单个用户的查询请求：设置每个用户的查询请求限制，以防止过高的并发请求导致系统崩溃。
7. 使用负载均衡：通过负载均衡器将请求分散到多个Elasticsearch集群中，以平衡负载和提高系统的稳定性。
8.优化硬件和网络配置：确保服务器硬件和网络性能足够好，以减少搜索响应时间，并提高系统的稳定性和可用性。
9.使用持久化存储：将数据存储在可靠的持久化存储中，以防止数据丢失或损坏。
10. 定期更新和修补：及时更新Elasticsearch版本，修补漏洞和修复已知问题，以提高系统的安全性和稳定性。
```

# es性能优化

```
1.防止脑裂：设置discovery.zen.minimum_master_nodes参数，确保选举出的Master节点的稳定性。
2.设置memory_lock：将JVM的物理内存地址锁定，防止操作系统进行交换出去，提高查询速度。
3. 设置分片数：根据实际情况设置分片数，避免过少或过多的分片导致检索速度慢。
4.优化Translog：通过"translog.sync_interval"和"translog.durability"等参数进行优化。
5. 使用node、master、client、data等角色分离：将不同的角色分离到不同的节点上，提高系统的稳定性和性能。
6.优化索引映射：选择合适的字段类型和映射设置，减少存储空间和提高查询效率。
7. 使用高效的数据结构和算法：利用Elasticsearch提供的各种数据结构和算法，提高查询效率。
8.优化网络连接和通信：确保服务器硬件和网络性能足够好，减少搜索响应时间。
9. 定期合并段 （merge segments）：减少磁盘碎片和优化索引性能。
10. 监控和优化Elasticsearch的性能指标：通过监控系统跟踪集群的健康状况和性能指标，根据监控数据调整配置参数，优化查询性能。
```

#  深翻页问题

1. 数据比较少(100条)  使用from + size  
2. 数据量大需要深度翻页  使用scroll 翻页
3. 数据量大需要深度翻页 又有实时高并发， 使用Search + after
   + 需要有稳定的排序
   + 不能跳页，只能顺序翻页
   + 

```
# 一次查询
GET products/_search
{
  "size": 10,
  "query": { "match_all": {} },
  "sort": [
    { "price": "asc" },
    { "_id": "asc" }
  ]
}

# 返回结果，sort 字段会附带在每条记录上
{
  "hits": {
    "hits": [
      { "_id": "1", "sort": [100, "1"], ... },
      { "_id": "2", "sort": [100, "2"], ... },
      ...
    ]
  }
}
# 第二次查询
GET products/_search
{
  "size": 10,
  "query": { "match_all": {} },
  "sort": [
    { "price": "asc" },
    { "_id": "asc" }
  ],
  "search_after": [150, "10"]
}
```

# es 搜索过程

```
在ElasticSearch集群中搜索数据的过程可以分为以下几个步骤：
1.接受请求：ElasticSearch集群中的任何节点都可以接受用户的搜索请求。一旦接收到请求，该节点会将其转发给协调节点（coordinating node）。
2.路由与寻址：协调节点接收到请求后，根据请求中的路由信息，将请求转发给相应的主分片或副本分片。每个分片都会独立地执行搜索并生成一个优先队列。
3. 分片选择和请求转发：每个分片在本地执行搜索并构建一个大小为from+size的优先队列。优先队列中包含了查询结果按照排序值的顺序排列的文档。同时，协调节点也会将该请求转发给相关的副本分片，并合并它们的结果到自己的优先队列中。
4.执行搜索计划：一旦所有的分片都完成了搜索并生成了优先队列，协调节点会将所有优先队列合并为一个全局排序后的结果列表。
5.搜索的后处理：协调节点会对全局排序后的结果列表进行处理，例如进行结果合并、处理搜索结果、返回查询结果等。
6.返回结果：一旦所有的搜索和后处理都完成了，协调节点会将最终的结果返回给客户端。
```

