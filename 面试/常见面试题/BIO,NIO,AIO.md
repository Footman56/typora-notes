### 总结对比表

| 特性         | BIO （同步阻塞） | NIO （同步非阻塞）                    | AIO （异步非阻塞）           |
| :----------- | :--------------- | :------------------------------------ | :--------------------------- |
| **I/O 模型** | 同步阻塞         | 同步非阻塞 （多路复用）               | 异步非阻塞                   |
| **线程模型** | 一连接一线程     | 一请求一线程 （少量线程处理大量连接） | 回调/通知 （不占用应用线程） |
| **数据读取** | 线程等数据       | 数据就绪 -> 线程读数据                | 数据读完 -> 通知线程处理     |
| **复杂度**   | 简单             | 复杂 （需处理粘包、轮询）             | 复杂 （回调、Future）        |
| **并发能力** | 极差             | 高                                    | 高                           |
| **底层原理** | 传统 Socket      | 多路复用器 （Selector/Epoll）         | 事件回调 （如 Windows IOCP） |
| **适用场景** | 连接少、固定架构 | 高并发、连接数多 （主流）             | 任务重、操作系统支持好的场景 |

BIO：**同步阻塞**：线程发起 I/O 请求后，一直等待数据，直到数据拷贝完成。

NIO:**同步非阻塞**：线程发起读请求后，不会一直等着，而是立即返回，可以去干别的事。但它需要主动（或通过 Selector）检查数据是否就绪。注意：这里的"非阻塞"指的是**线程不会阻塞在等待数据上**，但数据从内核空间拷贝到用户空间的过程依然是同步的。

AIO: **异步非阻塞**：线程发起 I/O 请求后，根本不用管，操作系统帮你读完数据放到指定位置，然后发个信号通知你"数据好了，你来用吧"。 异步回调方式

