树

# 普通树

每个节点有多个子节点



# 二叉树

每个节点最多两个子节点

![image-20260228101937387](/Users/peilizhi/Library/Application Support/typora-user-images/image-20260228101937387.png)

# 二叉搜索树

左子树 <  根 <  右子树

# AVL  树 （平衡树）

+ 左右子树高度差 <= 1
+ 查找/删除/插入 时间复杂度 O(logn)。

# 红黑树

红黑树：

+ 每个节点要么是红色、要么黑色
+ 根节点是黑色
+ 叶子节点是黑色
+ 红色节点不能连续
+ 任意节点到每个叶子路径上的黑节点数相同
+ 近似平衡： 最长路径< 2* 最短路径

ConcurrentHashMap、TreeMap 、TreeSet、HashMap 树化后都是红黑树 

优点是：工程更加稳定、插入删除、高效、大量插入删除场景更优

# B树

+ 多路平衡树
+ 节点可以存放多个key
+ 所有叶子节点同层
+ 适合磁盘IO
+ 时间复杂度为 log(n)

# B+树

+ 所有数据都在叶子节点
+ 叶子节点形成链表（双链表）
+ 非叶子节点只存索引

![image-20260228103813085](https://raw.githubusercontent.com/Footman56/images-2/master/img202602281038135.png)

索引下推

在存储引擎层 就提前过滤数据，减少回表次数

```
# 没有ICP
索引扫描 → 回表 → 判断 city → 丢弃

# ICP
索引扫描 → 判断 city → 满足才回表
```

什么使用生效？

+ 使用的是二级索引
+ where 条件中的字段都在索引中
+ 不是主键索引
+ 不是覆盖索引查询 （查询所需要的所有字段，都能从索引中获取，不需要回表）