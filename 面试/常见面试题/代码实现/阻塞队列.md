```java

/**
 *
 *@author peilizhi
 *@date 2026/2/27 13:32
 **/
public class MyBlockingQueue<T> {

    private Queue<T> queue = new LinkedList<>();
    private int capacity;

    private ReentrantLock lock = new ReentrantLock();
    private Condition notFull = lock.newCondition();
    private Condition notEmpty = lock.newCondition();


    public MyBlockingQueue(int capacity) {
        this.capacity = capacity;
    }

    /**
     * 生产者只唤醒消费者
     * @param element
     * @throws InterruptedException
     */
    public void put(T element) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                // 等待队列不满的消息
                notFull.await();
            }

            queue.offer(element);

            // 通知等待的消费者线程，队列不空了
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }


    /**
     * 消费者只唤醒生产者
     * @return
     * @throws InterruptedException
     */
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                notEmpty.await();
            }

            T item = queue.poll();
            notFull.signal();
            return item;
        } finally {
            lock.unlock();
        }
    }
```





# ArrayBlockingQueue 原理

```
1. 基于数组实现的有界阻塞队列
2. 使用 ReentrantLock 保证线程安全
3. 使用两个 Condition 控制队列满/空
4. 使用循环数组实现 FIFO
5. 单锁结构，并发度一般
6. 可选公平锁 (先进先出，吞吐不高， 非公平锁：抢占式)
```

```
优点:
数组结构内存连续
无额外节点对象
GC 压力小

缺点:
容量固定
单锁并发度一般
扩容困难
```



线程池常用LinkedBlockingQueue？

+ 双锁并发高
+ 默认无界
+ 适合任务队列

ArrayBlockingQueue 会不会死锁？

+ 所有操作用同一个锁

+ 严格条件控制
+ 不存在嵌套锁

线程池工作队列常见选择：

| 场景     | 推荐                |
| -------- | ------------------- |
| 高吞吐   | LinkedBlockingQueue |
| 内存敏感 | ArrayBlockingQueue  |
| 直接交付 | SynchronousQueue    |