```java

/**
 *
 *@author peilizhi
 *@date 2026/2/27 13:32
 **/
public class MyBlockingQueue<T> {

    private Queue<T> queue = new LinkedList<>();
    private int capacity;

    private ReentrantLock lock = new ReentrantLock();
    private Condition notFull = lock.newCondition();
    private Condition notEmpty = lock.newCondition();


    public MyBlockingQueue(int capacity) {
        this.capacity = capacity;
    }

    /**
     * 生产者只唤醒消费者
     * @param element
     * @throws InterruptedException
     */
    public void put(T element) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                // 等待队列不满的消息
                notFull.await();
            }

            queue.offer(element);

            // 通知等待的消费者线程，队列不空了
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }


    /**
     * 消费者只唤醒生产者
     * @return
     * @throws InterruptedException
     */
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                notEmpty.await();
            }

            T item = queue.poll();
            notFull.signal();
            return item;
        } finally {
            lock.unlock();
        }
    }
```





# ArrayBlockingQueue 原理

```
1. 基于数组实现的有界阻塞队列
2. 使用 ReentrantLock 保证线程安全
3. 使用两个 Condition 控制队列满/空
4. 使用循环数组实现 FIFO
5. 单锁结构，并发度一般
6. 可选公平锁 (先进先出，吞吐不高， 非公平锁：抢占式)
```

## 缺点

