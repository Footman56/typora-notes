

分布式缓存：

采用redis 来做 ：

+ 无中心架构
+ 数据自动分片
+ 支持主从复制

解决关键问题：

1. 缓存穿透：查询不存在的数据，每次都查DB

   ```java
   @Service
   public class CachePenetrationSolve {
       
       @Autowired
       private RedisTemplate<String, Object> redisTemplate;
       
       public Object getData(String key) {
           // 1. 查缓存
           Object value = redisTemplate.opsForValue().get(key);
           
           if (value != null) {
               return value;
           }
           
           // 2. 使用布隆过滤器（快速判断key是否存在）
           if (!bloomFilter.mightContain(key)) {
               return null; // 一定不存在
           }
           
           // 3. 分布式锁，防止缓存击穿
           String lockKey = "lock:" + key;
           RLock lock = redissonClient.getLock(lockKey);
           
           try {
               if (lock.tryLock(3, 10, TimeUnit.SECONDS)) {
                   // 双重检查
                   value = redisTemplate.opsForValue().get(key);
                   if (value != null) {
                       return value;
                   }
                   
                   // 4. 查数据库
                   value = database.query(key);
                   
                   // 5. 写入缓存（即使是空值也缓存）
                   if (value == null) {
                       redisTemplate.opsForValue().set(key, "NULL", 5, TimeUnit.MINUTES);
                   } else {
                       redisTemplate.opsForValue().set(key, value, 30, TimeUnit.MINUTES);
                   }
                   
                   return value;
               }
           } finally {
               lock.unlock();
           }
           return null;
       }
   }
   ```

   2. 缓存击穿

      现象：热点key过期，高并发同时查DB

      ```java
      // 方案1：互斥锁（如上所示）
      
      // 方案2：热点key永不过期 + 后台更新
      @Component
      public class HotKeyManager {
          
          @PostConstruct
          public void initHotKeys() {
              // 启动时加载热点key
              List<String> hotKeys = loadHotKeysFromDB();
              
              for (String key : hotKeys) {
                  refreshHotKey(key);
              }
              
              // 定时刷新
              scheduledExecutor.scheduleAtFixedRate(() -> {
                  for (String key : hotKeys) {
                      refreshHotKey(key);
                  }
              }, 5, 5, TimeUnit.MINUTES);
          }
          
          private void refreshHotKey(String key) {
              // 更新缓存（不设置过期时间）
              Object value = database.query(key);
              redisTemplate.opsForValue().set("hot:" + key, value);
              
              // 在value中保存时间戳
              HotKeyWrapper wrapper = new HotKeyWrapper(value, System.currentTimeMillis());
              redisTemplate.opsForValue().set("hot:" + key, wrapper);
          }
      }
      ```

      3. 缓存雪崩

      **现象**：大量key同时过期，导致DB压力暴增

      ```java
      @Component
      public class CacheAvalancheSolve {
          
          // 1. 设置随机过期时间
          public void setWithRandomExpire(String key, Object value) {
              int baseExpire = 3600; // 1小时
              int randomExpire = new Random().nextInt(600); // 0-10分钟随机
              
              redisTemplate.opsForValue().set(
                  key, value, 
                  baseExpire + randomExpire, 
                  TimeUnit.SECONDS
              );
          }
          
          // 2. 二级缓存
          @Cacheable(value = "user", key = "#userId")
          public User getUser(String userId) {
              // 先从本地缓存查
              User user = localCache.get(userId);
              if (user != null) {
                  return user;
              }
              
              // 再从Redis查
              user = redisTemplate.opsForValue().get("user:" + userId);
              if (user != null) {
                  localCache.put(userId, user);
                  return user;
              }
              
              // 最后查DB
              user = userMapper.selectById(userId);
              redisTemplate.opsForValue().set("user:" + userId, user, 30, TimeUnit.MINUTES);
              return user;
          }
          
          // 3. 熔断降级
          @HystrixCommand(fallbackMethod = "getUserFallback")
          public User getUserWithHystrix(String userId) {
              // 正常逻辑
          }
          
          public User getUserFallback(String userId) {
              // 返回降级数据
              return new User(); // 空用户或默认值
          }
      }
      ```

      4. 数据一致性

      **现象**：DB和缓存数据不一致

      ```java
      @Service
      public class CacheConsistencyManager {
          
          // 方案1：先更新DB，后删缓存（推荐）
          @Transactional
          public void updateUser(User user) {
              // 1. 更新数据库
              userMapper.updateById(user);
              
              // 2. 删除缓存（事务提交后执行）
              TransactionSynchronizationManager.registerSynchronization(
                  new TransactionSynchronizationAdapter() {
                      @Override
                      public void afterCommit() {
                          redisTemplate.delete("user:" + user.getId());
                      }
                  }
              );
          }
          
          // 方案2：延迟双删
          public void updateUserWithDelayDelete(User user) {
              // 1. 先删缓存
              redisTemplate.delete("user:" + user.getId());
              
              // 2. 更新数据库
              userMapper.updateById(user);
              
              // 3. 延迟再删一次（处理并发读可能导致的脏数据）
              scheduledExecutor.schedule(() -> {
                  redisTemplate.delete("user:" + user.getId());
              }, 500, TimeUnit.MILLISECONDS);
          }
          
          // 方案3：使用Canal监听binlog
          @EventListener
          public void handleDatabaseChange(CanalEvent event) {
              // 收到binlog变更，删除对应缓存
              String tableName = event.getTable();
              String id = event.getData().get("id").toString();
              
              redisTemplate.delete(tableName + ":" + id);
          }
      }
      ```

      

