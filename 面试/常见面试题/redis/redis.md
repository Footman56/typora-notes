# 缓存穿透

缓存穿透是值 查询一个根本不存在的数据，数据不存在的话，redis里面没有，就直接查数据库。

1. 布隆过滤器 ： 快速判断key 是否存在 (有一定的误判)

   1. 位数组 ，多个哈希函数

   ```
   m = 10000 位数组
   k = 3 个 hash 函数
   
   插入元素 "abc"：
   h1("abc") → 位置 5
   h2("abc") → 位置 200
   h3("abc") → 位置 888
   把这三个位置置为 1
   
   查询元素:查 "abc"：
   只要有一个位置为 0 → 一定不存在
   全部为 1 → 可能存在
   ```

2. 将这个不存在的值存下来，value 为null ，设置的TTL 时间短 300秒

3. 如果key 是连续的整数的话，可以使用Roaing Bitmap 来判断

   1. 分段：将32位整数拆成两部分，高16位为“桶索引”, 低16位 为 “桶内数据”
   2. 自适应
      + 桶内数据少时 ，使用Array COntainer  
      + 数据多时，使用Bitmap Container 

4. 数据需要频繁增删，布谷鸟过滤器

   ```
   1.计算两个候选桶位置
   2.若有空位 → 插入
   3.若都满 → 随机踢出一个元素
   4.被踢出的元素换到它的另一个桶
   5.可能形成“踢来踢去”
   ```

5. 立体防御
   1. 网关层：在nginx 网关层拦截恶意ip
   2. 应用层： 判断key不符合规则
   3. 数据层：缓存空对象或者过滤器

# 缓存击穿

单个热点key 过期，恰逢高并发过来，请求会访问数据库

1. 互斥锁 :  保证只有一个线程取查库

   ```java
   public Object getData（String key）｛
   // 1. 查询缓存
   Object value = redis.get （key）；
   if （value ！= nulL） return value；
   1/ 2. 缓存未命中，尝试获取互斥锁
   // SETNX key "1"EX 10（设置过期时间防止死锁）
   if（redis.tryLock（lockKey））｛
   try｛
   // Double Check：再次查询缓存，防止重复查库
   value = redis.get（key）；
   if （value ！= null） return value：
   // 3. 查询数据库
   value = db.query（key）；
   // 4. 回写缓存
   redis.set （key, value）；
   ｝ finally｛
   // 5.释放锁
   redis.unlock（ LockKey）；
   ｝
   ｝ else｛
   // 6.获取锁失败，休眠后重试
   Thread.sleep（50）；
   return getData（key）：
   ｝
   return
   value；
   ```

2.  逻辑过期 （key 永不过期，value 中存在过期时间戳，后台线程异步重建）



# 缓存雪崩

大面积key 同一时刻失败或者缓存宕机 ，大量请求涌入数据库

1. TTL 随机化， 在基础时间上加一个随机值
1. 多级缓存   本地缓存+分布式缓存
1. 使用互斥锁：保证一个线程查询数据库
2. 架构层面： 主从复制，集群来增加缓存的可用性
   1. Redis  Sentinel (哨兵) ：监控主节点状态，自动完成故障转移
   2. Redis Cluster (集群)： 通过分片存储数据，不至于全盘皆输





# redis 持久化

## RDB: 内存快照

默认开启为RDB持久化

在指定时间间隔内将内存中的数据写入到磁盘。

1. fork 子进程备份
2. 将共享内存数据写入临时RDB文件（COW 写时复制）
3. 完成临时写入，替换旧的RDB 文件，退出

### 触发时机

1. 自动触发

   ```
   save 900 1
   save 300 10
   save 60 10000
   
   900秒内有1次修改
   300秒内有10次修改
   60秒内有10000次修改就生成一次快照。
   ```

2. 手动触发

   ```
   SAVE  # 同步阻塞
   BGSAVE ¥ 异步阻塞
   ```

3. shutdown 触发  
4. flushall 触发

优点：

文件小、恢复快、适合做冷备份、性能影响小

缺点：

不是实时持久化、两次快照之间数据会丢

## 增量日志（AOF）

把每条写命令追加到AOF缓冲区中，根据同步策略写到AOF文件，当AOF文件达到重写策略配置的阈值时，会重写，AOF瘦身, redis 重启时 重新执行AOF 文件里面命令   bgrewirteao可以重写AOF文件

默认不开启  appendonly yes

### 刷盘策略

```
# 每次命令都fsync 最安全、性能最差
appendfsync always  

# 每秒fsync 一次 平衡 最多丢1秒数据(默认)
appendfsync everysec

# 交给os 决定，丢很多数据，性能最好
appendfsync no
```

### 文件碰涨

重写是对AOF重复性指令的整理。

 auto-aof-rewrite-percentage 100：当AOF文件体积达到上次重写之后的体积的100%时，会
触发AOF重写。
• auto-aof-rewrite-min-size 64mb：当AOF文件体积超过这个阈值时，会触发AOF重写。
当AOF文件的体积达到或超过上次重写之后的比例，并且超过了最小体积阈值时，Redis会自动触
发AOF重写新的AOF文件  
优点： 数据更加可靠、可以保留写命令历史

缺点：文件比较大、恢复速度慢

## 混合持久

redis 4.0 支持混合持久化 ，默认开启

# 过期策略

## 惰性删除

当客户尝试访问某个健时，Redis 会先检查是否过期，过期就删除。

## 定期删除

Redis 每隔一段时间（100毫米） 随机检查一部分过期时间的健，会随机从16个库中 抽取一定数量的key进行判断是否过期. 当抽查的缓存中,超过25%的key过期,那么会再次抽查,直到小于25%

同时采用定期删除和惰性删除。  还是会有大量的内存中key是已经失效的，导致内存溢出问题，解决方式引入淘汰机制

# 内存淘汰机制

## 不淘汰策略（默认的）

新写入的命令返回错误，写操作失败

## alleys-lru(全局最近最少使用)

从所有键中最久未被访问的键进行删除。无论键是否设置了过期时间，都将参与淘汰。

缓存系统使用

## volatile-lru (最近最少使用)

优先删除最久未被访问的键，保留常用的键

根据带有过期时间的缓存

## allkeys-lfu(全局访问频率最低的)

## volatile-flu(过期时间访问频率最低的)

## volatile-random

从过期时间中随机删除一个键

## allkeys-random（全局随机删除）

从所有键中随机选择一个键进行删除。

## volatile-tel( 根据过期时间优先)

优先删除剩余时间较短的键，保留剩余时间更长的



# 哨兵机制

Redis的主从复制主要用于实现数据的冗余备份和读分担，并不是为了提供高可用性。因此在系统高可用方面。

问题：

+ 需要人工介入：需要人工介入进行主节点切换。当主节点发生故障时，主从复制无法自动进行主节点的切
  换。需要管理员手动干预，修改配置将一个从节点提升为新的主节点。这增加了人工操作的复杂性和潜在的
  延迟。
+ 主节点写能力有限：主节点的写能力受限于单个节点。在主从复制中，所有写操作都必须发送给主节点处
  理，然后再同步到从节点。这导致主节点成为写入瓶颈，其写能力受限于单个节点的硬件和性能。如果负载
  过大，主节点的响应时间可能会增加，影响整体性能。
+ 单机节点存储能力有限：存储能力受限于主节点的容量。在主从复制中，所有数据都存储在主节点上，从节
  点仅用于提供读服务。这限制了整个系统的存储能力，因为主节点的存储容量有限。如果数据量增长过快或
  存储需求增加，主节点的存储容量可能会成为瓶颈。

1. 选取哨兵的领导者
2. 监控主节点、从节点
3. 故障转移（领导者处理） 必须是客观下线（过半哨兵节点认为不可用）
   1. 发送心跳Ping 来确认master 是否存活，不存活就是不可用
   2. 确认主节点
      1. 过滤不健康的从节点
      2. 选择从节点优先级最高的
      3. 选择复制偏移量最大的
4. 客户端重定向 通知客户端更新主节点



# 解决mysql 与缓存不一致问题

## 延迟双删

1. 先删除redis 
2. 再更新数据库
3. 延迟几百毫米在删除redis  

## 队列+重试机制

• 更新数据库数据；
• 缓存因为种种问题删除失败
• 将需要删除的key发送至消息队列
• 自己消费消息，获得需要删除的key
• 继续重试删除操作，直到成功

## 异步更新缓存（订阅binlog的同步机制）

<img src="https://raw.githubusercontent.com/Footman56/images-2/master/img202603011102030.png" alt="img" style="zoom:50%;" />

实际中通过Canal框架，模拟从库的备份请求来更新redis

#  分布式锁

## SETNX+ EXPIRE

setnx+ expire命令。即先用setnx来抢锁，如果抢到之后，再用expire给锁设置一个过期时间，防止锁忘记了释放。

缺陷：非原子操作，加锁后系统异常，没有及时设置过期时间，其他线程永远获取不到锁

## SETNX + value  (系统时间+过期时间)

```java
ong expires = System.currentTimeMillis（） + expireTime; //系统时间+设置的过期时间
String expiresStr = String.valueof （expires）；
// 如果当前锁不存在，返回加锁成功
if （jedis.setnx（key_resource_id, expiresStr） == 1）｛
return true；
// 如果锁已经存在，获取锁的过期时间
String currentValuestr = jedis.get（key_resource_id）；
// 如果获取到的过期时间，小于系统当前时间，表示已经过期
if （currentValuestr ！= null && Long.parseLong（currentValuestr） < System.currentTimeMillis（））｛
// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间
String oldValuestr = jedis.getSet （key_resource_id, expiresStr）；
if （oldValueStr ！= null && oldValueStr.equals（currentValueStr））｛
// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁
return true；
｝
//其他情况，均返回加锁失败
return false；
```

## SET KEY value Ex  PX NX XX  设置value时同步设置超时时间

锁过期释放啦，但是业务没执行完

锁被别的线程误删



## Redisson框架

看门狗机制，后台线程每隔10秒检查一下是否还持有锁，如果持有就延长时间

## 多机实现的分布式锁RedLock + Redisson

用于解决分布式环境中多个客户端对同一共享资源并发访问时一致性和可靠性问题。通过多个独立的redis 节点协作

使用单节点redis 有个问题：

```
1. 在 Master 上加锁成功
2. 锁还没同步到 Slave
3. Master 挂了
4. Slave 升级为新 Master
5. 锁丢失
```

1. 获取当前时间
2. 尝试加锁：依次向 5 个 Redis 实例加锁   必须设置唯一的UUID，使用相同的key 和唯一的随机value,并且每个锁的有效期一致
3. 每个实例设置锁时要有很短的超时时间   
4. 统计成功次数  成功数 >= 3（超过半数）&& 总耗时 < 锁有效时间 就是加锁成功
5. 加锁成功后，这把锁的有效期都是最开始设置的有效期
6.  否则就释放所有已加的锁



redLock 优点：

+ 避免单点故障
+ 不依赖主从复制
+ 提升安全性

不适合强一致性： 网络延迟、时钟依赖

## 大厂使用zookeeper 

redis  是基于过期时间的锁  、zookeeper 是基于共识协议的锁

zookeeper 是基于 Zab协议，多数派提交、强一致日志复制

加锁流程

1. 创建临时顺序节点
2. 所有节点按编号排序
3. 最小编号获取锁
4. 释放锁删除节点
5. 下一个自动监听触发



## redis 事务

1. 以multi 开启事务
2. 多个命令进入到队列里面
3. exec 命令触发事务

有事务中的某个命令失败时，继续执行其他命令，不会会滚。

乐观锁：通过watch 监控一个或者多个健，如果在exec执行前有改变的话，事务将不会执行



redis 主节点挂掉会导致超卖

redis 默认异步主从同步，主节点挂掉，但是数据没有异步同步到从节点，新的主节点里面没有数据就可以导致超卖

解决方案：

+ redlock 算法

+ 原子操作或者lua 脚本保证 扣减的原子性

+ 乐关锁：尽在数据未修改时执行扣减，否则重试

  

redis 为什么那么快？

+ 数据都存在内存里面

+ 单线程模型： 单线程处理请求

+ 高效的数据结构

+ IO多路复用 ： 能够同时处理大量连接并且使用reator模型，能够并发的处理连接以及对连接进行响应，但是内部命令执行还是单线程的 （一个线程同时监听多个socket ，谁有数据谁处理）

  ```
  EPOLL:
  1. 把所有 socket 注册到内核
  2. 内核帮你监听
  3. 某个 socket 有数据
  4. 内核通知你
  5. 你去处理
  ```

  

  redis 6 之前都是单线程模型

  网络IO多线程，异步持久化、惰性删除





# redis 作用

+ 缓存 

+ 分布式会话管理

+ 实时排行榜/计数器 （跳跃表：查询排序效率极高）

+ 消息队列 发布/订阅模型

+ 限流与速率控制

  







# 发布/订阅模型

+ 发布者： 发送消息
+ 频道： 消息通道
+ 订阅者： 接受消息

内部维护订阅列表， 当执行PUBliSh channel message ,找到该 channel 对应的订阅者,遍历列表,直接把消息推送给每个客户端

简单、实时、低延迟。 不持久化、客户端端线消息丢失

适合场景是：

+ 实时通知
+ 配置更新广播
+ 简单聊天室
+ 分布式事件通知
