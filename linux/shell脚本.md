# 什么是shell

shell 是用户与Linux 内核之间的接口程序，你在提示符下输入的每个命令都由shell先解释然后传给Linux内核。shell 是一个命令语言解释器（command-language interpreter）。拥有自己内建的 shell 命令集。此外，shell也能被系统中其他有效的Linux 实用程序和应用程序（utilities and application programs）所调用。

 不论何时你键入一个命令，它都被Linux shell所解释。一些命令，比如打印当前工作目录命令（pwd），是包含在Linux bash内部的（就象DOS的内部命令）。其他命令，比如拷贝命令（cp）和移动命令（rm），是存在于文件系统中某个目录下的单独的程序。



shell 首先检查命令是否是内部命令，不是的话再检查是否是一个应用程序，这里的应用程序可以是Linux本身的实用程序，比如ls 和 rm，也可以是购买的商业程序，比如 微信，或者是公用软件（public domain software），就象 ghostview。然后shell试着在搜索路径($PATH)里寻找这些应用程序。搜索路径是一个能找到可执行程序的目录列表。如果你键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。而如果命令被成功的找到的话，shell的内部命令或应用程序将被分解为系统调用并传给Linux内核。

# shell 如何启动

 shell在你成功地登录进入系统后启动，并始终作为你与系统内核的交互手段直至你退出系统。你系统上的每位用户都有一个缺省的shell。每个用户的缺省shell在系统里的passwd文件里被指定，该文件的路径是/etc/passwd。passwd文件里还包含有其他东西：每个人的用户ID号，一个口令加密后的拷贝和用户登录后立即执行的程序，（注：为了加强安全性，现在的系统一般都把加密的口令放在另一个文件--shadow中，而passwd中存放口令的部分以一个x字符代替）虽然没有严格规定这个程序必须是某个Linux shell，但大多数情况下都如此。



# 常用的shell 

1、**Bourne shell (sh)** 它是 UNIX 最初使用的shell 并且在每种 UNIX 上都可以使用。Bourne shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面作得不如其他几种 shell。

2、**C shell (csh)** 它更多的考虑了用户界面的友好性。它支持象命令补齐（command-line completion）等一些 Bourne shell 所不支持的特性。普遍认为C shell 的编程接口做的不如 Bourne shell

3、**Korn shell (ksh)**  它集合了C shell 和 Bourne shell 的优点并且和 Bourne shell 完全兼容。

**bash（Bourne Again shell ） 是大多数Linux 系统的缺省 shell。**

# 通配符

\*   匹配任何字符和任何数目的字符

?   匹配任何单字符

[...] 匹配任何包含在括号里的单字符

# 别名

bash 的另一个使你的工作变得轻松的方法是命令别名。命令别名通常是其他命令的缩写，用来减少键盘输入

例：

 alias ll='ls -l'

# 输出重定向

默认情况下 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。

**输出重定向就是将命令的输出到另一个位置，不是默认的终端**

| 命令            | 说明                                               |
| :-------------- | :------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

***需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。***



# 输入重定向

**输入重定向就是从另一个位置获取命令，不是默认的终端**

# WC

统计文件的单词数、字符数、行数

# 管道

管道可以把一系列命令连接起来。这意味着第一个命令的输出会通过管道传给第二个命令而作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，以此类推。而管道行中最后一个命令的输出才会显示在屏幕上



export 显示所有环境变量

`echo $VARIABLE_NAME`. 获取某一变量详情

whereis 使用系统自动构建的数据库来搜索可执行文件，源文件和手册页面。

which 它在环境变量PATH指定的目录中搜索可执行文件。此命令将打印可执行文件的完整路径。

# 十、shell

```
1、在文件开头写 #!/bin/bash
2、写指令
3、赋予文件执行权限
4、 ./XXX.sh 执行
```

## 1、变量

````shell
变量分为系统变量和自定义变量
$变量名 输出变量
变量=值  定义变量

等号两边不能有空格

将执行结果赋值给变量
A=`ls -l /home/huochai`
A=$(ls -l /home/huochai)

:<<!
多行注释
!

在 /etc/profile
export 变量=值 (将变量输出为环境变量)
source /etc/profile

位置参数变量
用于从命令行获取参数
$n n为数字 ，$0代表命令本身 $1-$9 表示第几个参数  ${10}第10个参数
$* 命令行中的所有参数，看做一个整体
$@ 命令行中的所有参数,区别对待
$# 命令行参数的个数

预定义变量
	$$ 当前进程的进程号PID
	$! 后台运行的最后一个进程号
	$? 最后一次执行命令的返回状态 0正常执行 

运算符
$[运算式]
$((运算式))
expr m - n   expr运算式之间要有空格

条件判断
[ condition ]       condition 前后要有空格
[]  返回false


两个整数比较
	= 字符串比价
	-lt 小于
	-le 小于等于
	-eq 等于
	-gt 大于
	-ge 大于等于
	-ne 不等于
按照文件权限进行判断
	-r 读的权限
	-w  写的权限
	-x 执行的权限
	
按照文件类型进行判断
 -f 文件存在并且是一个常规的文件
 -e 文件存在
 -d  文件存在并且是一个目录

if [ "ok" = "ok" ]
then
        echo "相等"
fi


流程判断
形式一：
if [ condition ];
	then  程序
fi

形式二：
if [ condition ]
	then 程序
elif [ condition ]
	then 程序
fi


case $变量名 in
“值1”)
	程序1
;;
“值2”）
	程序2
;;

..........
*)
 未匹配的程序
;;
esac
 
 
 #!/bin/bash
case $1 in
1)
        echo "周一"
;;
2)
        echo "周二"
;;
*)
        echo "other"
;;
esac




for循环

for 变量 in 值1 值2 值3 ...
do 
	程序
done
"$*" 将参数作为整体（一个值）
"$@" 将参数划分开（多个值）
注：二者不在参数的时候输出结果是一样的


for((初始值;循环控制条件;变量变化))
do
	程序
done 


while [ 条件表达式 ]
	do
	 程序
	done 
	
i=0
sum=0
while   [ $i -lt $1 ]
do
        sum=$[$sum+$i]
        i=$[$i+1]
done
echo "while sum is $sum"
要使用$ 进行取值


read [选项] 参数
	-p 指定读取值时的提示符
	-t 指定取值时的等待时间
````









