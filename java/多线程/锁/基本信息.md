# 锁

## 3.1 乐观锁

乐观锁认为读多写少，在读的时候不会上锁，在写的时候先判断当前版本号，然后上锁（如果本次版本号与上次一致，就上锁更新），如果不一致的话，就要**重复**  ***读-比较- 写***，采用CAS 操作。属于更新的原子性操作。核心就是先比较，没有变化就可以写，有变化就重复读。

## 3.2 悲观锁

悲观锁认为读写比较多，并发性高，每次读、写的时候都要上锁。别的获取的时候就会Block ,直到释放锁字段。java 悲观锁是synchronized（），AQS框架中是先获取CAS乐观锁，获取不到才转换为悲观锁。

## 3.3 自旋锁

如果持有锁的线程能够在短时间内释放锁资源，那么其他竞争锁资源的线程就不需要进行内核态到用户态的切换，只需等一等，就可以获取释放的锁资源。

自旋的时候是占用CPU的，如果在最大自旋时间之内，仍然没有获取锁，就停止自旋，进入阻塞状态。

自适应自旋锁：自旋时间不是固定的，而且由前一次在获取同一个锁上的时间和锁的状态决定的。默认是一个线程上下文切换时间为最佳时间。Jdk 1.7之后，由JVm 控制 -xx+UseSpinning 开启自旋锁。