# 一、线程创建

```java
/**
 * 继承Thread 类
 * @author peilizhi
 * @date 2022/3/14 23:52
 **/
public class MyThread extends Thread{

    /**
     * 重写run 方法，线程的执行体
     */
    @Override
    public void run() {
        super.run();
        System.out.println("true = " + true);
    }

    public static void main(String[] args) {
        final MyThread myThread = new MyThread();
        // 调用线程
        myThread.start();
    }
}


/**
 * 实现Runnable 接口
 *
 * @author peilizhi
 * @date 2022/3/14 23:54
 **/
public class MyThread2 implements Runnable {
    /**
     * 重写run 方法
     */
    @Override
    public void run() {
        System.out.println("true = " + true);
    }

    public static void main(String[] args) {
        // 构造Thread 实例
        Thread myThread = new Thread(new MyThread2());
        // 调用Thread.start() 方法
        myThread.start();
    }
}


/**
 * 实现Callable 需要指定返回类型
 *
 * @author peilizhi
 * @date 2022/3/15 00:09
 **/
public class MyThread3 implements Callable<String> {
    private final int num;

    public MyThread3(int num) {
        this.num = num;
    }

    /**
     * 实现带有返回值的方法
     */
    @Override
    public String call() throws Exception {
        return num + "";
    }

    public static void main(String[] args) {

        // 创建线程池
        ExecutorService executorService = Executors.newFixedThreadPool(12);
        List<Future<String>> result = new ArrayList<>();
        for (int i = 0; i < 12; i++) {
            // 执行线程并返回结果
            Future<String> submit = executorService.submit(new MyThread3(i));
            result.add(submit);
        }
      
      // 关闭线程池
        executorService.shutdown();
        // 输出结果
        result.forEach(stringFuture -> {
            try {
                System.out.println("stringFuture = " + stringFuture.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        });
    }
}
```

# 二、 线程状态

Thread 对象中状态枚举

| 状态 | NEW                        | RUNABLE                                  | BLOCKED                          | WAITING                                          | TIMED_WAITING                                        | TERMINATED                             |
| ---- | -------------------------- | ---------------------------------------- | -------------------------------- | ------------------------------------------------ | ---------------------------------------------------- | -------------------------------------- |
| 描述 | 尚未启动的线程的线程状态。 | 在 Java 虚拟机中执行的线程处于这种状态。 | 阻塞等待监视器锁的线程处于此状态 | 无限期等待另一个线程执行特定操作的线程处于此状态 | 等待另一个线程执行操作达指定等待时间的线程处于此状态 | 已终止线程的线程状态。线程已完成执行。 |

线程死亡情况：

+ 程序正常结束
+ 程序异常退出
+ 线程的stop()方法

<img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220315003744249.png" alt="image-20220315003744249" style="zoom:50%;" />

volatile:声明的对象在多个线程中，同一时刻只有一个线程可以修改

Interrupt()

+ 线程处于阻塞状态：sleep,同步锁的wait ，调用线程的Interrupt() 会抛出InterruptException,，可以捕获此异常来break 循环
+ 线程处于未阻塞状态，Interrupt()将阻塞设置为true,

Sleep 与wait 区别

+ Sleep() 属于Thread方法，wait 属于ob jest 方法
+ Sleep 让程序暂停执行指定时间，让出cpu, 他的监控状态仍保存，待指定时间后，自动恢复到运行状态，不会释放对象锁
+ Wait 放弃对象锁，进入对象的等待队列中，直到其他线程调用统一对象的nofity（）方法，进入对象的锁定池，等待获取锁对象



# 三、线程中断

线程中断其实就是给线程设置一个标志位。标志线程可以被终止不需要执行。想要生效的话，需要在线程执行方法里面明确判断是否被中断，否则就会正常执行，不会被中断。

```java
public class MyThread extends Thread{

    /**
     * 重写run 方法，线程的执行体
     */
    @Override
    public void run() {
        super.run();
        while (true){
            System.out.println("true = " + true);
            if (Thread.interrupted()){
                System.out.println("线程被中断");
                break;
            }

        }
    }
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        // 调用线程
        myThread.start();
        Thread.sleep(1000);
        myThread.interrupt();

    }
}
```

在没加入Thread.interrupted()判断时，线程执行方法没有判断线程是否被终止，会一直执行

加入Thread.interrupted()判断时，如果外界条件改变线程状态之后，会根据状态适时终止。



## interrupt

中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。

如果此线程在调用Object类的wait() 、 wait(long)或wait(long, int)方法或join() 、 join(long) 、 join(long, int) int) 、 sleep(long) , or sleep(long, int) , 时被外界设置为中断的话，那么**它的中断状态将被清除**（重新为false），**会抛出一个InterruptedException** 。

## isInterrupted

测试此线程是否已被中断。线程的中断状态不受此方法的影响。

## interrupted

测试当前线程是否被中断。通过该方法清除线程的中断状态

第一次执行时，可以被终止，状态设置为true;

第二次执行时，不可以被终止，状态设置为false

```java
public class MyThread extends Thread {

    /**
     * 重写run 方法，线程的执行体
     */
    @Override
    public void run() {
        super.run();
        while (true) {
            System.out.println("true = " + true);
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("线程被中断了");
                break;
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("e = " + e);
                // 因为在sleep的时候被外界终止，线程已经被设置为未终止的状态
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("线程被中断了");
                }
                // interrupted
                Thread.interrupted();
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("interrupted后线程被中断了");
                }
                this.interrupt();
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("this.interrupt后线程被中断了");
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        // 调用线程
        myThread.start();
        Thread.sleep(2000);
        myThread.interrupt();

    }
}
输出：
true = true
true = true
e = java.lang.InterruptedException: sleep interrupted
this.interrupt后线程被中断了
true = true
线程被中断了
```

