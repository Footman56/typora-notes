```
代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。
并不是访问当前对象，而是通过一个新的代理对象来实现功能
```

分为：静态代理、动态代理、CGLib代理

# 静态代理

采用硬编码的形式来实现的，代理类与被代理类实现相同的接口，被代理的类作为代理类的一个字段，外部调用代理类的接口， 接口实现时可以在被代理类方法前后做增强

```
这种代理方式需要代理对象和目标对象实现一样的接口。

优点：可以在不修改目标对象的前提下扩展目标对象的功能。

缺点：

冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。
不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。
```

```java
/**
 * @Author peilizhi
 * @Date 2021/9/7 20:55
 **/
public interface UserDao {
    void save();
}


/**
 * @Author peilizhi
 * @Date 2021/9/7 20:56
 **/
public class UserDaoImpl implements UserDao {
    @Override
    public void save() {
        System.out.println("true = " + true);
    }
}


/**
 * @Author peilizhi
 * @Date 2021/9/7 20:55
 * 代理类
 **/
public class UserDaoProxy implements UserDao {

    /**
     * 待实现的对象
     */
    private UserDao userDao;


    public UserDaoProxy(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void save() {
        System.out.println("userDao.start");
        userDao.save();
        System.out.println("userDao.end");
    }
}

测试方法
public static void main(String[] args) {
        // 目标对象
        final UserDao userDao = new UserDaoImpl();
        // 代理对象
        UserDaoProxy proxy=new UserDaoProxy(userDao);
        proxy.save();
        System.out.println("proxy = " + proxy);
    }
```

# JDK原生代理

```
动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中
```

**动态代理对象不需要实现接口，但是要求目标对象必须实现接口**

**对代理对象的所有接口方法调用都会转发到`InvocationHandler.invoke()`方法**，在`invoke()`方法里我们可以加入任何逻辑

代理对象的类型是`jdkproxy.$Proxy0`，这是个动态生成的类型，类名是形如$ProxyN的形式；

父类是`java.lang.reflect.Proxy`，所有的JDK动态代理都会继承这个类；

同时实现了`Hello`接口，也就是我们接口列表中指定的那些接口。

```java
jdk 中主要实现
  
static Object    newProxyInstance(ClassLoader loader,  //指定当前目标对象使用类加载器
 Class<?>[] interfaces,    //目标对象实现的接口的类型
 InvocationHandler h      //事件处理器
) 
//返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。
  
  
  Object    invoke(Object proxy, Method method, Object[] args) 
// 在代理实例上处理方法调用并返回结果。
```

```java
/**
 * @Author peilizhi
 * @Date 2021/9/7 22:21
 * 接口,被代理类必须实现
 **/
public interface UserDao {
    void save();
    void happy();
}


/**
 * @Author peilizhi
 * @Date 2021/9/7 22:21
 * 被代理类
 **/
public class UserDaoImpl implements UserDao {

    @Override
    public void save() {
        System.out.println("true = " + true);
    }

    @Override
    public void happy() {
        System.out.println("i am happy");
    }

}




/**
 * @Author peilizhi
 * @Date 2021/9/7 22:22
 * 代理类
 **/
public class ProxyFactory {
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    /**
     * 获取代理类
     * @return
     */
    public Object getProxyInstance(){
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("前置操作");

                // 执行目标方法
                // final Object invoke = method.invoke(target, args);  可注释掉
                System.out.println("后置操作");
                
                // 其返回值无意义
                return invoke;
            }
        });
    }
}



/**
 * @Author peilizhi
 * @Date 2021/9/7 22:37
 **/
public class Main {
    public static void main(String[] args) {
        UserDao userDao=new UserDaoImpl();
        final ProxyFactory proxyFactory = new ProxyFactory(userDao);

        /**
         * 因为在创建代理类时指定类实现的接口列表
         */
        final UserDao proxyInstance = (UserDao) proxyFactory.getProxyInstance();

      // 调用InvocationHandler#invoke()
        proxyInstance.happy();

        proxyInstance.save();
        
    }
}
```

```java
// JDK代理类具体实现
public final class $Proxy0 extends Proxy implements UserDao
{
  ...
  public $Proxy0(InvocationHandler invocationhandler)
  {
    super(invocationhandler);
  }
  ...
  @Override
  public final void happy(){
    ...
    return super.h.invoke(this, m3, new Object[] );// 将方法调用转发给invocationhandler
    ...
  }
  ...
}
```

# CGLib代理

[CGLIB](https://github.com/cglib/cglib)(*Code Generation Library*)是一个基于[ASM](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。【继承被代理的对象】

**使用CGLib代理的类不能是final修饰的；final修饰的方法不会被切入；如果主题类的构造函数不是默认空参数的，那么在使用Enhancer类create的时候，选择create(java.lang.Class[] argumentTypes, java.lang.Object[] arguments) 方法。**

```
1、引入jar 
	<!--cglib-->
        <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.2.5</version>
        </dependency>
2、实现一个MethodInterceptor
3、 使用工具类创建对象
```

```java
// 待实现的拦截接口
public interface MethodInterceptor
extends Callback
{
    /**
     * All generated proxied methods call this method instead of the original method.
     * The original method may either be invoked by normal reflection using the Method object,
     * or by using the MethodProxy (faster).
     * @param obj "this", the enhanced object
     * @param method intercepted Method
     * @param args argument array; primitive types are wrapped
     * @param proxy used to invoke super (non-intercepted method); may be called
     * as many times as needed
     * @throws Throwable any exception may be thrown; if so, super method will not be invoked
     * @return any value compatible with the signature of the proxied method. Method returning void will ignore this value.
     * @see MethodProxy
     */    
    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,
                               MethodProxy proxy) throws Throwable;

}

```



```java
/**
 * @Author peilizhi
 * @Date 2021/9/8 00:31
 * 非 final 类
 **/
public class Hello {
    void sayHello() {
        System.out.println("hello");
    }
}


/**
 * @Author peilizhi
 * @Date 2021/9/8 00:32
 * 代理类
 **/
public class ProxyFactory implements MethodInterceptor {

    /**
     * 目标对象
     */
    private Object target;


    public ProxyFactory(Object target) {
        this.target = target;
    }

    //为目标对象生成代理对象
    public Object getProxyInstance() {
        //工具类
        Enhancer en = new Enhancer();
        //设置父类
        en.setSuperclass(target.getClass());
        //设置回调函数
        en.setCallback(this);
        //创建子类对象代理
        return en.create();
    }
    
    /**
     * 所有被代理的对象执行方法时会调用此方法
     * @param o 增强对象
     * @param method 方法
     * @param objects 参数
     * @param methodProxy
     * @return
     * @throws Throwable
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("前置操作");
        // 要调用父类的方法，不能调用自身的方法，否则会造成死循环
        methodProxy.invokeSuper(o, objects);
        System.out.println("后置操作");
        return null;
    }
}



/**
 * @Author peilizhi
 * @Date 2021/9/8 00:36
 **/
public class Main {
    public static void main(String[] args) {
        final Hello hello = new Hello();
        final ProxyFactory proxyFactory = new ProxyFactory(hello);


        final Hello proxyInstance = (Hello) proxyFactory.getProxyInstance();
        proxyInstance.sayHello();
    }
}

```

我们通过CGLIB的`Enhancer`来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用`create()`方法得到代理对象

对于从Object中继承的方法，CGLIB代理也会进行代理，如`hashCode()`、`equals()`、`toString()`等，但是`getClass()`、`wait()`等方法不会，因为它是final方法

**可以控制回调函数来对方法进行不同程度的增强**

```java
多回调
    // MethodInterceptor 实现一
    DBQueryProxy dbQueryProxy = new DBQueryProxy();
  // MethodInterceptor 实现二
  DBQueryProxy2 dbQueryProxy2 = new DBQueryProxy2();

  // 创建对象
  Enhancer enhancer = new Enhancer();
  // 设置父类
  enhancer.setSuperclass(DBQuery.class);
  // 配置切入方法
  enhancer.setCallbacks(new Callback[]{dbQueryProxy, dbQueryProxy2});
  // 根据函数名称选择切入方法 返回实现类的下标
  enhancer.setCallbackFilter(new CallbackFilter() {

    public int accept(Method method) {
      if (method.getName().equals("getElement")) {
        return 0;
      } else {
        return 1;
      }
    }
  });
  DBQuery dbQuery = (DBQuery) enhancer.create();
  // 执行实现一的拦截方法
  System.out.println(dbQuery.getElement("Hello"));
  // 执行实现二的拦截方法
  System.out.println(dbQuery.getAllElements());
```

``` java
不处理
  // MethodInterceptor 实现一
  DBQueryProxy dbQueryProxy = new DBQueryProxy();
	// MethodInterceptor 实现二
  DBQueryProxy2 dbQueryProxy2 = new DBQueryProxy2();
  // 不处理
  Callback noopCb = NoOp.INSTANCE;


  Enhancer enhancer = new Enhancer();
  enhancer.setSuperclass(DBQuery.class);
  enhancer.setCallbacks(new Callback[]{dbQueryProxy, dbQueryProxy2, noopCb});
  enhancer.setCallbackFilter(new CallbackFilter() {

    public int accept(Method method) {
      if (method.getName().equals("getElement")) {
        return 0;
      } else if (method.getName().equals("getAllElements")) {
        return 1;
      } else {
        return 2;
      }
    }
  });
  DBQuery dbQuery = (DBQuery) enhancer.create();
// 执行实现一的拦截方法
  System.out.println(dbQuery.getElement("Hello"));

// 执行实现二的拦截方法
  System.out.println(dbQuery.getAllElements());

// 不执行拦截方法
  System.out.println(dbQuery.methodForNoop());

```







