

#  前言

```
Java执行GC判断对象是否存活有两种方式其中一种是引用计数。
引用计数：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。

在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。
```





# 强引用

```java
通过new 创建的对象就是强引用，如果一个对象具有强引用，那垃圾回收器绝不会回收它。 宁可抛出OutOfMemoryError
Object strongReference = new Object();


如果强引用对象不使用时，需要弱化从而使GC能够回收。
strongReference = null;

显示地设置strongReference对象为null，或让其超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于GC算法。
```

在一个**方法的内部**有一个**强引用**，这个引用保存在`Java`**栈**中，而真正的引用内容(`Object`)保存在`Java`**堆**中。 当这个**方法运行完成**后，就会退出**方法栈**，则引用对象的**引用数**为`0`，这个对象会被回收。

但是如果这个`strongReference`是**全局变量**时，就需要在不用这个对象时赋值为`null`，因为**强引用**不会被垃圾回收。

# 软引用

用于描述 有用但是非必须的

```
如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

在报OutOfMemoryError异常之前，已经回收过软引用
如果对象有仅一个软引用，在垃圾回收的时候就被回收的
```

**软引用可用来实现内存敏感的高速缓存。**

```java
public class GCTarget {

    /**
     * 对象的ID
     */
    public String id;

    /**
     * 占用内存空间
     */
    byte[] buffer = new byte[1024];

    public GCTarget(String id) {
        this.id = id;
    }

    @Override
    protected void finalize() throws Throwable {
        // 执行垃圾回收时打印显示对象ID
        System.out.println("Finalizing GCTarget, id is : " + id);
    }

}


/**
         * 定义引用队列,
         * 建立软引用的时候可以指定，在被回收之后将软引用加入到队列中
         */
        ReferenceQueue<String> referenceQueue = new ReferenceQueue<>();
        String str = new String("abc");
        java.lang.ref.SoftReference<String> softReference = new java.lang.ref.SoftReference<>(str, referenceQueue);

        str = null;
        // Notify GC 具体什么时候回收根据回收算法
        System.gc();
        // abc
        System.out.println(softReference.get());

        
        Reference<? extends String> reference = referenceQueue.poll();
        //null，此时软引用还没有被回收
        System.out.println(reference);
```

# 弱引用

```
在垃圾回收的时候，如果发现有弱引用，立马回收


productA = new Product(...);
WeakReference<Product> weakProductA = new WeakReference<>(productA);
当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。 
```

**Java类库为我们提供了WeakHashMap类，使用和这个类，它的键自然就是弱引用对象**

```java
/**
     * 弱引用队列
     * 存放弱引用的类型
     */
    private final static ReferenceQueue<GCTarget> REFERENCE_QUEUE = new ReferenceQueue<>();

    public static void main(String[] args) {
        LinkedList<GCTargetWeakReference> gcTargetList = new LinkedList<>();

        List<GCTarget> targetList = new ArrayList<>();

        // 创建弱引用的对象，依次加入链表中
        for (int i = 0; i < 5; i++) {
            GCTarget gcTarget = new GCTarget(String.valueOf(i));
            // 创建弱引用
            GCTargetWeakReference weakReference = new GCTargetWeakReference(gcTarget,
                    REFERENCE_QUEUE);
            gcTargetList.add(weakReference);
            // 在list中存在gcTarget 的引用,变成了强引用
            targetList.add(gcTarget);

            System.out.println("Just created GCTargetWeakReference obj: " +
                    gcTargetList.getLast());
        }

        // 通知GC进行垃圾回收
        System.gc();

        try {
            // 休息几分钟，等待上面的垃圾回收线程运行完成
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 检查关联的引用队列是否为空
        Reference<? extends GCTarget> reference;
        while ((reference = REFERENCE_QUEUE.poll()) != null) {
            if (reference instanceof GCTargetWeakReference) {
                System.out.println("In queue, id is: " +
                        ((GCTargetWeakReference) (reference)).id);
            }
        }

        // 查看list

        System.out.println(JsonUtil.toJson(targetList));
    }
```

# 虚引用

```
虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

String str = new String("abc");
    ReferenceQueue queue = new ReferenceQueue();
    // 创建虚引用，要求必须与一个引用队列关联
    PhantomReference pr = new PhantomReference(str, queue);
```

**程序可以通过判断引用**队列**中是否已经加入了**虚引用**，来了解被引用的对象是否将要进行**垃圾回收**。**



总结一下

<table>
<thead>
<tr>
<th>引用类型</th>
<th>被垃圾回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>1.GCRoots 不可达 2.发成GC</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td>软引用</td>
<td>当内存不足时</td>
<td>对象缓存</td>
<td>内存不足时终止</td>
</tr>
<tr>
<td>弱引用</td>
<td>正常垃圾回收时</td>
<td>WeakHashMap、ThreadLocal。用于解决某些场景下的内存泄漏问题（如 ThreadLocal 的 Entry 中的 key 就是弱引用）</td>
<td>垃圾回收后终止</td>
</tr>
<tr>
<td>虚引用</td>
<td>正常垃圾回收时</td>
<td>跟踪对象的垃圾回收</td>
<td>垃圾回收后终止</td>
</tr>
</tbody>
</table>

