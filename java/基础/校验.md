**校验的原理就是添加注解，之后使用反射来获取对象的属性，之后书写校验属性的逻辑**

**在返回错误信息的时候，通常可以在注解中定义异常信息，或者在注解参数中设置模板，将注解中的另一个属性填充过来。**

```java
package com.qjyd.appraisal.validate;


import com.qjyd.appraisal.annotation.validator.DateValidator;
import com.qjyd.appraisal.annotation.validator.DoubleRangeValidator;
import com.qjyd.appraisal.annotation.validator.EnumValidator;
import com.qjyd.appraisal.annotation.validator.FixedLengthValidator;
import com.qjyd.appraisal.annotation.validator.IdcodeValidator;
import com.qjyd.appraisal.annotation.validator.IntegerRangeValidator;
import com.qjyd.appraisal.annotation.validator.LengthValidator;
import com.qjyd.appraisal.annotation.validator.MobileValidator;
import com.qjyd.appraisal.annotation.validator.RegexValidator;
import com.qjyd.appraisal.annotation.validator.RequiredValidator;
import com.qjyd.appraisal.annotation.validator.SkipOnEmpty;
import com.qjyd.appraisal.common.helper.ValidatorHelper;
import com.qjyd.appraisal.util.DateUtil;
import com.qjyd.appraisal.util.IDcodeUtil;
import com.qjyd.xrxs.appraisal.constants.AppraisalErrorCodeConstant;
import com.xrxs.base.client.exception.FieldNotValidException;
import com.xrxs.base.client.exception.UserException;
import com.xrxs.base.client.exception.XrxsException;

import org.apache.commons.lang3.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

/**
 * @author wangzhuo
 * @date 16/10/21
 */
public abstract class BaseValidator<T> {

    private static final Logger LOGGER = LoggerFactory.getLogger(BaseValidator.class);

    protected FieldNotValidException error;

    // 待校验的参数
    protected T data;

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    /**
     * 具体验证方法实现
     */
    public abstract boolean validate();


    /**
     * 验证 数据字段上  注解代表的规则是否通过
     *
     * @return errorMap
     */
    protected Map<String, String> validateByAnnotion() {
        HashMap<String, String> errorMap = new HashMap<>(8);
        Field[] fields = data.getClass().getDeclaredFields();
        // 合并父类的字段
        fields = ArrayUtils.addAll(fields, data.getClass().getSuperclass().getDeclaredFields());
        try {
            for (Field field : fields) {
                // 对每个字段进行校验，异常的数据保存在Map中
                validateField(data, field, errorMap);
            }
        } catch (IllegalAccessException e) {
            throw new XrxsException(AppraisalErrorCodeConstant.FIELD_NOT_VALID, "字段验证失败:" + e.getMessage());
        }
        return errorMap;
    }

    private static boolean checkLen(String data, int min, int max) {
        return data.length() >= min && data.length() <= max;
    }

    private static boolean checkPattern(String data, String pattern) {
        return data.matches(pattern);
    }

    private static boolean checkRequired(Object data) {
        if (data == null) {
            return false;
        }

        if (data.getClass().isArray()) {
            return Array.getLength(data) > 0;
        }
        if (data instanceof Collection<?>) {
            return ((Collection) data).size() > 0;
        }
        return data.toString().length() > 0;
    }

    private static boolean checkCandidates(Object data, int[] candidates) {
        try {
            int item = Integer.parseInt(data.toString());
            return ArrayUtils.contains(candidates, item);
        } catch (NumberFormatException e) {
            return false;
        }

    }


    public XrxsException getError() {
        return this.error;
    }

    /**
     * 校验字段错误信息
     *
     * @param field    字段反射引用field
     * @param errorMap 错误信息map
     */
    public static void validateField(Object obj, Field field, HashMap<String, String> errorMap) throws IllegalAccessException {
        field.setAccessible(true);
        Object item = field.get(obj);

        // 先验证是否必填
        RequiredValidator requiredValidator = field.getAnnotation(RequiredValidator.class);
        if (requiredValidator != null) {
            String label = requiredValidator.label();
            if (!checkRequired(item)) {
                String message = requiredValidator.message().replace("{label}", label);
                errorMap.put(field.getName(), message);
                LOGGER.info("验证必填失败");
            }
        }

        // 默认为空值时不验证 当skipOnEmpty声明为false则强制验证
        SkipOnEmpty skipOnEmpty = field.getAnnotation(SkipOnEmpty.class);
        // 空数值 或者 空字符串
        if (item == null ||
                (item instanceof String && "".equals(item))) {
            if (skipOnEmpty == null || skipOnEmpty.value()) {
                return;
            }
        }

        assert item != null;
        //正则
        RegexValidator regexValidator = field.getAnnotation(RegexValidator.class);
        if (regexValidator != null) {
            String pattern = regexValidator.pattern();
            String label = regexValidator.label();
            if (!checkPattern(item.toString(), pattern)) {
                String message = regexValidator.message().replace("{label}", label);
                LOGGER.info("正则验证失败");
                errorMap.put(field.getName(), message);
            }
        }

        //长度
        LengthValidator lengthValidator = field.getAnnotation(LengthValidator.class);
        if (lengthValidator != null) {
            int min = lengthValidator.min();
            if (min < 0) {
                min = 0;
            }
            int max = lengthValidator.max();
            String label = lengthValidator.label();
            if (!checkLen(item.toString(), min, max)) {
                String message = lengthValidator.message().replace("{label}", label)
                        .replace("{min}", String.valueOf(min)).replace("{max}", max + "");
                LOGGER.info("长度验证失败");
                errorMap.put(field.getName(), message);
            }
        }

        //固定长度
        FixedLengthValidator fixedLengthValidator = field.getAnnotation(FixedLengthValidator.class);
        if (fixedLengthValidator != null) {
            int[] candidate = fixedLengthValidator.validLength();
            String label = fixedLengthValidator.label();
            HashSet<Integer> candidateMap = new HashSet<>();
            for (int i : candidate) {
                candidateMap.add(i);
            }
            if (candidateMap.size() > 0 && !candidateMap.contains(item.toString().length())) {
                String message = fixedLengthValidator.message().replace("{label}", label);
                LOGGER.info("固定长度验证失败");
                errorMap.put(field.getName(), message);
            }
        }

        //日期
        DateValidator dateValidator = field.getAnnotation(DateValidator.class);
        if (dateValidator != null) {

            String label = dateValidator.label();
            String format = dateValidator.format();
            if ("all".equals(format)) {
                try {
                    DateUtil.getDateValueFromString(item.toString());
                } catch (UserException e) {
                    String message = dateValidator.message().replace("{label}", label);
                    LOGGER.info("日期验证失败");
                    errorMap.put(field.getName(), message);
                }
                //单独分支处理batchEmployeeCareerModel
            } else if ("batch".equals(format)) {
                try {
                    DateUtil.getBatchTimeFromRegexStr(item.toString());
                } catch (UserException e) {
                    String message = dateValidator.message().replace("{label}", label);
                    LOGGER.info("batch时间验证失败");
                    errorMap.put(field.getName(), message);
                }
            } else {
                Date date1 = DateUtil.transferStringtoDate(item.toString(), format);
                if (date1 == null) {
                    String message = dateValidator.message().replace("{label}", label);
                    LOGGER.info("datel时间验证失败");
                    errorMap.put(field.getName(), message);
                }
            }

        }

        //手机
        MobileValidator mobileValidator = field.getAnnotation(MobileValidator.class);
        if (mobileValidator != null) {
            String mobile = item.toString();
            String label = mobileValidator.label();
            if (!ValidatorHelper.mobileValidator(mobile)) {
                String message = mobileValidator.message().replace("{label}", label);
                LOGGER.info("手机验证失败");
                errorMap.put(field.getName(), message);
            }
        }

        // 身份证号
        IdcodeValidator idCodeValidator = field.getAnnotation(IdcodeValidator.class);
        if (idCodeValidator != null) {
            String label = idCodeValidator.label();
            if (!IDcodeUtil.isValidIDCode(item.toString())) {
                String message = idCodeValidator.message().replace("{label}", label);
                errorMap.put(field.getName(), message);
            }
        }

        //枚举
        EnumValidator enumValidator = field.getAnnotation(EnumValidator.class);
        if (enumValidator != null) {
            int[] candidates = enumValidator.candidates();
            String label = enumValidator.label();
            if (!checkCandidates(item, candidates)) {
                String message = enumValidator.message().replace("{label}", label);
                errorMap.put(field.getName(), message);
            }
        }

        //整数
        IntegerRangeValidator integerRangeValidator = field.getAnnotation(IntegerRangeValidator.class);
        if (integerRangeValidator != null) {
            int min = integerRangeValidator.min();
            int max = integerRangeValidator.max();
            String label = integerRangeValidator.label();
            String message = integerRangeValidator.message();
            try {
                int num = Integer.valueOf(item.toString());
                if (num < min) {
                    message = "{label}应不小于" + min;
                    errorMap.put(field.getName(), message.replace("{label}", label));
                }
                if (num > max) {
                    message = "{label}应不大于" + max;
                    errorMap.put(field.getName(), message.replace("{label}", label));
                }
            } catch (NumberFormatException e) {
                errorMap.put(field.getName(), message.replace("{label}", label));
            }
        }

        // Double + 小数位数验证 [自定义的注解]
        DoubleRangeValidator doubleRangeValidator = field.getAnnotation(DoubleRangeValidator.class);
        if (doubleRangeValidator != null) {
            double min = doubleRangeValidator.min();
            double max = doubleRangeValidator.max();
            int decimal = doubleRangeValidator.decimal();
            String label = doubleRangeValidator.label();
            String message = doubleRangeValidator.message();

            try {
                // attention ！！！
                // double数据多于13位会有精度损失
                double d = Double.valueOf(item.toString());
                // 转 BigDecimal,取精度，因为 double 会自动转科学计数法，影响小数位计算
                BigDecimal bd = BigDecimal.valueOf(d);
                // 小数位验证
                if (bd.scale() > decimal) {
                    message = "{label}至多包含" + decimal + "位小数";
                    errorMap.put(field.getName(), message.replace("{label}", label));
                }

                // 数值大小应在{min}和{max}之间
                if (d < min) {
                    // min 是整数，小数点后面是0
                    if (min % 1 == 0) {
                        message = "{label}应不小于" + Double.valueOf(min).intValue();
                    } else {
                        // min 不是整数，小数点后面不是0
                        message = "{label}应不小于" + min;
                    }
                    errorMap.put(field.getName(), message.replace("{label}", label));
                }
                if (d > max) {

                    if (max % 1 == 0) {
                        // max是个整数，小数点后面是0
                        message = "{label}应不大于" + Double.valueOf(max).intValue();
                    } else {
                        // max不是整数，小数点后面不是0
                        message = "{label}应不大于" + max;
                    }
                    errorMap.put(field.getName(), message.replace("{label}", label));
                }q
            } catch (NumberFormatException e) {
                // 非数据  不符合规范
                errorMap.put(field.getName(), message.replace("{label}", label));
            }
        }
    }
}


```

