File.delete() 会立即删除文件

File.deleteOnExit() 并不会立即删除，可能在jvm退出时删除





# 5种文件拷贝方式

1. 传统字节流拷贝

   ```java
    /**
        * 传统字节流拷贝
        * 简单，适合于小文件，效率低
        * @param sourcePath
        * @param destPath
        */
       public static void copyFile1(String sourcePath, String destPath) {
           try (FileInputStream in = new FileInputStream(sourcePath);
                FileOutputStream out = new FileOutputStream(destPath)) {
               // 这里可以使用FileOutputStream来写入文件
               byte[] buffer = new byte[1024]; // 定义一个缓冲区
               int bytesRead; // 记录每次读取的字节数
               while ((bytesRead = in.read(buffer)) != -1) { // 从输入流中读取数据到缓冲区，直到读到文件末尾
                   out.write(buffer, 0, bytesRead); // 将缓冲区中的数据写入输出流，参数0表示从缓冲区的开始位置写入，bytesRead表示写入的字节数
               }
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   ```

   

2. 缓冲流优化拷贝

   ```java
   
       /**
        * 缓冲流优化拷贝
        * 比传统字节流要好，通过缓冲区减少IO次数
        * @param sourcePath
        * @param destPath
        */
       public static void copyFile2(String sourcePath, String destPath) {
           try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(sourcePath));
                BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(destPath))) {
               // 这里可以使用FileOutputStream来写入文件
               byte[] buffer = new byte[8192]; // 定义一个缓冲区,缓冲区越大性能越好
               int bytesRead; // 记录每次读取的字节数
               while ((bytesRead = bufferedInputStream.read(buffer)) != -1) { // 从输入流中读取数据到缓冲区，直到读到文件末尾
                   bufferedOutputStream.write(buffer, 0, bytesRead); // 将缓冲区中的数据写入输出流，参数0表示从缓冲区的开始位置写入，bytesRead表示写入的字节数
               }
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   ```

3. Files.copy 

   ```java
     /**
        * NIO  Files.copy  适合多数情景，代码简单 java7+
        * @param sourcePath
        * @param destPath
        */
       public static void copyFile3(String sourcePath, String destPath) {
           Path source = Paths.get(sourcePath);
           Path dest = Paths.get(destPath);
           try {
               java.nio.file.Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING);
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   ```

4. FileChannel

   ```java
   
       /**
        * NIO  FileChannel 通道拷贝 大文件性能最佳(采用零拷贝)
        * @param sourcePath
        * @param destPath
        */
       public static void copyFile4(String sourcePath, String destPath) {
           try (FileChannel sourceChannel = new FileInputStream(sourcePath).getChannel();
                FileChannel destChannel = new FileOutputStream(destPath).getChannel()) {
               destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());
           } catch (Exception e) {
               e.printStackTrace();
   
           }
       }
   ```

5. 内存拷贝

   ```java
   
       /**
        * 内存映射文件拷贝 适合大文件，性能较好，但需要注意内存泄露
        * @param sourcePath
        * @param destPath
        */
       public static void copyFile5(String sourcePath, String destPath) {
           try (RandomAccessFile sourceFile = new RandomAccessFile(sourcePath, "r");
                RandomAccessFile destFile = new RandomAccessFile(destPath, "rw");) {
               FileChannel sourceChannel = sourceFile.getChannel();
               MappedByteBuffer buffer = sourceChannel.map(FileChannel.MapMode.READ_ONLY, 0, sourceChannel.size());
               destFile.getChannel().write(buffer);
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   ```

   