# jps 

Jps 的作用是查看当前运行的java程序

<img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220422141659785.png" alt="image-20220422141659785" style="zoom:50%;" />

之后拿到进程id (3793)



# top

Top 可以将占用cpu 由高到低的顺序展示线程

<img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220422142233229.png" alt="image-20220422142233229" style="zoom:50%;" />

# jstack

查看**线程**堆栈信息，主要是分析当前虚拟机正在执行什么程序，运行到哪里，在哪里阻塞

jstack用于生成java虚拟机当前时刻的线程快照。**线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合**，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。可能导致的现象是CPU过高

通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源

jstack -l pid

<img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220422141843101.png" alt="image-20220422141843101" style="zoom:50%;" />



jstack  pid -> xx.txt 

输出线程堆栈信息到指定文件中

## 线程状态

**NEW,**未启动的。不会出现在Dump中。

**RUNNABLE,**在虚拟机内执行的。运行中状态，可能里面还能看到locked字样，表明它获得了某把锁。

**BLOCKED**,受阻塞并等待监视器锁。被某个锁(synchronizers)給block住了。

**WATING**,无限期等待另一个线程执行特定操作。等待某个condition或monitor发生，一般停留在park(), wait(), sleep(),join() 等语句里。

**TIMED_WATING,**有时限的等待另一个线程的特定操作。和WAITING的区别是wait() 等语句加上了时间限制 wait(timeout)。

**TERMINATED**,已退出的。

•java.lang.Thread.State: WAITING (parking)：一直等那个条件发生；
•java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。



## Monitor

在多线程的 JAVA程序中，实现线程之间的同步，就要说说 Monitor。 Monitor是 Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。下 面这个图，描述了线程和 Monitor之间关系，以 及线程的状态转换图：

![thread](https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081411039.bmp)

进入区(Entrt Set):表示线程通过synchronized要求获取对象的锁。如果对象未被锁住,则迚入拥有者;否则则在进入区等待。一旦对象锁被其他线程释放,立即参与竞争。

拥有者(The Owner):表示某一线程成功竞争到对象锁。

等待区(Wait Set):表示线程通过对象的wait方法,释放对象的锁,并在等待区等待被唤醒。

## 调用修饰

locked <地址> 目标：使用synchronized申请对象锁成功,监视器的拥有者。

waiting to lock <地址> 目标：使用synchronized申请对象锁未成功,在迚入区等待。

waiting on <地址> 目标：使用synchronized申请对象锁成功后,释放锁幵在等待区等待。

parking to wait for <地址> 目标





```
"Monitor Ctrl-Break" #5 daemon prio=5 os_prio=31 tid=0x00007fe091809800 nid=0x3c03 runnable [0x0000700003c12000]
   java.lang.Thread.State: RUNNABLE
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
	at java.net.SocketInputStream.read(SocketInputStream.java:171)
	at java.net.SocketInputStream.read(SocketInputStream.java:141)
	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)
	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
	- locked <0x00000006c000cf48> (a java.io.InputStreamReader)
	at java.io.InputStreamReader.read(InputStreamReader.java:184)
	at java.io.BufferedReader.fill(BufferedReader.java:161)
	at java.io.BufferedReader.readLine(BufferedReader.java:324)
	- locked <0x00000006c000cf48> (a java.io.InputStreamReader)
	at java.io.BufferedReader.readLine(BufferedReader.java:389)
	at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:49)

"Signal Dispatcher" #4 daemon prio=9 os_prio=31 tid=0x00007fe091043000 nid=0x3a03 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Finalizer" #3 daemon prio=8 os_prio=31 tid=0x00007fe09202a000 nid=0x4e03 in Object.wait() [0x0000700003906000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	- waiting on <0x00000006c000e880> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)
	- locked <0x00000006c000e880> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)
	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)
```

Wait on condition 该状态出现在线程等待某个条件的发生。具体是什么原因，可以结合 stacktrace来分析。 最常见的情况就是线程处于sleep状态，等待被唤醒。 常见的情况还有等待网络IO

一般情况下，通过jstack输出的线程信息主要包括：jvm自身线程、用户线程等。其中jvm线程会在jvm启动时就会存在。对于用户线程则是在用户访问时才会生成。

```jvm  线程
"VM Thread" os_prio=31 tid=0x00007fe093014000 nid=0x3003 runnable

"GC task thread#0 (ParallelGC)" os_prio=31 tid=0x00007fe09100b000 nid=0x1d07 runnable

"GC task thread#1 (ParallelGC)" os_prio=31 tid=0x00007fe092008800 nid=0x1f03 runnable

"GC task thread#2 (ParallelGC)" os_prio=31 tid=0x00007fe092009800 nid=0x2003 runnable

"GC task thread#3 (ParallelGC)" os_prio=31 tid=0x00007fe09200a000 nid=0x2a03 runnable

"GC task thread#4 (ParallelGC)" os_prio=31 tid=0x00007fe09200a800 nid=0x2c03 runnable

"GC task thread#5 (ParallelGC)" os_prio=31 tid=0x00007fe09200b000 nid=0x2e03 runnable

"GC task thread#6 (ParallelGC)" os_prio=31 tid=0x00007fe09200c000 nid=0x5403 runnable

"GC task thread#7 (ParallelGC)" os_prio=31 tid=0x00007fe09200c800 nid=0x5203 runnable

"VM Periodic Task Thread" os_prio=31 tid=0x00007fe08f81b000 nid=0x4003 waiting on condition

JNI global references: 15
```

## 使用

需要先使用top 命令查询使用cpu最高的java 线程，要获取pid ，第一列就是pid

![image-20230208141432608](https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081414676.png)

之后再通过 jstack pid 来查看线程的信息,这里面能够查看到线程执行到代码的哪一行

```
"Reference Handler" #2 daemon prio=10 os_prio=31 tid=0x00007fe092027800 nid=0x4f03 in Object.wait() [0x0000700003803000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	- waiting on <0x00000006c000ea38> (a java.lang.ref.Reference$Lock)
	at java.lang.Object.wait(Object.java:502)
	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
	- locked <0x00000006c000ea38> (a java.lang.ref.Reference$Lock)
	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

"main" #1 prio=5 os_prio=31 tid=0x00007fe092809000 nid=0x1103 runnable [0x0000700002de5000]
   java.lang.Thread.State: RUNNABLE
	at com.zhouyu.user.MyApplication.main(MyApplication.java:19)
```

可以看出 0x0000700003803000 线程 持有0x00000006c000ea38 资源但是也在等待 0x00000006c000ea38 资源

为什么同时锁住的等待同一个资源：

> 线程的执行中，先获得了这个对象的 Monitor（对应于 locked <0x00000006c000ea38>）。当执行到 obj.wait(), 线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on <0x00000006c000ea38> ）。

## 情景

### **进入区等待**

```
"d&a-3588" daemon waiting for monitor entry [0x000000006e5d5000]
java.lang.Thread.State: BLOCKED (on object monitor)
at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()
- waiting to lock <0x0000000602f38e90> (a java.lang.Object)
at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()
```

线程状态BLOCKED,线程动作wait on monitor entry,调用修饰waiting to lock总是一起出现。表示在代码级别已经存在冲突的调用。必然有问题的代码,需要尽可能减少其发生。

### **同步块阻塞**

一个线程锁住某对象,大量其他线程在该对象上等待。

```
"blocker" runnable
java.lang.Thread.State: RUNNABLE
at com.jiuqi.hcl.javadump.Blocker$1.run(Blocker.java:23)
- locked <0x00000000eb8eff68> (a java.lang.Object)
"blockee-11" waiting for monitor entry
java.lang.Thread.State: BLOCKED (on object monitor)
at com.jiuqi.hcl.javadump.Blocker$2.run(Blocker.java:41)
- waiting to lock <0x00000000eb8eff68> (a java.lang.Object)
"blockee-86" waiting for monitor entry
java.lang.Thread.State: BLOCKED (on object monitor)
at com.jiuqi.hcl.javadump.Blocker$2.run(Blocker.java:41)
- waiting to lock <0x00000000eb8eff68> (a java.lang.Object)
```

持续运行的IO IO操作是可以以RUNNABLE状态达成阻塞。例如:数据库死锁、网络读写。 格外注意对IO线程的真实状态的分析。 一般来说,被捕捉到RUNNABLE的IO调用,都是有问题的。

### 死锁

线程状态为RUNNABLE。 调用栈在SocketInputStream或SocketImpl上,socketRead0等方法。 调用栈包含了jdbc相关的包。很可能发生了数据库死锁

```
"d&a-614" daemon prio=6 tid=0x0000000022f1f000 nid=0x37c8 runnable
[0x0000000027cbd000]
java.lang.Thread.State: RUNNABLE
at java.net.SocketInputStream.socketRead0(Native Method)
at java.net.SocketInputStream.read(Unknown Source)
at oracle.net.ns.Packet.receive(Packet.java:240)
at oracle.net.ns.DataPacket.receive(DataPacket.java:92)
at oracle.net.ns.NetInputStream.getNextPacket(NetInputStream.java:172)
at oracle.net.ns.NetInputStream.read(NetInputStream.java:117)
at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:1034)
at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:588)
```

wait on monitor entry： 被阻塞的,肯定有问题

runnable ： 注意IO线程

in Object.wait()： 注意非线程池等待 ,正常的等待就是一般只有 `at java.lang.Object.wait(Native Method)` 异常的可能是`at java.lang.Object.wait(Object.java:485)` 对象等待

### 其他

1. 如果某个相同的call stack经常出现， 我们有80%的以上的理由确定这个代码存在性能问题（读网络的部分除外）；
2. 如果相同的call stack出现在同一个线程上（tid）上， 我们很很大理由相信， 这段代码可能存在较多的循环或者死循环；
3. 如果某call stack经常出现， 并且里面带有lock，请检查一下这个lock的产生的原因， 可能是全局lock造成了性能问题；
4. 在一个不大压力的群集里（w<2）， 我们是很少拿到带有业务代码的stack的， 并且一般在一个完整stack中， 最多只有1-2业务代码的stack，
5. 如果经常出现， 一定要检查代码， 是否出现性能问题。
6. 如果你怀疑有dead lock问题， 那么请把所有的lock id找出来，看看是不是出现重复的lock id。



# jmap

## jvm命令

```
-XX:-CITime：打印消耗在JIT编译的时间。
-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。
-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。
-XX:OnError=";"：出现致命ERROR后运行自定义命令。
-XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。
-XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。
-XX:-PrintCompilation：当一个方法被编译时打印相关信息。
-XX:-PrintGC：每次GC时打印相关信息。
-XX:-PrintGCDetails：每次GC时打印详细信息。
-XX:-PrintGCTimeStamps：打印每次GC的时间戳。
-XX:-TraceClassLoading：跟踪类的加载信息。
-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。
-XX:-TraceClassResolution：跟踪常量池。
-XX:-TraceClassUnloading：跟踪类的卸载信息。

-XX:+HeapDumpOnOutOfMemoryError： 当OutOfMemoryError发生时自动生成 Heap Dump 文件。
-XX:+HeapDumpBeforeFullGC 当 JVM 执行 FullGC 前执行 dump。
-XX:+HeapDumpAfterFullGC： 当 JVM 执行 FullGC 后执行 dump
-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。
```

具体使用：

```java
-XX:+HeapDumpOnOutOfMemoryError 
-XX:HeapDumpPath=/qjyd/log/appraisal/heap_dump_pid%p.hprof
-XX:+PrintGCDateStamps 
-XX:+PrintGCDetails 
-XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log 
-Xloggc:/qjyd/log/appraisal/gc-%t.log
```

通过上述启动配置，可以在内存溢出的时候将信息打印到heap_dump_pid%p.hprof文件中

每次GC的时候回打印日志到/qjyd/log/appraisal/gc-%t.log，

## GC文件

## -XX:+PrintGCDetails

使用这个命令对打印

<img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220824233332966.png" alt="image-20220824233332966" style="zoom:50%;" />

##  三、生成dump

先从服务器上下载hprof 文件

1246 是cpu 最高的进程id

```text
jmap -dump:format=b,file=user.dump 1246
```

在生产dump 文件的时候jvm 是停止一切工作的

##  四、找到最大对象，并且找到是如何生成的

这个最大对象是经历多次回收之后仍然存在的对象，就有可能是内存泄露的原因

1. 从当前对象集找到最大对象是什么，之后整理这个对象，右键使用选定对象

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081546353.png" alt="image-20220825090504002" style="zoom:50%;" />



2. 选择传入引用

   
   <img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202409291041828.png" alt="image-20220825090629361" style="zoom:50%;" />

   

3. 可以发现使用这个引入组合起来的对象

   <img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081546385.png" alt="image-20220825090819690" style="zoom:50%;" />

   这个对象是业务对象的话，就能大致定位是业务哪步生成出来的

   如果还不能确定的话，需要继续合并引用

   4. 继续合并引用

      ![image-20220825091307267](https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081546343.png)

      <img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220825091044622.png" alt="image-20220825091044622" style="zoom:50%;" />

4. 分析最大对象

   查看最大对象可以判断是不是对象过大

   <img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081546867.png" alt="image-20220825091346649" style="zoom:50%;" />

5. 查看创建对象的线程堆栈

   <img src="/Users/peilizhi/Library/Application Support/typora-user-images/image-20220825091450884.png" alt="image-20220825091450884" style="zoom:50%;" />

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081546386.png" alt="image-20220825091518392" style="zoom:50%;" />

一直展开能看到线程堆栈，记录线程号

之后在线程转储中根据线程号找对应的执行流程

![image-20220825091615473](https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081546613.png)

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202302081546775.png" alt="image-20220825091727246" style="zoom:50%;" />

7. 分析业务，确定好问题在哪里

```
Server side(10.111.4.94,20991) threadpool is exhausted ,detail msg:Thread pool is EXHAUSTED! Thread Name: DubboServerHandler-10.111.4.94:20991, Pool Size: 200 (active: 199, core: 200, max: 200, largest: 200), Task: 13622829 (completed: 13622632), Executor status:(isShutdown:false, isTerminated:false, isTerminating:false), in dubbo://10.111.4.94:20991!
```

