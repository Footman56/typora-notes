

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410180021041.png" style="zoom:50%;" />

对象内存可以分为： 对象头、实例数据、对齐填充

实例数据：各种属性

对齐填充：保证内存大小为8的倍数



Kclass 为类型指针：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。



在不同位操作系统中，是否使用压缩技术 对象头的大小不同

4字节正好是32位

|            | 32位系统（字节） | 64位系统未压缩（字节） | 64位系统压缩（字节） |
| ---------- | ---------------- | ---------------------- | -------------------- |
| MarkWord   | 4                | 8                      | 4                    |
| 元数据指针 | 4                | 8                      | 4                    |
| 数组长度   | 4                | 4                      | 4                    |

为什么要使用指针压缩？

+ 增加了GC开销：64位对象引用需要占用更多的堆空间，留给其他数据的空间将会减少，
  从而加快了GC的发生，更频繁的进行GC
+ 降低CPU缓存命中率：64位对象引用增大了，CPU能缓存的oop将会更少，从而降低了CPU缓存的效率。

堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间

堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现上面的问题，所以**堆内存不要大于32G为好**

![image-20241018010914470](https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410180109515.png)

**JVM 通过逃逸分析来判断是否能在栈内分配**

逃逸分析： 检查这个对象时候在方法外有别的引用，如果没有，就可以分配在栈中

优点：在栈中随方法结束而回收，避免多余的GC

-XX:+DoEscapeAnalysis 开启逃逸分析，jdk7之后默认开启



如果在栈内分配，但是没有连续的空间，可以使用**标量替换**

标量：不能被进一步分解的量，基础数据都是标量，reference类型  

-XX:+EliminateAllocations 开启标量替换，jdk7之后默认开启



新生对象在Eden区，如果大量的对象，存活的时间比较短的话，可以适当扩大Eden区的容量

Eden: s1:s2 = 8:1:1   -XX:-UseAdaptiveSizePolicy 可以动态调整比例（默认开启）

Eden放不下的话会触发minor gc 。 Eden中对象会进入到 s1区，如果s1放不下就放入老年代



进入到老年代的情景

+ 大对象

+ 长期存活的对象
+ 动态年龄

**大对象直接进入老年代**

-XX:PretenureSizeThreshold可以设置大对象的大小【单位是字节】

如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在Serial和ParNew两个收集器下有效。

能够避免在大对象的年轻代进行复制



**长期存活的对象**

如果对象在Eden出生并经过第一次MinorGC后仍然能够存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（**默认为15岁**，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同） 

-XX:MaxTenuringThreshold 来设置最大年龄



**动态年龄**

在surivor中存活的对象，n(1)+n(2) ...+ n(n) >= 50% * surivor 的话， 年龄 >= n(n+1) 的对象进入老年代

-XX:TargetSurvivorRatio 设置Servir : s1 的比例

**对象动态年龄判断一般在minor gc 之后触发**



**老年代空间担保机制**

**在minor gc 之前触发**

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410180054788.png" alt="image-20241018005456736" style="zoom:50%;" />

**为什么要进行空间担保？**

　　是因为新生代采用**复制收集算法**，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。**老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象**，但一共有多少对象在内存回收后存活下来是不可预知的，**因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考**。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。



GC Roots : 线程栈的本地变量、静态变量、本地方法栈的变量

**即使被标记为不可达对象的时候，也不一定要立刻回收，需要一个标记过程**

标记过程：

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410180106619.png" style="zoom:50%;" />

如果再次变成不可达之后，就立刻回收，因为finalize()只会执行一遍