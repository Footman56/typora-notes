# jvm调参

2025年2.18 ，早上机器内存达到75%以上

1. 确认内存情况，来定位具体问题时间

   ![image-20250218142713842](https://raw.githubusercontent.com/Footman56/images/master/img202502181427163.png)

可以确定时间是8:57 。

2. 检查是否有慢sql

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502181429145.png" alt="image-20250218142952093" style="zoom:50%;" />

实际上是有慢sql 的，是查询草稿的问题。

可以考虑删除数据、或者修改sql 再或者就是修改业务逻辑。

3. 如果没有的话就需要检查耗时的请求，在监控这个发现了有比较耗内存的操作。也可以监控请求时机比较长的。

   ![image-20250218143555730](https://raw.githubusercontent.com/Footman56/images/master/img202502181435795.png)

4. 通过上面分析就可以确实，是由导出大量数据操作导致内存问题。
5. 现在分析为什么垃圾回收机制解决失效啦

```sh
-Dapp.key=appraisal -Xms1G -Xmx4G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Dspring.profiles.active=online -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/qjyd/app/appraisal/work -Djava.net.preferIPv6Addresses=false -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/qjyd/log/ -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log -Xloggc:/qjyd/log/appraisal/gc-%t.log -XX:+UseG1GC -XX:G1ReservePercent=20 -javaagent:/qjyd/app/ArmsAgent-appraisal/arms-bootstrap-1.7.0-SNAPSHOT.jar -Dlogging.config=./config/log4j2/log4j2-online.xml
```

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502181449077.png" alt="image-20250218144957995" style="zoom:50%;" />

需要确认案发时间的gc 回收情况， 通过这个young gc 可以得出的结论是 老年代大约内存为  1156M. 

触发mixed gc 时老年代占比是默认 45% ， 4096 * 0.45 = 1843 M ，此时没有达到 所以没有触发mixed  gc，参数

`-XX:InitiatingHeapOccupancyPercent=45`

年轻代的最大大小是 60%   4096 * 0.6 = 2457.6 M， 此时eden占比超过了 8:1:1 。通过参数 `-XX:G1NewSizePercent=5 -XX:G1MaxNewSizePercent=60 `

问题就是老年代的数据没有达到 45% 的标志，无法触发mixed gc， 但此时数据还是在一直增长的，eden区不断扩大，并且也没有达到60% 左右的上限，才会导致这个问题的。

并且近一个月内老年代平均大小不超过 1G，所以说可以适当放小老年代回收比例，让老年代的数据参与回收。

![image-20250218151244044](https://raw.githubusercontent.com/Footman56/images/master/img202502181512116.png)

解决方式： 调小老年代回收的占比，让老年代尽快回收，不要占着内存；

```sh
-Dapp.key=appraisal -Xms4G -Xmx4G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Dspring.profiles.active=online -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/qjyd/app/appraisal/work -Djava.net.preferIPv6Addresses=false -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/qjyd/log/ -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log -Xloggc:/qjyd/log/appraisal/gc-%t.log -XX:+UseG1GC -XX:G1ReservePercent=20 -javaagent:/qjyd/app/ArmsAgent-appraisal/arms-bootstrap-1.7.0-SNAPSHOT.jar -Dlogging.config=./config/log4j2/log4j2-online.xml -XX:InitiatingHeapOccupancyPercent=40 
```



在分析的时候发现系统总计内存是 7G, java 程序配置的最大内存是4G， 可能是还有别的地方使用了系统的内存【堆外内存】，比如NIO的直接分配内存

可能使用堆外内存的情况

+ NIO 的 DirectByteBuffer
+ JNI 调用分配的内存，通过`malloc` 分配内存。
+ JVM 自身使用的内存
  - 元空间
  - 线程栈
  - JIT 编译代码缓存
+ 第三方库
  + apache POI
  + netty 框架

通过修改启动参数之后，机器回收频率降低，但是cpu的压力很大

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502191110261.png" alt="image-20250219111046890" style="zoom:50%;" />

查看回收日志的时候，显示年轻代回收的内存很多，就导致cpu压力很大

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502191112976.png" alt="image-20250219111201912" style="zoom:50%;" />

这是因为年轻代设置的最大比例 默认是60% ，可以调小这个比例，来减少年轻代回收的占比

```sh
-Dapp.key=appraisal -Xms4G -Xmx4G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Dspring.profiles.active=online -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/qjyd/app/appraisal/work -Djava.net.preferIPv6Addresses=false -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/qjyd/log/ -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log -Xloggc:/qjyd/log/appraisal/gc-%t.log -XX:+UseG1GC -XX:G1ReservePercent=20 -javaagent:/qjyd/app/ArmsAgent-appraisal/arms-bootstrap-1.7.0-SNAPSHOT.jar -Dlogging.config=./config/log4j2/log4j2-online.xml -XX:InitiatingHeapOccupancyPercent=40  -XX:G1MaxNewSizePercent=40
```

统计系统分配年轻代的效率。根据gc 日志来查询，抽样检测5次回收记录

| 时间     | 回收内存 |                         |
| -------- | -------- | ----------------------- |
| 11:35:26 | 2422     | 2422 / 106=  22.85  M/s |
| 11:33:40 | 2422     | 2422 / 92 =  26.33      |
| 11:32:08 | 2418     | 2418 /124  = 19.5       |
| 11:30:04 | 2406     | 2406 / 56 = 42.96       |
| 11:29:08 | 2420     | 2420 /28  =  86.43      |
| 11:28:40 |          | 平均： 39.614 M/s       |

1min 生成的内存是  39.61 * 60  = 2376 M ,  如果要失效 1分钟内回收一次垃圾的话，需要限制年轻代的最大值为 2376 M, 对于 4096M 内存来说就是  58% 

线程总数太大，导致很多线程都在等待状态  代码中设置线程池大小。

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502191409442.png" alt="image-20250219140959298" style="zoom:50%;" />



总计8G 内存， 实际内存是 7.2 G   java 线程使用 62.8%  实际内存是   7.2  * 1024 *  62.8  =4630  M

堆内存分配 4096 M ，非堆内存使用  463 M   约等于  4096 + 463 = 4559M 

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502191412174.png" alt="image-20250219141237126" style="zoom:50%;" />



注：执行jvm 启动参数的时候，需要注意`-XX:G1MaxNewSizePercent=40`, 必须配置`-XX:+UnlockExperimentalVMOptions`  并且

`-XX:+UnlockExperimentalVMOptions`  必须配置在 ``-XX:G1MaxNewSizePercent=40`` 之前

```sh
-Dapp.key=appraisal -Xms4G -Xmx4G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Dspring.profiles.active=online -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/qjyd/app/appraisal/work -Djava.net.preferIPv6Addresses=false -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/qjyd/log/ -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log -Xloggc:/qjyd/log/appraisal/gc-%t.log -XX:+UseG1GC -XX:G1ReservePercent=20 -javaagent:/qjyd/app/ArmsAgent-appraisal/arms-bootstrap-1.7.0-SNAPSHOT.jar -Dlogging.config=./config/log4j2/log4j2-online.xml -XX:InitiatingHeapOccupancyPercent=40 -XX:+UnlockExperimentalVMOptions -XX:G1MaxNewSizePercent=40
```

发布后观察

cpu 效果明显降下来啦

![image-20250220114128468](https://raw.githubusercontent.com/Footman56/images/master/img202502201141554.png)

观察gc日志，发现young gc 从1606 M就开始回收啦，不在等到2G多才回收，说明参数`-XX:G1MaxNewSizePercent=40`起作用啦

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502201142789.png" alt="image-20250220114219702" style="zoom:50%;" />

但是过一段时间之后还是有问题，可见cpu已经正常了，问题在于内存的使用率还是很高

![image-20250225114743802](https://raw.githubusercontent.com/Footman56/images/master/img202502251147154.png)

观察gc 情况，可以发现老年代没有触发回收。问题可以分成两部分：

+ 老年代没有触发mixed gc， 说明`-XX:InitiatingHeapOccupancyPercent=40` 参数的值还是很大，1210 / 4096 = 0.295，没有达到40%的比例

+ 老年代新增了很多的数据，机器接近1s进行一次young gc ，如果接口请求大于1s时，是不会被gc回收的，会进入s1区，经过多次轮次的gc后会进入到老年代，所以也要追踪请求超过1s，能优化就优化；不能优化也可以考虑降低gc回收的频次，如果回收频次大于1s的话，就可以回收

+ 目前是两台机器，其中一台机器有问题，考虑是不是机器路由分配策略问题，大部分请求都打到有问题的机器，

  + 统计两台机器http 请求占比

    ```
    * and request_uri: appraisal  and __source__: "10.111.3.51" | select __source__,count(*) as c_cout from log group by __source__ order by c_cout desc
    ```

![image-20250225114900152](https://raw.githubusercontent.com/Footman56/images/master/img202502251149203.png)







# 内存抖降

机器内存抖降，观察时间时 2025 2-18 15:32 ～ 2025 2-18 15:35

![image-20250220102754263](https://raw.githubusercontent.com/Footman56/images/master/img202502201027510.png)

检查这段时间内GC回收情况，是否有扩容问题

通过指令： `grep -E '2025-02-18T15:3[2-5]' -A100 gc-2025-02-18_11-12-35.log | grep -E 'GC pause|Eden'`查询出这段时间内的回收情况

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502201111052.png" alt="image-20250220111116923" style="zoom:50%;" />

可见在这段期间内有扩容问题。

检查之前没有抖降的时候，是否有gc扩容情况

```
grep -E '2025-02-18T15:2[0-9]' -A100 gc-2025-02-18_11-12-35.log | grep -E 'GC pause|Eden'
```

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502201114446.png" alt="image-20250220111422387" style="zoom:50%;" />

可见期间内没有gc扩容现象

观察项目发布前后的内存情况

![image-20250220111638296](https://raw.githubusercontent.com/Footman56/images/master/img202502201116357.png)

1. 发布的时候内存会回升，回升值 5.76G  = 5898 M 

2. 发布后内存会因程序占用进行消耗，剩余内存 2.9 G  = 2969M

3. 观察gc日志，发现堆使用 2299 M  `实际分配物理内存 = 5898 - 2969 = 2929M`  5998 - 2969  (操作系统不会立刻分配物理内存，只有需要的时候才会进行分配)

   所以**GC调优就有很大的必要啦，目标就是不需要再去申请实际分配物理内存** 就是要保证在 

   ![image-20250220112102832](https://raw.githubusercontent.com/Footman56/images/master/img202502201121915.png)

   ```
   # 根据目的，避免jvm再去申请物理内存，也就是要保证2929M内存满足客户需求
   -XX:G1MaxNewSizePercent=40 ： 4G * 0.4 = 1.6G 就回收
   也就是说 老年代最大使用内存为  2929 - 1938 = 991M ，占比为 991 / 4096 = 0.25
   那么实际老年代回收还可以降低  -XX:InitiatingHeapOccupancyPercent=25，其实这个值有点太小了，现在配置的是40，目前来看良好
   ```

4. 通过 `free -h` 查询内存分配情况

   <img src="https://raw.githubusercontent.com/Footman56/images/master/img202502201132830.png" alt="image-20250220113240760" style="zoom:50%;" />

total = used  + free  + cache  就是 7782.4 = 5529.6 + 2150.4 + 164 

used = jvm使用的内存 + 额外项目的内存。 

jvm 使用内存 = 4096M（堆分配内存） +  467.9(非堆内存) 



# mixded  gc 回收效率不高

mixed gc 回收效率不高，可能是年轻代的对象很容易就进入到老年代，

<img src="https://raw.githubusercontent.com/Footman56/images/master/img202502251818235.png" alt="image-20250225181838175" style="zoom:50%;" />

![image-20250225181420901](https://raw.githubusercontent.com/Footman56/images/master/img202502251814162.png)

```
系统gc日志如下：
2025-02-24T12:53:51.035+0800: 403250.281: [GC pause (G1 Evacuation Pause) (mixed), 0.0759251 secs]
   [Parallel Time: 69.8 ms, GC Workers: 4]
      [GC Worker Start (ms): Min: 403250282.4, Avg: 403250282.5, Max: 403250282.7, Diff: 0.3]
      [Ext Root Scanning (ms): Min: 12.8, Avg: 13.7, Max: 14.7, Diff: 1.9, Sum: 54.6]
      [Update RS (ms): Min: 15.7, Avg: 15.8, Max: 15.8, Diff: 0.1, Sum: 63.0]
         [Processed Buffers: Min: 45, Avg: 51.5, Max: 59, Diff: 14, Sum: 206]
      [Scan RS (ms): Min: 7.0, Avg: 10.4, Max: 12.2, Diff: 5.2, Sum: 41.5]
      [Code Root Scanning (ms): Min: 0.9, Avg: 2.7, Max: 6.1, Diff: 5.2, Sum: 10.7]
      [Object Copy (ms): Min: 26.1, Avg: 27.1, Max: 27.9, Diff: 1.7, Sum: 108.4]
      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         [Termination Attempts: Min: 1, Avg: 8.8, Max: 14, Diff: 13, Sum: 35]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      [GC Worker Total (ms): Min: 69.4, Avg: 69.6, Max: 69.7, Diff: 0.3, Sum: 278.4]
      [GC Worker End (ms): Min: 403250352.1, Avg: 403250352.1, Max: 403250352.1, Diff: 0.0]
   [Code Root Fixup: 0.2 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.5 ms]
   [Other: 5.4 ms]
      [Choose CSet: 0.7 ms]
      [Ref Proc: 1.7 ms]
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.2 ms]
      [Humongous Register: 0.1 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 1.3 ms]
   [Eden: 190.0M(190.0M)->0.0B(188.0M) Survivors: 14.0M->16.0M Heap: 1008.6M(4096.0M)->627.0M(4096.0M)]
jvm参数为：



-Dapp.key=appraisal -Xms4G -Xmx4G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Dspring.profiles.active=online -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/qjyd/app/appraisal/work -Djava.net.preferIPv6Addresses=false -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/qjyd/log/ -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log -Xloggc:/qjyd/log/appraisal/gc-%t.log 
-XX:+UseG1GC -XX:G1ReservePercent=20 -javaagent:/qjyd/app/ArmsAgent-appraisal/arms-bootstrap-1.7.0-SNAPSHOT.jar 
-Dlogging.config=./config/log4j2/log4j2-online.xml
-XX:InitiatingHeapOccupancyPercent=40 
-XX:+UnlockExperimentalVMOptions
-XX:G1MaxNewSizePercent=40
现象是：young gc 几乎1分钟1次，mixed gc很少，full gc几乎没有，内存使用情况是偶尔出现使用90%的情况，平时都是75%左右
结合gc日志和jvm参数，分析出为什么老年代回收效率不高？ 并且解释为什么会这些上述现象。并且给出解决方式要求内存使用不超过70%
```





```
-Dapp.key=appraisal -Xms4G -Xmx4G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Dspring.profiles.active=online -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/qjyd/app/appraisal/work -Djava.net.preferIPv6Addresses=false -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/qjyd/log/ -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log -Xloggc:/qjyd/log/appraisal/gc-%t.log -XX:+UseG1GC -XX:G1ReservePercent=20 -javaagent:/qjyd/app/ArmsAgent-appraisal/arms-bootstrap-1.7.0-SNAPSHOT.jar -Dlogging.config=./config/log4j2/log4j2-online.xml -XX:InitiatingHeapOccupancyPercent=35 -XX:+UnlockExperimentalVMOptions -XX:G1MaxNewSizePercent=40
```

