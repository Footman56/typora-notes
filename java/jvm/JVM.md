```
Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；
这 5 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。

使用New关键字是会在堆内存中分配一个新的空间 
```

```
从上图中我们看到常量值最小值默认-128并且不可更改，而常量池的最大值是可以通过配置JVM的启动参数来修改的，但是最后有断言至少比127要大
```

```java
+ 这个操作不适用与Integer对象所以首先会对 b 和 c 进行自动拆箱操作进行数值相加，
    该语句即变成了 a == 数值 。
    然后由于Integer对象无法直接与数值比较，所以a自动拆箱为int值40，
    该语句最终转为 40 == 40 进行数值之间的比较
    
Integer a= 5;
Integer b=new Integer(5);
System.out.println( a==b); // false
System.out.println(a.equals(b)); // true
```

**==: 比较的就是内存地址
equals:比较的就是值**

**比较数值相等的话应该用equals()。**

```
用String的intern()方法，该方法是用来将新建的String对象内容在常量池中创建，
如果常量池中已经存在则直接指向常量池中的对象，如果不存在则新建该对象并返回引用。
```

# 查看java进程

```
ps -ef |grep java
```

# Jvm 组成

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410142122999.png" alt="image-20241014212249254" style="zoom:50%;" />



<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202402191052099.png" alt="image-20240219105232756" style="zoom:50%;" />



Jvm 系统分为：

+ 类加载器(ClassLoader)： ClassLoader 负责加载字节码文件即 class 文件，class 文件在文件开头有特定的文件标示，并且 ClassLoader 只负责class 文件的加载，**加载完的字节码文件存放在运行时数据区**。
+ 运行时数据区(Runtime Data Area)： 存放数据的，包括 堆、元空间区、虚拟机栈、本地方法栈、程序计数器
+ 执行引擎(Execution Engine)：Class 文件被加载后，会把指令和数据信息放入内存中，Execution Engine 则负责把这些命令解释给操作系统，即将 JVM 指令集翻译为操作系统指令集。
+ 本地方法(Native Interface): 负责调用本地接口的。



执行流程大致如下

1. idea  编写java 代码，文件是.java
2. 通过编译器编译 成字节码，文件是.class
3. 类加载器加载 class 文件到运行时数据区
4. 解析器将字节码文件 解析成 cpu能识别的机器指令（借助了解析器、本地方法库的功能）

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202402191114957.png" alt="image-20240219111452906" style="zoom:50%;" />



## Jvm 内存管理

### 程序计数器： 

【线程私有】当前**字节码指令**执行的行号指示器，记录了当前正在执行的虚拟机字节码指令地址，如果执行的是本地方法，程序计数器是空的。程序计数器没有**OutOfMemoryError**

### 虚拟机栈：

【线程私有】，它描述的是**Java方法执行的内存模型**：每个方法在**执行的同时**都会创建一个栈帧（Stack Frame）用于存储***局部变量表***、***操作数栈***、***动态链接***、***方法出口*** 等信息，每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。

虚拟机栈帧中，局部变量表也就是平常所说的“栈”，**局部变量表所需的内存空间在编译期间分配完成**，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。栈帧（ Frame）是用来存储**数据**和部分**过程结果**的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。*** 栈帧随着方法调用而创建，随着方法结束而销毁***——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

虚拟机栈有两种异常情况：

1. **StackOverflowError**：线程请求的栈深度大于虚拟机所允许的深度，特别是方法的递归调用时
2. **OutOfMemoryError**：虚拟机栈无法满足线程所申请的空间需求，即使经过动态扩展仍然无法满足时抛出

### 本地方法栈

【线程私有】同虚拟机栈，不过本地方法栈服务的是本地方法

### 堆

【线程公有】Java虚拟机管理的内存中最大的一块，在虚拟机启动时创建，堆的作用就是存储**对象实例**和数组。

堆也是垃圾收集器所管理的主要区域，因此很多时候也被称作**GC堆**。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，因此堆还可以被细分为：**新生代和老年代**。再继续细分可以分为：**Eden空间、From Survivor空间、To Survivor空间等**，从内存分配的角度来看，线程共享的堆中还可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。

堆可以是**物理上不连续的空间**，只要逻辑上是连续的即可，分配的内存是在`运行期`确认的，因此大小不固定。-Xmx和-Xms参数可以控制堆的最大和最小值。

堆的空间大小不满足时将抛出OutOfMemoryError异常。

### 本地方法区

用于存储已被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等数据。Java虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆）。

方法区同样会抛出OutOfMemoryError异常。

在方法区中有一部分区域用来存储编译期产生的**各种字面量和符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。这里需要说明一点，常量并不是只能在编译期产生，运行期间也会产生新的常量并被发在常量池中，如 String 类的 intern() 方法。

### 直接内存

直接内存不属于虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，其主要用于 JDK1.4 引入的基于通道(Channel)和缓冲区(Buffer)的 NIO 类





## JMM 内存模型

JMM  是 多线程环境共享数据访问的规范。解决线程间的 可见性、原子性、有序性

可见性： 一个线程更新共享变量后，另一个线程就能看到

原子性：一个操作不能被中断

有序性：禁止指令重排序优化 

JMM通过**happens-before规则**来保证有序性：如果两个操作满足happens-before关系，那么JVM不会对它们进行重排序。具体实现上，**volatile关键字**通过插入内存屏障禁止特定类型的重排序，**synchronized**通过锁的获取和释放保证临界区代码的有序性。
