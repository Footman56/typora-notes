# 垃圾收集器

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410202329966.png" style="zoom:75%;" />



# 判断一个对象是否被回收

有两种算法：引用计数法、可达性分析算法

## 引用计数法：

每个对象保留一个整型的引用计数，如果计数为0 时就可被回收。

缺点： 有空间开销；引用赋值时都需要更新计数器；有环形引用问题，这种的不会被回收



## 可达性分析

以根对象集合为起始点，按照从上到下的方式搜索被根对象所链接的对象，这些对象就是可达的，不会被回收。

GCRoots:

+ 虚拟机栈中引用的对象 （各个线程中被调用的）







## 1、serial收集器

```
串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；
新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）。一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。

特点：CPU利用率最高，停顿时间即用户等待时间比较长。
适用场景：小型应用
通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。
```

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410202219205.png" alt="image-20241020221949160" style="zoom:50%;" />





## 2、parallel 收集器

```
parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；；新生代复制算法、老年代标记-压缩

采用多线程来通过扫描并压缩堆
特点：停顿时间短，回收效率高，对吞吐量要求高。
适用场景：大型应用，科学计算，大规模数据采集等。
通过JVM参数 XX:+USeParNewGC
```

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410202226151.png" alt="image-20241020222622114" style="zoom:50%;" />

吞吐量：CPU中用于运行用户代码的时间与CPU总消耗时间的比值。

## 3、ParNew收集器

```
serial收集器的多线程版本，新生代并行，老年代串行
ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩

参数控制：-XX:+UseParNewGC  ParNew收集器

-XX:ParallelGCThreads 限制线程数量
```

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410202231141.png" alt="image-20241020223112103" style="zoom:50%;" />

## 4、cms 收集器

```
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：
优点:并发收集、低停顿
缺点：产生大量空间碎片、并发阶段会降低吞吐量
特点：响应时间优先，减少垃圾收集停顿时间
适应场景：大型服务器等。
采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。
```

<img src="https://gcore.jsdelivr.net/gh/Footman56/imageBeds/202410202244514.png" alt="image-20241020224441474" style="zoom:50%;" />



垃圾收集器组合

| 年轻代   | 老年代       |
| -------- | ------------ |
| Serial   | Serial  Old  |
| Parallel | Parallel Old |
| parNew   | CMS          |
| Serial   | CMS          |
| ParNew   | Serial Old   |
| Parallel | Serial Old   |

***并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。***

***吞吐量：每秒能够做多少事？***



G1ReservePercent

## 5、G1收集器

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410301609145.png" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410221644701.png" alt="image-20241022142839341" style="zoom:50%;" />

在G1垃圾回收的时候Humongous 区也算做老年代



G1 筛选回收的有 XX:MaxGCPauseMillis 控制回收region， 如果配置的是 2s的话，会根据 region 回收的时间、成本进行排序，找到所有region 回收时间之和小于MaxGCPauseMillis 的，剩余的不回收

回收成本：一个region 80%垃圾、另一个region 20% 垃圾，优先回收 20%的

回收时间：一个region 回收10ms， 另一个region 回收 2ms ，优先回收 2ms 的

-InitiatingHeapOccupancyPercent： 默认45%。针对混合回收回收的参数：混合回收不仅针对老年代，还有新生代和大对象，老年代占据了堆内存45%的Region的时，会触发混合GC



G1对象进入到老年代情景：

1. 新生代经过多次GC后存活，达到阈值年龄的对象移入到老年代

2. Survior区GC后对象存活率超过50%，该区中年龄超过平均值的对象移入老年区

3. 大对象（内存占用超过Region分区的50%）直接分配到老年区

   



什么场景适合使用G1

1. 50%以上的堆被存活对象占用
2. 对象分配和晋升的速度变化非常大
3. 垃圾回收时间特别长，超过1秒
4. 8GB以上的堆内存(建议值)
5. 停顿时间是500ms以内



# 安全点与安全区域

安全点就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以**GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。**

这些特定的安全点位置主要有以下几种:

1. 方法返回之前
2. 调用某个方法之后
3. 抛出异常的位置
4. 循环的末尾

大体实现思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的。

安全区域又是什么？SafePoint是对正在执行的线程设定的。如果一个线程处于Sleep或中断状态，它就不能响应JVM的中断请求，再运行到SafePoint上。因此JVM引入了SafeRegion。**SafeRegion是指在一段代码片段中，引用关系不会发生变化**。在这个区域内的任意地方开始GC都是安全的。



# 优化方法

+ 调小对象进入老年代的年龄： 对象存活的时间不长，minor gc 的间隔时间大于大对象存活的时间，几次minor gc 之后仍存活的大对象基本上就是要进入老年代的，不需要等15次minor ，避免一直占用 server区
+ 大对象直接进入老年代,(XX:PretenureSizeThreshold)，  一般设置1M

+ 对于JDK8默认的垃圾回收器是**-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)**，如果内存较大(超过4个G，只是经验值)，系统对停顿时间比较敏感，我们可以使用ParNew+CMS(-XX:+UseParNewGC -XX:+UseConcMarkSweepGC)





## 如何选择垃圾收集器

1. 优先调整堆的大小让服务器自己来选择
2. 如果内存小于100M，使用串行收集器
3. 如果是单核，并且没有停顿时间的要求，串行或JVM自己选择
4. 如果允许停顿时间超过1秒，选择并行或者JVM自己选
5. 如果响应时间最重要，并且不能超过1秒，使用并发收集器
6. 4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC











1. g1的enden区什么时候会扩容
   + 对象分配率高：短时间内有大量的对象创建，Eden 区会被快速填满，G1 可能动态增加 Eden 区的 Region 数量，以延迟下一次 Young GC 的时间。
   + GC 停顿时间目标未达标：实际 Young GC 停顿时间 **短于 `MaxGCPauseMillis` 的设定值**，G1 可能认为有优化空间，会尝试增加 Eden 区，通过减少 Young GC 频率来提升吞吐量。
   + 老年代晋升压力低：
   + 如果 Young GC 后 **存活对象较少**（晋升到老年代的对象少），G1 可能扩大 Eden 区，减少 GC 频率。
2. 老年代占1G, 年轻代接近2G，此时内存占用超过75%，后续年轻代回收的时候，为什么内存利用率不降







