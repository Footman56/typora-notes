# G1

```
#使用G1垃圾收集器，在低延迟和高吞吐间寻找平衡，可以调整最大停止时间，设置新生代大小来提高吞吐量
-XX:+UseG1GC

#堆内存，示例设置最大最小值为4g，对于G1，一般建议2g以上。注意设定Xms=Xmx，防止发生扩容、缩容
-Xms4g -Xmx4g 

#配置元空间初始256m、最大256m。不配置的话，元空间会不受限地占用物理机内存
-XX:MetaspaceSize=256m  -XX:MaxMetaspaceSize=256m 
 
#设置最大暂停时间，默认200ms。G1收集回收器将堆进行分区，划分为一个个的区域，每次收集的时候，只收集其中几个区域，以此来控制垃圾回收产生一次停顿时间。
#暂停时间只是一个目标，并不能总是得到满足，G1会逐步调整到最佳状态。但若暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度，最终退化成Full GC。
#在极端环境（如要求业务接口需要快速返回结果）下可尝试设置20ms以下，此时建议：精简下应用服务（减少实例的产生）、升级高版本jdk（17）、做好压测、长期关注。
-XX:MaxGCPauseMillis=100

#指定Region大小，必须是2次幂，最大是32m，具体取值有1MB、2MB、4MB、8MB、16MB、32MB。注意当对象占用内存超过Region的一半时将被视为大对象，被分配到Humongous区域
#可以预估应用服务的对象大小，确定Region大小。如果没有大对象的场景，则可尝试配置2m、1m，使单个Region能被快速回收
#该配置非必填，不声明时，Region大小等于堆大小除以2048
-XX:G1HeapRegionSize=2m

#针对混合回收回收的参数：混合回收不仅针对老年代，还有新生代和大对象
#老年代Region触发混合GC的占比，默认值是45，也就是说老年代占据了堆内存45%的Region的时，会触发混合GC。该值一般不需要调整，这样可以让JVM内存占用维持在50%左右
-XX:InitiatingHeapOccupancyPercent=45
#混合回收阶段会执行8次（默认值），一次只回收掉部分Region，然后系统继续运行一小段时间，之后再继续混合回收，重复8轮。混合回收通过间断操作，可以把每次的回收时间控制在指定的停顿时间之内，最终也达到了垃圾清理的效果。
-XX:G1MixedGCCountTarget=8
#混合回收整理出来的空闲空间占heap的5%时（默认值），终止本次回收
-XX:G1HeapWastePercent=5

#如果一个Region中的存活对象大于Region大小的85%的话（默认值），就不去回收这个Region
-XX:G1MixedGCLiveThresholdPercent=85

#设置新生代大小，默认5%，默认最大60%。在运行过程中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过G1MaxNewSizePercent值
#年轻代中的Eden和Survivor对应的region也跟之前 一样，默认8:1:1，例如年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应 100个
#理论上，不同的应用、不同的CPU硬件资源，都会有不同的最优值，但区别不会太大。通过实践总结，调整该值的收益远不如调整其他参数（如上面提到的几个）
-XX:G1NewSizePercent=5 -XX:G1MaxNewSizePercent=60

 #gc日志打印到执行日志文件
-Xloggc:/data/server/${app}/gc.log
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime 

#可以生成更详细的Survivor空间占用日志，开发环境调试用
-XX:+PrintAdaptiveSizePolicy 
#在控制台输出GC情况，一般是本地调试用。（上线后是后台运行，不关注控制台日志）
-verbose:gc 

#开启远程debug，开发环境、测试环境可考虑配置
-Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n 

#spring相关，指定加载配置文件
--spring.config.location=classpath:/,classpath:/config/,file:./,file:./config/,file:/home/mall-job/conf/
```



