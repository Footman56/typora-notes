```
-Xmx3550m：设置JVM最大堆内存为3550M。
-Xms3550m：设置JVM初始堆内存为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如>2MB）时将会在很大程度上降低系统的性能。
-Xmn2g：设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。
-XX:NewSize=1024m：设置年轻代初始值为1024M。
-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。
-XX:PermSize=256m：设置持久代初始值为256M。
-XX:MaxPermSize=256m：设置持久代最大值为256M。
-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。
-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。
-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。
```

-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？
如下：
高优先级：-XX:NewSize/-XX:MaxNewSize 
中优先级：-Xmn（默认等效 -Xmn=-XX:NewSize=-XX:MaxNewSize=?） 
低优先级：-XX:NewRatio 
推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成





# Java 启动参数

```启动指令
nohup java -server -Denv_config=staging 
-XX:PermSize=256m      			设置持久代(perm gen)初始值 1/64
-XX:MaxPermSize=1024m       设置持久代最大值	物理内存的1/4	
-XX:+CMSParallelRemarkEnabled 
-XX:+ExplicitGCInvokesConcurrent 
-XX:+CMSPermGenSweepingEnabled 
-XX:+CMSClassUnloadingEnabled 
-XX:+UseParNewGC    				使用ParNew收集器 
-XX:ParallelCMSThreads=8    限制ParNew新生代线程数量
-XX:+PrintGCTimeStamps 
-XX:+PrintGCDetails 
-verbose:gc -Xloggc:/qjyd/log/hardware/gc.log -XX:+CMSScavengeBeforeRemark 
-Xmx1g    最大堆大小，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制
-Xms1g    初始堆大小，默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.
-Xmn1g    年轻代大小(1.4or lator)	  
-Dlog4j.configuration=log4j-online.properties 
-Dspring.profiles.active=staging 
-Dfile.encoding=UTF-8 
-Duser.timezone=GMT+08             时区
-Dsun.jnu.encoding=UTF-8           语言版本
-XX:+HeapDumpOnOutOfMemoryError 
-Djava.net.preferIPv6Addresses=false 
-Djava.io.tmpdir=/qjyd/app/hardware/work 
-XX:HeapDumpPath=/qjyd/log/hardware/heap_dump_pid%p.hprof 
-XX:ErrorFile=/qjyd/log/hardware/hs_err-%t.log -jar ${package_path} 
> ./hardware.log 2>&1 &     重定向输出日志的位置
-Xss   每个线程的堆栈大小 JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右
-XX:NewRatio   年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)
-XX:SurvivorRatio   Eden区与单个Survivor区的大小比值  
-XX:+DisableExplicitGC      关闭System.gc()   需要严格控制
-XX:+AggressiveOpts   加快编译  没有必要不开启
```

## nohup 

```
表示不挂断运行： 退出当前账号后，程序继续执行
&： 后台运行

使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：
nohup command > myout.file 2>&1 &   或者简化命令 nohup command > myfile.log &
```



