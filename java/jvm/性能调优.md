

# jps

查看允许的java 进程

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222227872.png" alt="image-20241022222706830" style="zoom:50%;" />

# jmap

查看某一时刻 jvm 使用 情况

jmap -histo 17746 



<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222226162.png" alt="image-20241022222610101" style="zoom:25%;" />

为了方便查看 输出dump文件

jmap -dump:format=b file=/Users/peilizhi/test.hprof  17736

![image-20241022223022886](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222230924.png)

有了dump 文件就可以分析内存情况，使用jvisualvm、 mat工具分析

# jstack

查看java 线程      jstack PID

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222235459.png" alt="image-20241022223507415" style="zoom:50%;" />

```
prio:java优先级 
os_prio: 系统优先级
tid:线程id
nid:操作系统内核线程id
```

## 查询cpu飙升的线程

1. top  找出cpu 飙升的进程

2. 查看进程内飙升的线程

   top -H -p PID

   ![image-20241022225123026](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222251080.png)

3. 需要先讲pid 转换成16进制

   ```sh
   printf "0x%x\n" 21266
   >> 0x5312
   ```

4. jstack 查看线程情况，

   jstack [java进程PID]  | grep -A10  

   ![image-20241022225717271](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222257315.png)

# jinfo 

查看jvm参数

jinfo -flags  PID

![image-20241022225955991](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222259036.png)

jinfo -sysprops PID

查看java系统参数

# jstat

查看gc 运行情况

![image-20241022230214280](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222302337.png)

```
S0C：第一个幸存区的大小，单位KB
S1C：第二个幸存区的大小
S0U：第一个幸存区的使用大小
S1U：第二个幸存区的使用大小
EC：伊甸园区的大小
EU：伊甸园区的使用大小
OC：老年代大小
OU：老年代使用大小
MC：方法区大小(元空间)
MU：方法区使用大小
CCSC:压缩类空间大小
CCSU:压缩类空间使用大小
YGC：年轻代垃圾回收次数
YGCT：年轻代垃圾回收消耗时间，单位s
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间，单位s
GCT：垃圾回收消耗总时间，单位s
```



jstat -gc PID 每2000ms 打印一次，总计打印10000次

![image-20241022230554017](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222305065.png)

统计minor gc,  Full gc 回收的频次，以及JVM 参数设置，就能大致推断出  每秒产生多大数据进入年轻代，每秒产生多大数据进入老年代

```
‐Xms1536M ‐Xmx1536M ‐Xmn512M ‐Xss256K ‐XX:SurvivorRatio=6 ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M
‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC ‐XX:CMSInitiatingOccupancyFraction=75 ‐XX:+UseCMSInitiatingOccupancyOnly

每天70次Full GC; 每天1000次yonggc

younggc 24 * 60 * 60 / 1000 =  8.64 s/次  
eden : 384M   
384/8.64= 44M  每秒生成44M对象进入到eden

Full GC   24*60*60/70 = 1234 s/次
old:1536M 
1536*0.75= 2194M 
结论：1234s 就有2194M 进入到老年代
```

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410222340393.png" alt="image-20241022234043340" style="zoom:50%;" />

程度中很多对象都是**朝生夕死**的,一个接口的平均执行时间不会超过2s.

**目的：主要减少full gc的次数, yonggc 次数因为程序的正常执行次数可能会很频繁** 。正常full gc 的频率是几乎不发生、或者几千小时

full gc 频繁的原因就要分析 对象为什么频繁进入到老年代    ->  对象进入老年代的条件

+ 达到对应的分代年龄  【如果不是发生内存泄露的话，一般来说不会有大量的这样数据，就算有一些缓存数据，第一次进入后，后续也不会那么频繁】
+ 大对象直接进入老年代  ： ***此时就需要检查dump中是否大量并且频繁生成的大对象。***
+ 动态年龄：对象进入到s1区后，如果容量到达 64 * 0.5 = 32 M 后,  较老的对象会进入到老年代中
+ 老年代空间担保机制：

每秒44M对象生成，但是动态年龄 ，s1容量很小。可以调大年轻代

Full gc 次数比younggc 次数多

1. 元空间不够
2. 老年代空间担保机制（老年代的空间不足）



为什么会老年代空间不足？是否有大量对象搬运到老年代

如果出现大量对象频繁搬运到老年代？

1. 正常达到分代年龄：说明线程执行的时间过长，就要分析cpu 较高的线程，一般有大量对象不断产生，对应的方法代码肯定会被频繁调用，占用的cpu必然较高：**减少调用次数**，**优化代码实现**
2. 内存泄露（重点检查map使用）



# arthas 

+ dashboard  查看运行情况 内存、线程 、GC 
+ thread [进程id]
+ thread -b 查看死锁线程

地址：https://arthas.aliyun.com/doc/quick-start.html

# gc 日志

根据回收情况来分析

工具：https://gceasy.io/

