实战分析：

从两方面着手

+ 修改案发现场的方法
+ jvm参数调优
+ gc 日志观察

通常是将二者结合

jvm 启动命令如下:

```sh
-Dapp.key=appraisal -Xms1G -Xmx4G -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Dspring.profiles.active=online -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.io.tmpdir=/qjyd/app/appraisal/work -Djava.net.preferIPv6Addresses=false -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/qjyd/log/ -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log -Xloggc:/qjyd/log/appraisal/gc-%t.log -XX:+UseG1GC -XX:G1ReservePercent=20 -javaagent:/qjyd/app/ArmsAgent-appraisal/arms-bootstrap-1.7.0-SNAPSHOT.jar -Dlogging.config=./config/log4j2/log4j2-online.xml
```

现象：

![image-20241030155449967](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410301558673.png)

机器内存 在 2024-10-28 14:39:00  之后骤降，之后机器可用内存就不回收。注zabbix 的图表不准，

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410301558874.png" alt="image-20241030155747270" style="zoom:50%;" />



![image-20241030175612099](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410301756265.png)

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410301759233.png" alt="image-20241030175912177" style="zoom:50%;" />

获取gc 日志，投入到easy gc 中分析， 发现问题重点在**young gc 频繁**，并且 **mixed gc 回收效率不高**，并且两次mixed gc 之间的间隔不大  mixed gc 效率不高意味着不应该触发的时候触发了mixed gc 或者老年代碎片化，回收的时候没有合适的region

结合jvm参数进行获取信息

-Xmx4G： 堆大小为 4G ，默认是2048 个region 

4 *  1024 / 2048 = 2M 【一个region 默认是2M】

年轻代初始大小  4096 * 0.05 = 204.8 M

年轻代最大大小  4096 * 0.6 =  2457.6 M



eden区大小：  204.8 * 8 /10 =  163.84 M  大约 164M

**eden 区的大小要以 gc 日志中的数据为准 。大致在 1419M左右**

s1 区大小： 204.8 * 1 /10 =  20M

如果对象大于 2M * 0.5 = 1M的话就会认为是大对象

老年代回收时内存占比    4096 * 0.45 =  1843.2 M





流程推测：

G1 在回收的时候会动态调整了eden 区的大小

在1s内有27 次young gc ，说明新生的对象很多，并且很快，才会导致 频繁的young gc ，

young gc 之后就会将数据复制到servior 区，servior 区数据增多的时候 就可能因为动态年龄导致就会有大量的数据进入老年代,  

又因为配置的ReservePercent = 20 % ，导致老年代空间不能全部使用，就会出发mixed  gc。在触发mix ed gc 的时候接口没有返回，所有老年代很多数据都是非垃圾，所以mixed  gc 的时候回收效率不高。而且mixed gc 触发也不是很频繁，所以老年代就会存了很多垃圾数据但是又回收不了。



 mixed gc 间隔不大：说明很快就达到老年代回收的临界条件，可能是有大对象直接进入，可以调大region大小，也有可能是动态年龄占比调整的太小；

mixed gc 回收效率不够： 老年代数据过于碎片化，可以调小region存活的数据占比。



调参第一版：

目地：通过调大 eden 区尽量减少young gc；增加回收的时间来尽可能的回收干净；提高动态年龄来保证进入老年代的数量少；增加region来避免大对象直接进入老年代；调大年轻代的占比，尽量避免进入老年代；

```sh
-Xm4G -Xmx4G 
-XX:MetaspaceSize=512m  -XX:MaxMetaspaceSize=512m 
-XX:HeapDumpPath=/qjyd/log/ -XX:+PrintGCDateStamps
-XX:+PrintGCDetails 
-XX:ErrorFile=/qjyd/log/hs_err_pid-%p.log 
-Xloggc:/qjyd/log/appraisal/gc-%t.log 
-XX:+UseG1GC 
-XX:G1ReservePercent=20 
-XX:G1NewSizePercent=20
-XX:G1HeadpRegionSize=4M
-XX:TargetSurvivorRatio=60
-XX:G1MaxNewSizePercent=65
-XX:G1MixedGCLiveThresholdPercent=80
-XX:MaxGCPauseMills=250
```



系统突然大量young gc 的时候，你会怎么分析？

```
young  gc 是有大量的对象进入到年轻代，因为年轻代容量不够，导致gc ，可以从两步去考虑，第一个检查年轻代是否配置的过小，g1 的年轻代默认是5% 的，如果机器内存太小的话，就很容易触发gc。第二是有大量对象创建，有可能是正常的大量请求，如果请求数量不多的话，就需要检查用时最长的接口，看看发生了什么，是否查询了大量数据。
```

系统突然大量full gc 的时候，你会怎么分析？

```
full gc 就是有大量对象进入老年代，考虑到进入老年代的规则， 大对象直接进入老年代、动态年龄机制，长期存活的对象，老年代空间担保机制也会导致大量full gc 。使用Serial 和parnew 垃圾收集器的时候检查jvm配置，看如何才算大对象。动态年龄就是要看servier 空间大小，如果太小的话， 很容易达到50%进入到老年代。长期存活的对象需要检查是否有静态map、ThreaLocal使用情况；如果多次回收效率不高的话，就有可能是内存泄露，就需要jmap  获取dump文件来分析啦。
```







