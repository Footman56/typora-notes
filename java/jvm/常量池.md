# class 常量池

Class常量池可以理解为是Class文件中的资源仓库。Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放**编译期**生成的各种**字面量**(Literal)和**符号引用**(Symbolic References)

在class文件中可以查看类中的常量

字面量：字母、数字等构成的字符串或者数值常量

符号引用：

+ 类和接口的全限定名    `T`
+ 字段的名称和描述符  `a`
+ 方法的名称和描述符    `getOne`

```java
public class T{
  public T getOne(String a){}
}
```

常量池现在是静态信息，只有到运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦被装入内存就变成运行时常量池

对应的符号引用在程序加载或运行时会被转变为被加载到内存区域的代码的直接引用，也就是我们说的动态链接了

getOne()这个符号引用在运行时就会被转变为getOne()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。



# 运行时常量池

在运行过程中，存储的的 字面量、符号引用等 在元空间

jdk 1.6 之后在永久代

jdk 1.8 之后 **字符串常量池就在堆中**，运行时常量池在堆中

```java
String s = "zhuge"; //  检查常量池中是否有zhuge ,有就返回，否则的话 就在常量池中创建
```

```
String s1 = new String("zhuge"); 
String s2 = s1.intern();
System.out.println(s1 == s2); //false
```

1. 在字符串常量池 创建 `zhuge`
2. 在堆中创建 `zhuge`  并且地址赋给 s1
3. s2 取的是字符串常量池中`zhuge`的地址

**intern() 返回的是常量池中的地址**





```java
public static void main(String[] args) throws InterruptedException {
        String str = "hello world" + "huochai";
    }
```

默认搞成一个字符串常量

![image-20241023223328212](https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410232233633.png)

```java
public static void main(String[] args) throws InterruptedException {
        String str1 = "hello world" ;
        String str2 = "huochai" ;
        String string = str1 + str2;
    }
```

这种对象的  + 拼接就转换成StringBuilder.append()

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410232235955.png" alt="image-20241023223530904" style="zoom:50%;" />



```java
String a = "ab";
final String bb = "b";
String b = "a" + bb;
System.out.println(a == b); 
```

final 修饰的对象 会变成 常量池中的

<img src="https://cdn.jsdelivr.net/gh/Footman56/imageBed2/202410232238803.png" alt="image-20241023223813756" style="zoom:50%;" />



# 对象池

**java中基本类型的包装类的大部分都实现了常量池技术**(严格来说应该叫对象池，在堆上)，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。

另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象