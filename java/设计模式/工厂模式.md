# 一、适用点

```
提供一种创建对象的有效方式
```

# 二、定义

```
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
主要解决：主要解决接口选择的问题。
何时使用：我们明确地计划不同条件下创建不同实例时。
如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
一个类只有一个返回另一个类的对象的方法，且不需要参数
```

# 三、结构

## 3.1 工厂方法模式

```
每一个工厂对应一个对象
```

<img src="/Users/mac/Library/Application Support/typora-user-images/image-20210530103815058.png" alt="image-20210530103815058" style="zoom:50%;" />

## 3.2 简单工厂模式

```
一个构造方法根据参数的不同创建不同的对象（if - else ） 
```

<img src="/Users/mac/Library/Application Support/typora-user-images/image-20210530103905803.png" alt="image-20210530103905803" style="zoom:50%;" />

**不符合开闭原则**

## 3.3 抽象工厂模式

```
每一个工厂生成相应的产品族
类中有多个创建类的函数，且每一个函数没有参数。为用户创建一系列相关的对象
若是有多个产品，工厂方法模式会有很多类，过于复杂。因此对产品进行管理。构建产品族。一个工厂对应一个产品族
产品族：产品族内的多个产品能够构成一个复杂的产品。类似Window系统、 Liunx系统。两个系统都含有文本，按钮类
一个工厂负责生产多个产品，这些产品能够组合成新的产品
```

<img src="/Users/mac/Library/Application Support/typora-user-images/image-20210530104024672.png" alt="image-20210530104024672" style="zoom:50%;" />

**违背单一职责原则**