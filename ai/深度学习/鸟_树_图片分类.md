

```python
# ===============================
# 强制 fastai + PyTorch 使用 CPU
# ===============================
import os

os.environ["CUDA_VISIBLE_DEVICES"] = ""  # 禁用 CUDA
os.environ["PYTORCH_ENABLE_MPS_FALLBACK"] = "1"  # 避免 MPS 报错
os.environ["PYTORCH_MPS_HIGH_WATERMARK_RATIO"] = "0.0"
import torch

torch.cuda.is_available = lambda: False
torch.backends.mps.is_available = lambda: False
torch.backends.mps.is_built = lambda: False

from ddgs import DDGS  # DuckDuckGo has changed the api so we need to update
from fastcore.all import *
import time, json
from fastdownload import download_url
from fastai.vision.all import *


# 彻底禁止 fastai 使用 GPU
defaults.device = torch.device('cpu')


# 查询图片的接口
def search_images(keywords, max_images=200):
    return L(DDGS().images(keywords, max_results=max_images)).itemgot('image')


# 搜索有两类搜索
searches = 'forest', 'bird'
path = Path('bird_or_not')

# 收集数据，收集收据的同时将图片进行分类
for o in searches:
    dest = (path / o)
    dest.mkdir(exist_ok=True, parents=True)
    # 下载图片到对应的目录
    download_images(dest, urls=search_images(f'{o} photo'))
    time.sleep(1)
    # 对图片进行压缩
    resize_images(path / o, max_size=400, dest=path / o)

# 处理错误的图片
failed = verify_images(get_image_files(path))
failed.map(Path.unlink)
len(failed)

# 您的数据加载代码
dls = DataBlock(
    blocks=(ImageBlock, CategoryBlock),
    get_items=get_image_files,
    splitter=RandomSplitter(valid_pct=0.2, seed=42),
    get_y=parent_label,
    item_tfms=[Resize(192, method='squish')]
).dataloaders(path, bs=32, device='cpu')

dls.show_batch(max_n=6)

# ====================================
# 创建 learner（不能传 device！）
# ====================================
learn = vision_learner(
    dls,
    resnet18,
    metrics=error_rate,
    pretrained=True,  # 正常加载
    normalize=True
)

# 禁用混合精度，否则 fastai 会尝试启用 GPU AMP
learn.to_fp32()

# 再确保模型在 CPU
learn.model.to('cpu')

# ====================================
# 训练
# ====================================

# 微调
learn.fine_tune(3)

is_bird, _, probs = learn.predict(PILImage.create('images.jpg'))
print(f"This is a: {is_bird}.")
print(f"Probability it's a bird: {probs[0]:.4f}")

```

- **`blocks=(ImageBlock, CategoryBlock)`**：定义数据块的类型
  - `ImageBlock`：输入是图像数据
  - `CategoryBlock`：输出是分类标签
- **`get_items=get_image_files`**：指定如何获取数据项
  - 使用 `get_image_files` 函数从路径中获取所有图像文件
- **`splitter=RandomSplitter(valid_pct=0.2, seed=42)`**：定义数据分割策略
  - 随机分割，20% 作为验证集
  - `seed=42` 确保每次分割结果一致
- **`get_y=parent_label`**：指定如何获取标签
  - 使用 `parent_label` 函数，根据图像所在文件夹名称作为类别标签
- **`item_tfms=[Resize(192, method='squish')]`**：定义数据预处理
  - `Resize(192)`：将所有图像调整为 192x192 像素
  - `method='squish'`：通过拉伸/压缩图像来适应目标尺寸

**`vision_learner()` 函数参数分析：**

- **`dls`**：数据加载器
  - 包含训练集和验证集的数据管道
  - 提供模型训练所需的批次数据
- **`resnet18`**：模型架构
  - 使用 ResNet-18 卷积神经网络
  - 18层深度，适合中等复杂度的图像分类任务
- **`metrics=error_rate`**：评估指标
  - `error_rate`：错误率（1 - 准确率）
  - 在训练过程中显示模型的性能指标
- **`pretrained=True`**：使用预训练权重
  - **关键作用**：使用在 ImageNet 数据集上预训练的权重初始化模型
  - **好处**：
    - 利用在大规模数据集上学到的通用特征
    - 大幅减少训练时间和所需数据量
    - 提高模型在小数据集上的性能
- **`normalize=True`**：数据标准化
  - 自动对输入图像进行标准化处理
  - 使用 ImageNet 数据集的均值和标准差：(0.485, 0.456, 0.406) 和 (0.229, 0.224, 0.225)
  - **作用**：使输入数据分布更稳定，加速模型收敛

**`fine_tune()` 方法分析：**

- **`3`**：训练周期数
  - 模型将训练 3 个完整的 epoch
- **`fine_tune()` 的内部工作流程**：
  1. **冻结特征提取层**（第一阶段）：
     - 只训练新添加的分类头（最后一层）
     - 保持预训练的特征提取器权重不变
     - 使用较低的学习率
  2. **解冻全部层**（第二阶段）：
     - 解冻所有层进行端到端训练
     - 使用差分学习率（不同层使用不同学习率）
     - 特征提取层使用较小学习率，分类层使用较大学习率