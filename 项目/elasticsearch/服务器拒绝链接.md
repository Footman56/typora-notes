目的：

+ 使用**连接池**且自动**复用连接**
+ 加上**连接失败重试机制**
+ 设置合理的**KeepAlive 和清理空闲连接策略**
+ 定期执行轻量级心跳请求，**保持连接活跃**

```java
@Configuration
public class ElasticSearchConfig extends AbstractElasticsearchConfiguration {

    @Value("${spring.elasticsearch.datacenter.uris}")
    private String datacenterEndpoints;
    @Value("${spring.elasticsearch.datacenter.username}")
    private String datacenterUsername;
    @Value("${spring.elasticsearch.datacenter.password}")
    private String datacenterPassword;

    @Value("${spring.elasticsearch.appraisal.uris}")
    private String appraisalEndpoints;
    @Value("${spring.elasticsearch.appraisal.username}")
    private String appraisalUsername;
    @Value("${spring.elasticsearch.appraisal.password}")
    private String appraisalPassword;

    @Bean("elasticsearchTemplate")
    @Primary
    public ElasticsearchRestTemplate elasticsearchTemplate() {
        return new ElasticsearchRestTemplate(restHighLevelClient());
    }

    @Bean("restHighLevelClient")
    @Primary
    @Override
    public RestHighLevelClient elasticsearchClient() {
        return createRestHighLevelClient(datacenterEndpoints, datacenterUsername, datacenterPassword);
    }

    @Bean("appraisalElasticsearchTemplate")
    public ElasticsearchRestTemplate appraisalElasticsearchTemplate() {
        return new ElasticsearchRestTemplate(appraisalRestHighLevelClient());
    }

    @Bean("appraisalRestHighLevelClient")
    public RestHighLevelClient appraisalRestHighLevelClient() {
        return createRestHighLevelClient(appraisalEndpoints, appraisalUsername, appraisalPassword);
    }

    /**
     * 通用构建 RestHighLevelClient 的方法
     */
    private RestHighLevelClient createRestHighLevelClient(String endpoints, String username, String password) {
        String[] hosts = endpoints.split(",");
        HttpHost[] httpHosts = Arrays.stream(hosts)
                .map(this::createHttpHost)
                .toArray(HttpHost[]::new);

        RestClientBuilder builder = RestClient.builder(httpHosts);

        // 请求超时设置
        builder.setRequestConfigCallback(requestConfigBuilder -> requestConfigBuilder
                .setConnectTimeout(5000)
                .setSocketTimeout(60000)
                .setConnectionRequestTimeout(0));

        // 安全认证配置
        if (StringUtils.isNotBlank(username)) {
            final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
            credentialsProvider.setCredentials(AuthScope.ANY,
                    new UsernamePasswordCredentials(username, password));

            builder.setHttpClientConfigCallback(httpClientBuilder -> httpClientBuilder
                    .setDefaultCredentialsProvider(credentialsProvider)
                    .setMaxConnTotal(100)
                    .setMaxConnPerRoute(20)
                    .evictIdleConnections(60, TimeUnit.SECONDS)
                    .setKeepAliveStrategy((response, context) -> 5 * 60 * 1000)); // 5分钟
        } else {
            builder.setHttpClientConfigCallback(httpClientBuilder -> httpClientBuilder
                    .setMaxConnTotal(100)
                    .setMaxConnPerRoute(20)
                    .evictIdleConnections(60, TimeUnit.SECONDS)
                    .setKeepAliveStrategy((response, context) -> 5 * 60 * 1000));
        }

        // 连接失败监听器
        builder.setFailureListener(new RestClient.FailureListener() {
            @Override
            public void onFailure(Node node) {
                System.err.println("ES节点连接失败: " + node.getHost());
            }
        });

        return new RestHighLevelClient(builder);
    }

    /**
     * 将 host:port 字符串转为 HttpHost
     */
    private HttpHost createHttpHost(String endpoint) {
        String[] parts = endpoint.split(":");
        String host = parts[0];
        int port = Integer.parseInt(parts[1]);
        return new HttpHost(host, port, "http"); // 如果是 https，这里改成 "https"
    }

    @Bean
    @Override
    public EntityMapper entityMapper() {
        ElasticsearchEntityMapper entityMapper = new ElasticsearchEntityMapper(elasticsearchMappingContext(),
                new DefaultConversionService());
        entityMapper.setConversions(elasticsearchCustomConversions());
        return entityMapper;
    }
}
```

# 配置定时任务注解

```java
@EnableScheduling
@SpringBootApplication
public class YourApplication {
    public static void main(String[] args) {
        SpringApplication.run(YourApplication.class, args);
    }
}
```

```java
import lombok.extern.slf4j.Slf4j;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class EsHeartbeatTask {

    private final RestHighLevelClient datacenterClient;
    private final RestHighLevelClient appraisalClient;

    public EsHeartbeatTask(
            @Qualifier("restHighLevelClient") RestHighLevelClient datacenterClient,
            @Qualifier("appraisalRestHighLevelClient") RestHighLevelClient appraisalClient) {
        this.datacenterClient = datacenterClient;
        this.appraisalClient = appraisalClient;
    }

    /**
     * 每5分钟ping一次datacenter ES实例
     */
    @Scheduled(fixedDelay = 5 * 60 * 1000) // 每5分钟
    public void pingDatacenterEs() {
        try {
            boolean alive = datacenterClient.ping(RequestOptions.DEFAULT);
            log.info("[ES心跳] datacenter ping 状态: {}", alive);
        } catch (Exception e) {
            log.warn("[ES心跳] datacenter ping 异常: {}", e.getMessage(), e);
        }
    }

    /**
     * 每5分钟ping一次appraisal ES实例
     */
    @Scheduled(fixedDelay = 5 * 60 * 1000, initialDelay = 60 * 1000) // 和上面错开1分钟
    public void pingAppraisalEs() {
        try {
            boolean alive = appraisalClient.ping(RequestOptions.DEFAULT);
            log.info("[ES心跳] appraisal ping 状态: {}", alive);
        } catch (Exception e) {
            log.warn("[ES心跳] appraisal ping 异常: {}", e.getMessage(), e);
        }
    }
}
```

