题目：

已知链表结构为 1->2->3->4->5 ,要求将链表反转过来。结果为：5->4->3->2->1 。

首先确定数据结构为链表，那么就要考虑java中是怎么实现链表这一数据结构的

# 解决一：迭代方式

迭代解决问题的思路是，尽量一次遍历对象，在遍历对象的过程中，设置多个全局变量来记录当前的状态，通过修改当前的状态值来实现要求的效果。

```java
/**
 * 链表反转
 *@author peilizhi
 *@date 2026/2/22 11:11
 **/
public class LinkedNodeReversal {

    public static class LinkedNode {
        private int value;
        private LinkedNode next;

        public LinkedNode(int value, LinkedNode next) {
            this.value = value;
            this.next = next;
        }
    }


    public static LinkedNode reverse(LinkedNode head) {
        // 需要将链表反转过来
        // 需要三个指针，pre、cur、next
        LinkedNode pre = null;
        LinkedNode cur = head;
        // 不确定循环的次数就使用while循环，循环结束的条件是遍历到链表的最后一个元素
        // 注意：链表遍历的节点和实际结果是两个对象
        while (cur != null) {
            // 需要先记录当前节点的状态，因为后续需要修改当前节点的指向
            LinkedNode next = cur.getNext();

            // 设置节点变更
            cur.setNext(pre);

            pre = cur;

            // 设置循环条件
            cur = next;
        }
        return pre;
    }


    public static void main(String[] args) {

        LinkedNode node5 = new LinkedNode(5, null);
        LinkedNode node4 = new LinkedNode(4, node5);
        LinkedNode node3 = new LinkedNode(3, node4);
        LinkedNode node2 = new LinkedNode(2, node3);
        LinkedNode node1 = new LinkedNode(1, node2);

        LinkedNode reverse = reverse(node1);
        System.out.println("reverse = " + reverse);

    }
}
```



# 解决二：递归

类似于树形结构，先由根节点找到叶子节点，从叶子节点开始处理问题，最终解决到根节点。 要求叶子节点和根节点的解决思路是已知的。

**树型结构非常适合递归** 

```java
 /**
     * 递归方式去解决问题；将大问题化成小问题，从小问题开始解决，解决完小问题就拼装成大问题的解决思路啦。
     * 与正常的遍历不同，递归是从后面解决问题。
     * 1->2->3->4->5->null
     * 1<2<3<4<5
     * @param head
     * @return
     */
    public static LinkedNode recursion(LinkedNode head) {
        // 递归的方式反转链表
        // 1.确定递归的出口，递归的出口是当前节点为null或者当前节点的下一个节点为null,
        if (head == null || head.getNext() == null) {
            return head;
        }
        // 2.确定递归的逻辑，递归的逻辑是将当前节点的下一个节点作为新的头节点，继续递归，直到找到链表的最后一个节点，最后一个节点就是新的头节点。
        // 在递归程序内的递归函数，参数要是下一个循环的参数，不能是这个函数的参数，否则就会死循环。
        LinkedNode newHead = recursion(head.getNext());
        // 3. 找到最后的节点之后，使用最后的节点或者当前的节点进行业务处理。
        // 4.最小问题的解决思路，
        head.getNext().setNext(head);
        head.setNext(null);
        
        // 注意这个返回的结果就是最终的结果，不能是递归函数的参数，否则就会死循环。
        return newHead;
    }
```

