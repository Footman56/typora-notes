# 问题： 连续最大递增子序列

贪心算法适合局部最优解能推导出全局最优解的情况

给定一个未经排序的整数数组，找到最长且连续递增的子序列并返回该序列的长度。序列的下标是连续的

解决思路：贪心算法。贪心算法使用于不知道最终结果，只能先求出局部的解，最终总和多个局部的解确定最终的解。

特点：在每次循环中如果满足条件都计算一次局部的解，**如果条件不符的话就重置状态**，在计算出局部解之后就比较是否为全局的解

```java
    private static int maxSeq(int[] nums) {
        // 最长序列长度
        int maxSeq = 0;
        // 序列开始的下标，如果不是递增的就获取队列长度，并且清空序列下标
        int start = 0;
        for (int i = 1; i < nums.length; i++) {
            // 如果当前元素比前一个元素小的话，就需要重新记录子序列位置
            if (nums[i] < nums[i - 1]) {
                // 重新开始计算，i-1是序列的最后一个元素
                // 计算当前子序列长度
                int seq = i - start;
                // 更新最长序列长度
                maxSeq = Math.max(maxSeq, seq);
                // i是新序列的开头
                start = i;
            } else {
                // 符合条件就继续计算子序列长度，直到不满足条件为止
                // 计算当前子序列长度
                int seq = i - start + 1;
                // 更新最长序列长度
                maxSeq = Math.max(maxSeq, seq);
            }
        }
        return maxSeq;
    }
```



# 问题：柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为5美元。顾客排队购买你的产品，一次购买一杯。每位顾客只买一杯柠檬水，然后向你付5美元、10美元或20美元。必须给每个顾客正确找零注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回true，否则返回false。

**在获取局部最优解的情况下不影响全局最优解**

问题本质就是遍历数组，检查数组的当前元素是否符合条件，并且有多种因素能够满足条件，**在这几种因素中综合选择最有利的情况**。

```java

    private static boolean change(int[] nums) {
        // 综合当前条件，检查数组中的元素是否能满足条件
        int five = 0;
        int ten = 0;
        for (int num : nums) {
            if (num == 5) {
                five++;
            } else if (num == 10) {
                // 10元只能找5块，如果有就成功，否则失败
                ten++;
                if (five > 0) {
                    five--;
                } else {
                    return false;
                }
            } else if (num == 20) {
                // 处理20元的时候有多种情况，综合选择一个10，5这种情况先找零「选择局部最优解」，
                // 如果没有的话就找3个5块的情况，如果都没有的话就失败
                if (ten > 0 && five > 0) {
                    ten--;
                    five--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
```

# 问题：三角形最大周长

给定由一些正数（代表长度）组成的数组 arr，返回由其中三个长度组成的、面积不为零的三角形的最大周长。如果不能形成任何面积不为零的三角形，返回、0。

需要满足周长最大，那么排序从大到小去找结果【局部最优解为最大长度】  贪心体现在 先找长度最大。

```java
 public static int largestPerimeter(int[] nums) {
        // 先对数组进行排序，方便后续处理
        Arrays.sort(nums);
        // 从后往前遍历，找到满足条件的三角形
        for (int i = nums.length - 1; i >= 2; i--) {
            // 判断当前三个数是否能组成三角形
            if (nums[i] < nums[i - 1] + nums[i - 2]) {
                // 如果满足条件，返回周长
                return nums[i] + nums[i - 1] + nums[i - 2];
            }
        }
        // 如果没有找到满足条件的三角形，返回0
        return 0;
    } 
```

