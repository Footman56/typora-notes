问题：求二叉树的最小深度

解题思路：广度优先

特点是一层级一层级的遍历，所有兄弟节点未遍历完时，不去找子节点

```java
/**
     * 广度优先算法： 队列实现
     * @param root
     * @return
     */
    private static int minDepth2(BTreeNode root) {
        if (null == root) {
            return 0;
        }
        // 这里用一个队列来实现广度优先算法，先进先出
        Queue<BTreeNode> queue = new LinkedList<>();

        // 先把根节点放入队列中
        root.setDepth(1);
        queue.offer(root);
        // 只要队列不为空，就一直处理
        while (!queue.isEmpty()) {
            // 从队列头弹出一个节点
            BTreeNode node = queue.poll();

            // 判断这个节点是否有子节点，如果没有的话，就说明遍历到叶子节点，深度就是叶子节点的深度
            if (node.getLeft() == null && node.getRight() == null) {
                // 如果没有子节点了，说明找到了一个叶子节点，直接返回当前深度
                return node.getDepth();
            }

            // 如果有左节点，左节点入队列，并且设置深度
            if (node.getLeft() != null) {
                node.getLeft().setDepth(node.getDepth() + 1);
                queue.offer(node.getLeft());
            }
            // 如果有右节点，右节点入队列，并且设置深度
            if (node.getRight() != null) {
                node.getRight().setDepth(node.getDepth() + 1);
                queue.offer(node.getRight());
            }

        }

        return 0;
    }

```

