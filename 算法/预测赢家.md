问题：给定一个表示分数的非负整数数组。玩家1 从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿。。。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设**每个玩家的玩法都会使他的分数最大化。**

解题思路：

1. 检查是否可以递归解决问题

2. 显然，可以算作递归（从左边或者右边拿一个之后，B拿，之后又是从左边或者右边拿一个）

3. 考虑递归的三要素

   1. 递归接口的含义 ： 从数组中去最大值

   2. 递归的出口：这一步就是推导 

      如果有一个的话： 就取唯一的一个

      如果有两个的话：就取最大的一个

      如果有三个的话： a:  先取左或者先右  b有两个， b 也可以选左或者选右，取左还是取右是根据余下的都是小的

      如果有四个的话： a:  先取左或者先右  b有三个，就转换成b有三个的问题， 但b一定会留下最小的

   3. 递归的推导公式 就类似 f(n) = f(n-1) * a 这种操作

      1. 可以选择左或者选右，但一定是左或者右的最大值，就需要穷举左侧的情况，右侧的情况，之后取最大值



```java

    /**
     * 根据输入的数组判断是否可以赢
     * @param arr
     * @return
     */
    public static boolean canWin(int[] arr) {

        int start = 0;
        int end = arr.length - 1;
        // 求总和
        int sum = 0;
        for (int i : arr) {
            sum += i;
        }
        int aSum = sumMaxScore(arr, start, end);
        // a赢的条件就是a的分数大于剩余的分数
        return aSum > sum - aSum;
    }


    /**
     * 递归接口：计算当前情况的最大值 不能采用贪心算法，会导致达不到全局最优解
     * 通常都有一个参数，不同的递归情况，参数值发生变成
     * @param arr 数组
     * @param start 开始下标
     * @param end 结束下标
     *            为什么设置两个下标来表示当前的情况呢？因为每次递归都会改变当前的情况，改变的方式就是改变下标的值
     * @return
     */
    private static int sumMaxScore(int[] arr, int start, int end) {
        // 递归出口
        if (start == end) {
            // 只有一个的时候
            return arr[start];
        }
        if (end - start == 1) {
            // 有两个的时候，选最大的
            return Math.max(arr[start], arr[end]);
        }

        // 剩余多个的时候，无外乎就两个操作，选左或者选右
        int sumLeft = 0;
        int sumRight = 0;

        // a取左边的情况   b取左边的情况  那么a最大的情况就是 sumMaxScore(arr, start + 2, end)
        //               b取右边的情况  那么a最大的情况就是 sumMaxScore(arr, start + 1, end - 1) 。b一定要赢的话，那么会最小的情况
        sumLeft = arr[start] + Math.min(sumMaxScore(arr, start + 2, end), sumMaxScore(arr, start + 1, end - 1));


        // a取右边的情况   b取左边的情况  那么a最大的情况就是 sumMaxScore(arr, start + 1, end - 1)
        //               b取右边的情况  那么a最大的情况就是 sumMaxScore(arr, start, end - 2) 。b一定要赢的话，那么会最小的情况
        sumRight = arr[end] + Math.min(sumMaxScore(arr, start + 1, end - 1), sumMaxScore(arr, start, end - 2));

        // 最终选择的是左边或者右边最大的
        return Math.max(sumLeft, sumRight);
    }

    public static void main(String[] args) {

        int[] arr = new int[]{5, 200, 4, 3};

        /**
         * 3 {5,4} 4 {200,5} 200   3+4+200 = 207   b在面临选完3之后，会剩下 {5,200} ,{200,4} 中最小的: 这里是全局最小的，不是局部最小的
         *         5 {200,4} 200   3+5+200 = 208
         * 5 {200,3} 200 {4,3} 3   5+200+3 = 215  [done]
         */
        System.out.println("canWin(arr) = " + canWin(arr));
    }
```

