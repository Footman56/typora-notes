问题：总共有n枚硬币，将它们摆成一个阶梯形状，第K行必须正好有k枚硬币。给定一个数字n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。



# 思路一：暴力迭代求解

```java
 /**
     * 逐行累加，如果超过硬币数的话，就是当前行
     * @param n
     * @return
     */
    public static int arrange(int n) {
        // 需要找到满足条件的最大行数
        int row = 0;
        // 需要一个变量来记录当前已经使用的硬币数量
        int count = 0;
        while (count <= n) {
            row++;
            count += row;
        }
        return row - 1;
    }
```



# 思路二：二分查找法

时间复杂度为log（n）

```java

    // 转换成二分查找，就是在1，n 行之间找到一个x，要求 1+2+3+...+x <= n, 也就是 x*(x+1)/2 <= n
    // 重点公式为：1+2+3+...+x = x*(x+1)/2
    public static int arrange2(int n) {
        // 开始和结尾下标
        int left = 1;
        int right = n;

        while (left <= right) {
            // 取中间的行数
            int mid = left + (right - left) / 2;
            // 计算mid行所需要的硬币数
            int sum = mid * (mid + 1) / 2;

            if (sum == n) {
                // 刚好mid行需要的硬币数等于n，直接返回mid
                return mid;
            } else if (sum < n) {
                // mid行需要的硬币数小于n，说明mid行是满足条件的，继续往右边找更大的行数
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return right;
    }
```

# 思路三： 牛顿迭代法

```java
// 对二分查找进一步优化成牛顿迭代
    // 已知要求的是 x(x+1)/2 = n, 可以转换成 x^2 =  2n -x , 带入牛顿迭代公式是 (x+ a/x)/2 其中 x^2=a,
    // 那么得到公式为 (x + (2n-x)/x)/2

    public static int arrange3(int n) {
        if (n == 0) {
            return 0;
        }
        return (int) sqrt(n, n);
    }


    /**
     *
     * @param x 预计值
     * @param n y值
     * @return
     */
    public static double sqrt(double x, int n) {
        if (x == 0) {
            return 0;
        }
        // 通过递归不断的求解，直到结果不再变化为止
        double res = (x + (2 * n - x) / x) / 2;
        // 一直计算到java中double类型的精度范围内，结果不再变化为止
        if (res == x) {
            return res;
        }
        return sqrt(res, n);
    }
```

