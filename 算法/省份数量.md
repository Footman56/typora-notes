问题：有n个城市，其中一些彼此相连，另一些没有相连。如果城市a与城市b直接相连，且城市b与城市c直接相连，那么城市a与城市c间
接相连。省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 n xn 的矩阵isConnected，其中 isConnected［illil = 1表示第i个城市和第j个城市直接相连，而isConnected［ilijl = 0 表示二者不直接相连。返回矩阵中 省份 的数量。

本质就是分组问题，能分几个组就有几个省份。这一组就是多个有关联的节点组成，可以采用深度优先、广度优先的方式去找。

在分组的时候需要注意已经分组的节点就不能再次分组啦（通过这一特性就能找出有多少组）





# 思路一：深度优先

这类题目 一般都需要一个标志位来是否遍历过，是否为相同的分组。

```java
 /**
     * 通过深度优先搜索统计省份
     * @param isConnected
     * @return
     */
    public static int getProvince(int[][] isConnected) {
        // 省份数量
        int count = 0;
        // 是否访问过，如果访问过就说明已经分组啦，没有访问过就是未分组，自己成一组
        boolean[] visited = new boolean[isConnected.length];
        for (int i = 0; i < isConnected.length; i++) {
            if (!visited[i]) {
                dfs(i, visited, isConnected);
                // 省份+1
                count++;
            }
        }
        return count;
    }

    /**
     * 对i进行搜索，找到相同的分组
     * @param i
     * @param visited
     * @param isConnected
     */
    private static void dfs(int i, boolean[] visited, int[][] isConnected) {
        int length = isConnected.length;

        // 遍历所有的城市，检查是否有符合的分组
        for (int j = 0; j < length; j++) {
            // 如果i和j是同一组，并且j没有访问过，就继续对j进行搜索，找到j的分组
            if (isConnected[i][j] == 1 && !visited[j]) {
                visited[j] = true;
                // 继续对j进行搜索,提醒深度搜索的原理
                dfs(j, visited, isConnected);
            }
        }
    }
```