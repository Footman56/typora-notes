问题：有n个城市，其中一些彼此相连，另一些没有相连。如果城市a与城市b直接相连，且城市b与城市c直接相连，那么城市a与城市c间
接相连。省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 n xn 的矩阵isConnected，其中 isConnected［illil = 1表示第i个城市和第j个城市直接相连，而isConnected［ilijl = 0 表示二者不直接相连。返回矩阵中 省份 的数量。

本质就是分组问题，能分几个组就有几个省份。这一组就是多个有关联的节点组成，可以采用深度优先、广度优先的方式去找。

在分组的时候需要注意已经分组的节点就不能再次分组啦（通过这一特性就能找出有多少组）





# 思路一：深度优先

这类题目 一般都需要一个标志位来是否遍历过，是否为相同的分组。

```java
 /**
     * 通过深度优先搜索统计省份
     * @param isConnected
     * @return
     */
    public static int getProvince(int[][] isConnected) {
        // 省份数量
        int count = 0;
        // 是否访问过，如果访问过就说明已经分组啦，没有访问过就是未分组，自己成一组
        boolean[] visited = new boolean[isConnected.length];
        for (int i = 0; i < isConnected.length; i++) {
            if (!visited[i]) {
                dfs(i, visited, isConnected);
                // 省份+1
                count++;
            }
        }
        return count;
    }

    /**
     * 对i进行搜索，找到相同的分组
     * @param i
     * @param visited
     * @param isConnected
     */
    private static void dfs(int i, boolean[] visited, int[][] isConnected) {
        int length = isConnected.length;

        // 遍历所有的城市，检查是否有符合的分组
        for (int j = 0; j < length; j++) {
            // 如果i和j是同一组，并且j没有访问过，就继续对j进行搜索，找到j的分组
            if (isConnected[i][j] == 1 && !visited[j]) {
                visited[j] = true;
                // 继续对j进行搜索,提醒深度搜索的原理
                dfs(j, visited, isConnected);
            }
        }
    }
```



# 思路二： 广度优先

广度优先通常采用 Queue 来实现，借助队列的先进先出的特点，将根节点和直接关联的叶子节点入队列，然后按顺序出队列，在找子节点，一直循环到都处理完为止。

```java
/**
     * 通过广度优先搜索统计省份
     * @param isConnected
     * @return
     */
    public static int getProvince1(int[][] isConnected) {
        // 省份数量
        int count = 0;
        // 是否访问过，如果访问过就说明已经分组啦，没有访问过就是未分组，自己成一组
        boolean[] visited = new boolean[isConnected.length];

        // 广度优先通过Queue来实现
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < isConnected.length; i++) {
            if (!visited[i]) {
                // 把当前城市入队列
                queue.offer(i);

                // 将所有关联的城市都入队列
                while (!queue.isEmpty()) {
                    int city = queue.poll();
                    visited[city] = true;

                    // 遍历所有的城市，检查是否有符合的分组
                    for (int j = 0; j < isConnected.length; j++) {
                        // 如果city和j是同一组，并且j没有访问过，就继续对j进行搜索，找到j的分组
                        if (isConnected[city][j] == 1 && !visited[j]) {
                            queue.offer(j);
                        }
                    }
                }
                // 省份+1
                count++;
            }
        }
        return count;
    }
```

#  思路三： 并查集

如果两个节点有关联的话，那么这两棵树就是关联的。将所有的有关系的树合并之后 就是所有的组合啦。

合并操作就是 找根，将层次小的合并到层次高的。

并查集 借助一个数组来完成，数组的下标就是节点，数组的值就是根。有多少个下标与根相同就有多少组。

合并操作：

1. 首先找根节点 (递归方式查询根节点，找到后就同步，下次就直接查)
2. 获取根节点的深度
3. 将深度小的根设置为深度大的
4. 修改根的深度（作用不大），只需要修改根深度相同的

```java
 /**
     * 通过并查集搜索统计省份
     * @param isConnected
     * @return
     */
    public static int getProvince2(int[][] isConnected) {

        int countCity = isConnected.length;

        // 根节点
        int[] head = new int[countCity];
        // 深度
        int[] depth = new int[countCity];

        // 为根节点、深度赋初值
        for (int i = 0; i < countCity; i++) {
            // 下标就是城市编号，值就是根节点编号，初始时每个城市都是自己的根节点
            head[i] = i;
            depth[i] = 1;
        }

        for (int i = 0; i < countCity; i++) {
            for (int j = i + 1; j < countCity; j++) {
                // 如果i和j是同一组，就把i和j合并成一组
                if (isConnected[i][j] == 1) {
                    // 执行合并操作
                    merge(i, j, head, depth);
                }
            }
        }

        // 省份数量
        int count = 0;
        // 统计省份数量，根节点的数量就是省份的数量
        for (int i = 0; i < countCity; i++) {
            if (head[i] == i) {
                count++;
            }
        }
        return count;
    }


    private static void merge(int x, int y, int[] head, int[] depth) {
        // 找到对应的根节点
        int headX = find(x, head);
        int headY = find(y, head);

        // 根节点相同的话不需要合并
        if (headX == headY) {
            return;
        }

        // 修改根节点
        if (depth[headX] <= depth[headY]) {
            head[headX] = headY;
        } else {
            head[headY] = headX;
        }

        // 修改根的深度
        if (depth[headX] == depth[headY]) {
            depth[headY]++;
            depth[headX]++;
        }
    }

    /**
     * 找对应的根节点
     * @param x
     * @param head
     * @return
     */
    private static int find(int x, int[] head) {
        if (x == head[x]) {
            return x;
        } else {
            // 路径压缩，直接把x的根节点赋值给x
            head[x] = find(head[x], head);
            return head[x];
        }
    }


```

