前序遍历 ： 根左右

中序遍历： 左根右

后序遍历： 左右根

层序遍历： 从上到下，从左到右

遇到问题：可以考虑是否使用合适的数据结构，合适的数据结构能够有效的解决问题

先进先出 ： 队列    Queue<BTreeNode> queue = new LinkedList<>();

先进后出： 堆栈  Stack

# 前序遍历-递归

```java
 /**
     * 前序遍历： 根左右
     * @param root
     */
    public static void preOrder(BTreeNode root) {
        if (null == root) {
            return;
        }
        // 先处理当前节点
        System.out.println(root.getValue());
        // 处理左子树
        preOrder(root.getLeft());
        // 处理右子树
        preOrder(root.getRight());
    }
```

# 中序遍历-递归

```java
/**
     * 中序遍历：左根右
     * @param root
     */
    public static void inOrder(BTreeNode root) {
        if (null == root) {
            return;
        }
        // 处理左子树
        inOrder(root.getLeft());
        // 先处理当前节点
        System.out.println(root.getValue());
        // 处理右子树
        inOrder(root.getRight());
    }

```

# 后续遍历-递归

```java

    /**
     * 后续遍历：左右根
     * @param root
     */
    public static void postOrder(BTreeNode root) {
        if (null == root) {
            return;
        }
        // 处理左子树
        postOrder(root.getLeft());
        // 处理右子树
        postOrder(root.getRight());
        // 先处理当前节点
        System.out.println(root.getValue());
    }
```



# 层次遍历

使用递归来完成层次遍历，由于递归是向深度搜索，不能直接遍历，需要借助递归遍历来获取所有的元素，将这些元素存入集合中，最后遍历集合来实现层次遍历

```java
 /**
     * 层次遍历：递归遍历，使用集合来存储结果
     * @param root
     */
    public static void levelOrder1(BTreeNode root) {
        if (null == root) {
            return;
        }

        int i = 1;
        List<Integer> list = new ArrayList<>();

        // 通过递归来遍历二叉树，遍历的同时将节点存入集合中
        recursiveFunc(root, list, i);

        // 打印list
        System.out.println(Arrays.toString(list.toArray()));
    }


    private static void recursiveFunc(BTreeNode root, List<Integer> list, int i) {
        if (null == root) {
            return;
        }
        // 注意如果i大于list的长度时会报错的，需要将list进行扩容
        int length = list.size();
        if (i >= length) {
            // 扩容，扩容的方式是将list的长度翻倍
            for (int j = 0; j <= i - length; j++) {
                list.add(length + j, null);
            }
        }
        // 先将根节点存入集合中
        list.set(i, root.getValue());
        // 处理左子树 左节点的下标为2 * i
        recursiveFunc(root.getLeft(), list, 2 * i);
        // 处理右子树 右节点的下标为2 * i + 1
        recursiveFunc(root.getRight(), list, 2 * i + 1);
    }
```

 简单一点的就使用队列来实现，队列的特点是先进先出，左右节点进入，在出来找左右节点的子节点

```java
/**
     * 层次遍历：一层一层的遍历，使用队列实现
     * @param root
     */
    public static void levelOrder(BTreeNode root) {
        if (null == root) {
            return;
        }
        // 这里用一个队列来实现层序遍历，先进先出
        Queue<BTreeNode> queue = new LinkedList<>();
        // 先把根节点放入队列中
        queue.offer(root);
        // 只要队列不为空，就一直处理
        while (!queue.isEmpty()) {
            // 从队列头弹出一个节点
            BTreeNode node = queue.poll();
            // 处理当前节点
            System.out.println(node.getValue());
            // 如果有左节点，左节点入队列
            if (node.getLeft() != null) {
                queue.offer(node.getLeft());
            }
            // 如果有右节点，右节点入队列
            if (node.getRight() != null) {
                queue.offer(node.getRight());
            }
        }
    }
```

# 前序遍历-迭代

由递归变成迭代的思路就是 使用堆栈来模拟递归调用