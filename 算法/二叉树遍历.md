前序遍历 ： 根左右

中序遍历： 左根右

后序遍历： 左右根

层序遍历： 从上到下，从左到右



# 前序遍历

```java
 /**
     * 前序遍历： 根左右
     * @param root
     */
    public static void preOrder(BTreeNode root) {
        if (null == root) {
            return;
        }
        // 先处理当前节点
        System.out.println(root.getValue());
        // 处理左子树
        preOrder(root.getLeft());
        // 处理右子树
        preOrder(root.getRight());
    }
```

# 中序遍历

```java
/**
     * 中序遍历：左根右
     * @param root
     */
    public static void inOrder(BTreeNode root) {
        if (null == root) {
            return;
        }
        // 处理左子树
        inOrder(root.getLeft());
        // 先处理当前节点
        System.out.println(root.getValue());
        // 处理右子树
        inOrder(root.getRight());
    }

```

# 后续遍历

```java

    /**
     * 后续遍历：左右根
     * @param root
     */
    public static void postOrder(BTreeNode root) {
        if (null == root) {
            return;
        }
        // 处理左子树
        postOrder(root.getLeft());
        // 处理右子树
        postOrder(root.getRight());
        // 先处理当前节点
        System.out.println(root.getValue());
    }
```



# 层次遍历

使用递归来完成层次遍历，由于递归是向深度搜索，不能直接遍历，需要借助递归遍历来获取所有的元素，将这些元素存入集合中，最后遍历集合来实现层次遍历

```java
 /**
     * 层次遍历：递归遍历，使用集合来存储结果
     * @param root
     */
    public static void levelOrder1(BTreeNode root) {
        if (null == root) {
            return;
        }

        int i = 1;
        List<Integer> list = new ArrayList<>();

        // 通过递归来遍历二叉树，遍历的同时将节点存入集合中
        recursiveFunc(root, list, i);

        // 打印list
        System.out.println(Arrays.toString(list.toArray()));
    }


    private static void recursiveFunc(BTreeNode root, List<Integer> list, int i) {
        if (null == root) {
            return;
        }
        // 注意如果i大于list的长度时会报错的，需要将list进行扩容
        int length = list.size();
        if (i >= length) {
            // 扩容，扩容的方式是将list的长度翻倍
            for (int j = 0; j <= i - length; j++) {
                list.add(length + j, null);
            }
        }
        // 先将根节点存入集合中
        list.set(i, root.getValue());
        // 处理左子树 左节点的下标为2 * i
        recursiveFunc(root.getLeft(), list, 2 * i);
        // 处理右子树 右节点的下标为2 * i + 1
        recursiveFunc(root.getRight(), list, 2 * i + 1);
    }
```

 简单一点的就使用队列来实现，队列的特点是先进先出，左右节点进入，在出来找左右节点的子节点

```java
```

