问题：

两个有序整数数组 numsl 和 nums2，将nums2 合并到nums1 中，使numsl成为一个有序数组。初始化 nums1 和nums2 的元素数量分别为m和n。假设nums1的空间大小等于 m +n，这样它就有足够的空间保存来自 nums2 的元素。



# 思路一：借助封装好的工具方法

```java
 /**
     * 合并num2数据到num1中
     * @param num1
     * @param n
     * @param num2
     * @param m
     * @return
     */
    public static int[] merge(int[] num1, int n, int[] num2, int m) {
        // 1. 先迁移数据到num1的末尾
        System.arraycopy(num2, 0, num1, n, m);
        // 2. 对num1进行排序
        Arrays.sort(num1);
        return num1;
    }

```

# 思路二：创建一个新的数组来接受

属于双指针的变形，两个指针指向的是两个数组的下标，不是简单的一个数组

```java
 /**
     * 创建一个新的数据来存储合并后的数据
     * @param num1
     * @param n
     * @param num2
     * @param m
     * @return
     */
    public static int[] merge1(int[] num1, int n, int[] num2, int m) {
        int[] num1Copy = new int[n + m];
        // 1. 先迁移数据到num1Copy中，使用num1来存储结果
        System.arraycopy(num1, 0, num1Copy, 0, n);

        // 2.需要记录数组的下标
        int p1 = 0; // num1Copy的下标
        int p2 = 0; // num2的下标
        int p = 0; // num1的下标
        // 3. 不确定循环的次数就使用while循环
        // 循环截止的条件是有任意一个数组处理就行了，就一个数组就直接copy剩余的元素就行了
        while(p1 < n && p2 <m ){
            // 判断哪个数据小就覆盖num1的数据,并且对应的下标向后移动
            num1[p++] = num1Copy[p1] < num2[p2] ? num1Copy[p1++] : num2[p2++];
        }

        // 检查哪个数组是否还有剩余，有剩余的话就直接copy剩余的元素到num1中
        if (p1 < n) {
            System.arraycopy(num1Copy, p1, num1, p, n - p1);
        }
        if (p2 < m) {
            System.arraycopy(num2, p2, num1, p, m - p2);
        }

        return num1;
    }
```



# 思路三：将元素从大到小排列到num1的后面

```
```

