



问题:求二叉树最小深度。

思路：深度优先算法。

1. 将大问题拆分成小问题 （求整颗树的深度转换成求每一个节点的深度）
2. 对小问题的结果进行组装 （比较左右节点的深度，取最小的 +1 作为当前节点的深度）
3. 返回实际节点的深度「先递归遍历，再对数据进行操作」

```java

    /**
     *
     * @param root
     * @return
     */
    private static int minDepth(BTreeNode root) {
        if (null == root) {
            return 0;
        }
        // 递归结束的条件，找到叶子节点啦，叶子深度为1
        if (root.getLeft() == null && root.getRight() == null) {
            return 1;
        }
        // 取左右两个节点的最小值,这个变量其实不是全局变量，只要比较当前节点 叶子的最小值就可以去定当前深度。就返回给上一级去使用可以
        int minDepth = Integer.MAX_VALUE;
        
        // 这种有条件就进行的判断就比较好，能避免一些不必要的递归调用，减少一些性能损耗
        if (root.getLeft() != null) {
            // 有左节点的话，就处理左节点的深度
            minDepth = Math.min(minDepth(root.getLeft()), minDepth);
        }
        if (root.getRight() != null) {
            // 有右节点的话，就处理右节点的深度
            minDepth = Math.min(minDepth(root.getRight()), minDepth);
        }
        // 最后加上当前节点的深度1
        return minDepth + 1;
    }


    public static void main(String[] args) {

        BTreeNode node7 = new BTreeNode(7, null, null);
        BTreeNode node6 = new BTreeNode(6, null, node7);
        BTreeNode node5 = new BTreeNode(5, null, null);
        BTreeNode node4 = new BTreeNode(4, null, null);
        BTreeNode node3 = new BTreeNode(3, node5, node6);
        BTreeNode node2 = new BTreeNode(2, node4, null);
        BTreeNode node1 = new BTreeNode(1, node2, node3);

        int minDepth = minDepth(node1);
        System.out.println(minDepth);


    }
```

